<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>FreeRTOS学习笔记 | 林守拙的个人空间</title><meta name="author" content="林守拙"><meta name="copyright" content="林守拙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="FreeRTOS学习笔记1、简介FreeRTOS 是一个 RTOS 类的嵌入式实时操作系统。它的社会占有量很高，许多半导体厂商产品的 SDK 包就使用 FreeRTOS 作为其操作系统，尤其是 WIFI、蓝牙这些带协议栈的芯片或模块。 FreeRTOS 的内核支持抢占式， 合作式和时间片调度。任务与任务、 任务与中断之间可以使用任务通知、消息队列、二值信号量、数值型信号量、 递归互斥信号量和互斥信">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS学习笔记">
<meta property="og:url" content="http://example.com/2023/08/16/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="林守拙的个人空间">
<meta property="og:description" content="FreeRTOS学习笔记1、简介FreeRTOS 是一个 RTOS 类的嵌入式实时操作系统。它的社会占有量很高，许多半导体厂商产品的 SDK 包就使用 FreeRTOS 作为其操作系统，尤其是 WIFI、蓝牙这些带协议栈的芯片或模块。 FreeRTOS 的内核支持抢占式， 合作式和时间片调度。任务与任务、 任务与中断之间可以使用任务通知、消息队列、二值信号量、数值型信号量、 递归互斥信号量和互斥信">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bingbing2_corrosion_port.jpg">
<meta property="article:published_time" content="2023-08-16T14:07:49.000Z">
<meta property="article:modified_time" content="2023-11-01T13:26:48.618Z">
<meta property="article:author" content="林守拙">
<meta property="article:tag" content="STM32">
<meta property="article:tag" content="FreeRTOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/bingbing2_corrosion_port.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/08/16/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-01 21:26:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/bingbing2_corrosion_port.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/6.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="林守拙的个人空间"><span class="site-name">林守拙的个人空间</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-16T14:07:49.000Z" title="发表于 2023-08-16 22:07:49">2023-08-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-01T13:26:48.618Z" title="更新于 2023-11-01 21:26:48">2023-11-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="FreeRTOS学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="FreeRTOS学习笔记"><a href="#FreeRTOS学习笔记" class="headerlink" title="FreeRTOS学习笔记"></a>FreeRTOS学习笔记</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>FreeRTOS</strong> 是一个 RTOS 类的嵌入式实时操作系统。它的社会占有量很高，许多半导体厂商产品的 SDK 包就使用 FreeRTOS 作为其操作系统，尤其是 WIFI、蓝牙这些带协议栈的芯片或模块。</p>
<p><strong>FreeRTOS 的内核支持抢占式， 合作式和时间片调度。</strong>任务与任务、 任务与中断之间可以使用<strong>任务通知、消息队列、二值信号量、数值型信号量、 递归互斥信号量和互斥信号量进行通信和同步</strong>。</p>
<h3 id="1-1-任务"><a href="#1-1-任务" class="headerlink" title="1.1 任务"></a>1.1 任务</h3><p><strong>RTOS 系统的核心就是任务管理， FreeRTOS 是一个抢占式的实时多任务系统</strong>， 其任务调度器也是<strong>抢占式</strong>的。<strong>高优先级的任务可以打断低优先级任务的运行</strong>而取得 CPU 的使用权，这样就保证了那些紧急任务的运行。 这样我们就可以为那些对实时性要求高的任务设置一个很高的优先级。 高优先级的任务执行完成以后重新把 CPU 的使用权归还给低优先级的任务，这个就是抢占式多任务系统的基本原理。</p>
<p><strong>在使用 RTOS 的时候一个实时应用可以作为一个独立的任务</strong>。每个任务都有自己的运行环境， 不依赖于系统中其他的任务或者 RTOS 调度器。 <strong>任何一个时间点只能有一个任务运行，具体运行哪个任务是由 RTOS 调度器来决定的</strong>， RTOS 调度器因此就会重复的开启、关闭每个任务。</p>
<p>任务不需要了解 RTOS 调度器的具体行为， RTOS 调度器的职责是确保当一个任务开始执行的时候其上下文环境(寄存器值，堆栈内容等)和任务上一次退出的时候相同。 为了做到这一点，<strong>每个任务都必须有个堆栈，当任务切换的时候将上下文环境保存在堆栈中</strong>，这样当任务再次执行的时候就可以从堆栈中取出上下文环境， 任务恢复运行。</p>
<h3 id="1-2-任务状态"><a href="#1-2-任务状态" class="headerlink" title="1.2 任务状态"></a>1.2 任务状态</h3><p><strong>FreeRTOS 中的任务永远处于下面几个状态中的某一个：</strong></p>
<ul>
<li><strong>运行态</strong><br>   当一个任务正在运行时， 那么就说这个任务处于运行态， 处于运行态的任务就是当前正在使用处理器的任务。 如果使用的是单核处理器的话那么不管在任何时刻永远都只有一个任务处于运行态。</li>
<li><strong>就绪态</strong><br>  处于就绪态的任务是那些已经准备就绪(这些任务没有被阻塞或者挂起)， 可以运行的任务，但是<strong>处于就绪态的任务还没有运行，因为有一个同优先级或者更高优先级的任务正在运行！</strong></li>
<li><strong>阻塞态</strong><br>  <strong>如果一个任务当前正在等待某个外部事件的话就说它处于阻塞态</strong>， 比如说如果某个任务调用了函数 vTaskDelay()的话就会进入阻塞态， 直到延时周期完成。<strong>任务在等待队列、信号量、事件组、通知或互斥信号量的时候也会进入阻塞态。</strong>任务进入阻塞态会有一个超时时间，当超过这个超时时间任务就会退出阻塞态，即使所等待的事件还没有来临！</li>
<li><strong>挂起态</strong><br>  像阻塞态一样，任务进入挂起态以后也不能被调度器调用进入运行态， 但是<strong>进入挂起态的任务没有超时时间</strong>。任务进入和退出挂起态通过调用函数 <code>vTaskSuspend()</code>和 <code>xTaskResume()</code>。</li>
</ul>
<h3 id="1-3-任务优先级"><a href="#1-3-任务优先级" class="headerlink" title="1.3 任务优先级"></a>1.3 任务优先级</h3><p>每 个 任 务 都 可 以 分 配 一 个 从 <code>0 ~ configMAX_PRIORITIES-1</code> 的 优 先 级 ，<code>configMAX_PRIORITIES</code>在文件<code>FreeRTOSConfig.h</code> 中有定义。</p>
<p>FreeRTOS 调度器确保处于就绪态或运行态的高优先级的任务获取处理器使用权，换句话说就是处于就绪态的最高优先级的任务才会运行。<strong>当宏<code>configUSE_TIME_SLICING</code>定义为 1 的时候多个任务可以共用一个优先级，数量不限</strong>。默认情况下宏<code>configUSE_TIME_SLICING</code>在文件<code>FreeRTOS.h</code>中已经定义为 1。此时处于就绪态的优先级相同的任务就会使用时间片轮转调度器获取运行时间。</p>
<h3 id="1-4-内核配置"><a href="#1-4-内核配置" class="headerlink" title="1.4 内核配置"></a>1.4 内核配置</h3><ul>
<li><strong>内核配置一</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数名称</th>
<th style="text-align:center">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>USE_PREEMPTION</code></td>
<td style="text-align:center">定义调度器模式</td>
</tr>
<tr>
<td style="text-align:center"><code>CPU_CLOCK_HZ</code></td>
<td style="text-align:center">定义CPU的主频</td>
</tr>
<tr>
<td style="text-align:center"><code>TICK_RATE_HZ</code></td>
<td style="text-align:center">定义系统时钟节拍数</td>
</tr>
<tr>
<td style="text-align:center"><code>MAX_PRIORITIES</code></td>
<td style="text-align:center">定义可供用户使用的最大优先级数</td>
</tr>
<tr>
<td style="text-align:center"><code>MINIMAL_STACK_SIZE</code></td>
<td style="text-align:center">定义空闲任务的栈空间大小</td>
</tr>
<tr>
<td style="text-align:center"><code>MAX_TASK_NAME_LEN</code></td>
<td style="text-align:center">定义任务名最大的字符数</td>
</tr>
<tr>
<td style="text-align:center"><code>USE_16_BIT_TICKS</code></td>
<td style="text-align:center">系统时钟节拍计数使用TickType_t数据类型定义</td>
</tr>
<tr>
<td style="text-align:center"><code>IDLE_SHOULD_YIELD</code></td>
<td style="text-align:center">用于使能与空闲任务同优先级的任务</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>内核配置二</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数名称</th>
<th style="text-align:center">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>USE_MUTEXES</code></td>
<td style="text-align:center">用于使能互斥锁</td>
</tr>
<tr>
<td style="text-align:center"><code>USE_RECURSIVE_MUTEXES</code></td>
<td style="text-align:center">用于使能递归互斥锁</td>
</tr>
<tr>
<td style="text-align:center"><code>USE_COUNTING_SEMAPHORES</code></td>
<td style="text-align:center">用于使能计数信号量</td>
</tr>
<tr>
<td style="text-align:center"><code>QUEUE_REGISTRY_SIZE</code></td>
<td style="text-align:center">用于设置可以注册的信号量和消息队列个数</td>
</tr>
<tr>
<td style="text-align:center"><code>USE_APPLICATION_TASK_TAG</code></td>
<td style="text-align:center">用于使能任务标记</td>
</tr>
<tr>
<td style="text-align:center"><code>ENABLE_BACKWARD_COMPATIBILITY</code></td>
<td style="text-align:center">用于使能新版本对老版本的兼容特性</td>
</tr>
<tr>
<td style="text-align:center"><code>USE_PORT_OPTIMISED_TASK_SELECTION</code></td>
<td style="text-align:center">用于优化优先级列表中药执行的最高优先级任务的算法</td>
</tr>
<tr>
<td style="text-align:center"><code>USE_TICKLESS_IDLE</code></td>
<td style="text-align:center">用于使能tickless低功耗模式</td>
</tr>
<tr>
<td style="text-align:center"><code>USE_TASK_NOTIFICATIONS</code></td>
<td style="text-align:center">使能任务间直接的消息传递，包括信号量、事件标志组和消息邮箱</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>内存管理</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数名称</th>
<th style="text-align:center">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>MEMORY_ALLOCATION</code></td>
<td style="text-align:center">定义内存分配模式</td>
</tr>
<tr>
<td style="text-align:center"><code>TOTAL_HEAP_SIZE</code></td>
<td style="text-align:center">定义动态内存分配总长度</td>
</tr>
<tr>
<td style="text-align:center"><code>HEAP_NUMBER</code></td>
<td style="text-align:center">定义动态内存管理方式</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>任务运行信息获取配置</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数名称</th>
<th style="text-align:center">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>GENERATE_RUN_TIME_STATS</code></td>
<td style="text-align:center">用于使能任务运行状态参数统计</td>
</tr>
<tr>
<td style="text-align:center"><code>USE_TRACE_FACILITY</code></td>
<td style="text-align:center">使能此配置将添加额外的结构体成员和函数</td>
</tr>
<tr>
<td style="text-align:center"><code>USE_STATS_FORMATTING_FUNCTIONS</code></td>
<td style="text-align:center">用户配置宏定义<code>configUSE_TRACE_FACILITY</code> 和<code>configUSE_STATS_FORMATTING_FUNCTIONS</code>都为 1 的时候，将使能函数 <code>vTaskList()</code> 和 <code>vTaskGetRunTimeStats()</code>，如果两者中任何一个为 0，那么这两个函数都将被禁能</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>软件定时器</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数名称</th>
<th style="text-align:center">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>USE_TIMERS</code></td>
<td style="text-align:center">用于使能软件定时器</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>中断优先级</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数名称</th>
<th style="text-align:center">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>LIBRARY_LOWEST_INTERRUPT_PRIORITY</code></td>
<td style="text-align:center">用于配置 FreeRTOS 用到的 SysTick 中断和 PendSV 中断的优先级</td>
</tr>
<tr>
<td style="text-align:center"><code>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code></td>
<td style="text-align:center">定义了受 FreeRTOS 管理的最高优先级中断</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>函数Include配置</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数名称</th>
<th style="text-align:center">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>vTaskPrioritySet</code></td>
<td style="text-align:center">设置任务优先级</td>
</tr>
<tr>
<td style="text-align:center"><code>uxTaskPriorityGet</code></td>
<td style="text-align:center">获取任务优先级</td>
</tr>
<tr>
<td style="text-align:center"><code>vTaskDelete</code></td>
<td style="text-align:center">任务删除</td>
</tr>
<tr>
<td style="text-align:center"><code>vTaskCleanUpResources</code></td>
<td style="text-align:center">清理任务资源</td>
</tr>
<tr>
<td style="text-align:center"><code>vTaskSuspend</code></td>
<td style="text-align:center">任务挂起</td>
</tr>
<tr>
<td style="text-align:center"><code>vTaskDelayUntil</code></td>
<td style="text-align:center">任务绝对延时</td>
</tr>
<tr>
<td style="text-align:center"><code>vTaskDela</code></td>
<td style="text-align:center">任务延时</td>
</tr>
<tr>
<td style="text-align:center"><code>xTaskGetSchedulerState</code></td>
<td style="text-align:center">获取调度器状态</td>
</tr>
<tr>
<td style="text-align:center"><code>xTaskResumeFromISR</code></td>
<td style="text-align:center">在中断中恢复任务</td>
</tr>
<tr>
<td style="text-align:center"><code>xQueueGetMutexHolder</code></td>
<td style="text-align:center">获取互斥锁持有者</td>
</tr>
<tr>
<td style="text-align:center"><code>pcTaskGetTaskName</code></td>
<td style="text-align:center">获取任务名称</td>
</tr>
<tr>
<td style="text-align:center"><code>uxTaskGetStackHighWaterMark</code></td>
<td style="text-align:center">获取任务堆栈信息</td>
</tr>
<tr>
<td style="text-align:center"><code>xTaskGetCurrentTaskHandle</code></td>
<td style="text-align:center">获取当前任务句柄</td>
</tr>
<tr>
<td style="text-align:center"><code>eTaskGetState</code></td>
<td style="text-align:center">获取任务状态</td>
</tr>
<tr>
<td style="text-align:center"><code>xEventGroupSetBitFromISR</code></td>
<td style="text-align:center">在中断中设置事件标志组</td>
</tr>
<tr>
<td style="text-align:center"><code>xTimerPendFunctionCall</code></td>
<td style="text-align:center">定时器挂起后回调函数</td>
</tr>
<tr>
<td style="text-align:center"><code>xTaskAbortDelay</code></td>
<td style="text-align:center">终止任务延时</td>
</tr>
<tr>
<td style="text-align:center"><code>xTaskGetHandle</code></td>
<td style="text-align:center">获取任务句柄</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2、CubeMX项目配置实现LED灯翻转"><a href="#2、CubeMX项目配置实现LED灯翻转" class="headerlink" title="2、CubeMX项目配置实现LED灯翻转"></a>2、CubeMX项目配置实现LED灯翻转</h2><p>在组件面板的Middleware组里，有FreeRTOS，启用FreeRTOS并进行模式和参数设置，如下如所示：</p>
<p><img src="/img/loading.gif" data-original="FreeRTOS_CubeMX配置.png" alt="FreeRTOS_CubeMX配置"></p>
<p>在模式设置(Mode)部分，只有一个参数Interface，其右下拉列表框中有3个选项：</p>
<ul>
<li>Disable，表示不适用FreeRTOS。</li>
<li>CMSIS_V1，启用FreeRTOS，并且使用接口CMSIS_V1。</li>
<li>CMSIS_V2，启用FreeRTOS，并且使用接口CMSIS_V2。</li>
</ul>
<p>这里的接口指的是CMSIS-RTOS接口，也就是ARM公司定义的RTOS接口，有V1和V2两个版本。对于新的设计，我们应该使用新的版本，所以选择CMSIS_V2。</p>
<p>FreeRTOS的配置部分有8个页面，配置的内容比较多。</p>
<ul>
<li>Config parameters，参数配置。配置FreeRTOS的多组参数，这些参数对应于文件FreeRTOSConfig.h中的一些宏定义。</li>
<li>Include parameters，包含参数。配置FreeRTOS的包含参数，是一些函数的条件编译设置，这些包含参数对应于文件FreeRTOSConfig.h中的一些宏定义。</li>
<li>Advanced settings，高级设置。一些高级参数设置。</li>
<li>Tasks and Queues，任务和队列。任务和队列的管理，包括创建、删除和编辑等操作。</li>
<li>Timer and Semaphores，定时器和信号量。管理软件定时器，二值信号量和计数信号量。</li>
<li>Mutexes，互斥量。管理互斥量和递归互斥量。</li>
<li>FreeRTOS Heap Usage，FreeRTOS堆空间使用情况统计。</li>
<li>User Constants，用户常数。用户自定义常数的设置。</li>
</ul>
<p>这几个页面的设置涉及FreeRTOS中的一些主要功能的使用，列如任务、信号量、互斥量等。现在，先保持FreeRTOS的所有参数设置为默认值。</p>
<p><strong>在FreeRTOS中，用户至少需要创建一个任务。CubeMX在启用FreeRTOS时，就定义了一个默认的任务。</strong>任务名称时defaultTask，任务函数名称是StartDefaultTask，这个任务的所有设置暂时保持默认值。</p>
<p><img src="/img/loading.gif" data-original="CubeMX中定义的默认任务.png" alt="CubeMX中定义的默认任务"></p>
<p>在完成设置之后，若是字节生成项目代码，会弹出弹窗：</p>
<p><img src="/img/loading.gif" data-original="提示在使用FreeRTOS时不要使用SysTick定时器作为HAL基础时钟源.png" alt="提示在使用FreeRTOS时不要使用SysTick定时器作为HAL基础时钟源"></p>
<p>它提示在<strong>使用FreeRTOS时，应该使用一个独立的定时器HAL基础时钟源，而不是使用SysTick定时器。</strong></p>
<p>返回<code>SYS</code>组件的模式设置，设置<code>Timebase Source</code>为某个定时器，这个默认定时器是<code>SysTick</code>，<strong>在使用FreeRTOS的时候，FreeRTOS会将SysTick用作基础时钟，所以需要设置一个定时器作为HAL的基础时钟。</strong></p>
<p><img src="/img/loading.gif" data-original="SYS组件的模式设置.png" alt="SYS组件的模式设置"></p>
<p>再次生成工程文件，就没有弹窗了。</p>
<h3 id="2-1、程序分析"><a href="#2-1、程序分析" class="headerlink" title="2.1、程序分析"></a>2.1、程序分析</h3><h4 id="2-1-1-主程序"><a href="#2-1-1-主程序" class="headerlink" title="2.1.1. 主程序"></a>2.1.1. 主程序</h4><p>生成的工程主函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/*!&lt; 系统时钟配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">/*!&lt; FreeRTOS对象初始化函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line"> </span><br><span class="line">  osKernelInitialize(); <span class="comment">/*!&lt; 初始化FreeRTOS的调度器 */</span></span><br><span class="line">  MX_FREERTOS_Init();   <span class="comment">/*!&lt; FreeRTOS对象初始化函数 */</span></span><br><span class="line">  osKernelStart();      <span class="comment">/*!&lt; 启动FreeRTOS的任务调度器 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*!&lt; 程序无法运行到这里，因为RTOS的任务调度器接管了系统的控制 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的最开始还是调用函数<code>HAL_Init()</code>进行初始化。<code>HAL_Init()</code>内部会调用函数<code>HAL_InitTick()</code>对HAL基础时钟进行初始化。</p>
<p><strong>默认情况下，HAL基础时钟源使用SysTick定时器</strong>，在使用定时器TIM6作为HAL时钟源后，CubeMX在生成代码是创建了一个文件<code>stm32f1xx_hal_timebase_tim.c</code>，在这个文件中重新实现了函数<code>HAL_InitTick</code>，<strong>对TIM6进行初始化，使用TIM6生成HAL的滴答时钟信号</strong>。</p>
<p><strong>系统和外设初始化完成之后，调用函数<code>osKernelInitialize()</code>进行FreeRTOS调度器的初始化。</strong></p>
<p>函数<code>MX_FREERTOS_Init()</code>是FreeRTOS中创建对象的初始化函数，这个函数在<code>freertos.c</code>中实现。<em>注意：文件<code>freertos.c</code>没有对应的头文件<code>freertos.h</code>，所以在文件<code>main.c</code>的私有函数原型定义部分，声明了这个函数的原型。</em> <strong>函数<code>MX_FREERTOS_Init()</code>的主要功能是创建用户定义的任务、信号量、队列等在FreeRTOS中用到的对象。</strong></p>
<p>之后调用了<code>osKernelStart()</code>，这是<code>CMSIS-RTOS</code>标准接口函数，其内部调用FreeRTOS的函数<code>vTaskStartScheduler()</code>，功能是启动FreeRTOS内核的任务调度器。<em>执行了这个函数之后，FreeRTOS就接管了系统的控制权，处理去循环执行FreeRTOS中各个任务的代码，FreeRTOS进行任务调度与其他功能管理。</em> <strong>处理器不会执行<code>osKernelStart()</code>之后的代码行，也不会执行main()函数最后的while()最后的while()循环里的代码。</strong></p>
<h4 id="2-1-2-FreeRTOS对象初始化函数和任务创建"><a href="#2-1-2-FreeRTOS对象初始化函数和任务创建" class="headerlink" title="2.1.2. FreeRTOS对象初始化函数和任务创建"></a>2.1.2. FreeRTOS对象初始化函数和任务创建</h4><p><strong>函数<code>MX_FREERTOS_Init()</code>是CubeMX生成的文件<code>freertos.c</code>中的一个函数，用于创建FreeRTOS中的任务、信号量、队列等对象</strong>。FreeRTOS要运行起来，必须创建至少一个任务。应用程序中需要用户编写的涉及FreeRTOS操作的代码，主要写在这个文件里面。</p>
<p>文件<code>freertos.c</code>没有对应的头文件<code>freertos.h</code>。文件<code>freertos.c</code>初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Definitions for defaultTask */</span></span><br><span class="line">osThreadId_t defaultTaskHandle;	<span class="comment">//任务defaultTask的句柄函数</span></span><br><span class="line"><span class="comment">//任务defaultTask的属性</span></span><br><span class="line"><span class="type">const</span> osThreadAttr_t defaultTask_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;defaultTask&quot;</span>,	<span class="comment">//任务的注释名称</span></span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,	<span class="comment">//栈储存空间大小，即128x4=512字节</span></span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,	<span class="comment">//任务优先级</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartDefaultTask</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* (MISRA C 2004 rule 8.1) */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  FreeRTOS initialization</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_MUTEX */</span></span><br><span class="line">  <span class="comment">/* add mutexes(互斥量), ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_MUTEX */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_SEMAPHORES */</span></span><br><span class="line">  <span class="comment">/* add semaphores(信号量), ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_SEMAPHORES */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_TIMERS */</span></span><br><span class="line">  <span class="comment">/* start timers, add new ones, ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_TIMERS */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_QUEUES */</span></span><br><span class="line">  <span class="comment">/* add queues(队列), ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_QUEUES */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create the thread(s) */</span></span><br><span class="line">  <span class="comment">/* creation of defaultTask */</span></span><br><span class="line">  defaultTaskHandle = osThreadNew(StartDefaultTask, <span class="literal">NULL</span>, &amp;defaultTask_attributes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_THREADS */</span></span><br><span class="line">  <span class="comment">/* add threads(任务), ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_THREADS */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_EVENTS */</span></span><br><span class="line">  <span class="comment">/* add events, ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_EVENTS */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务defaultTask的任务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartDefaultTask</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartDefaultTask */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    osDelay(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartDefaultTask */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在程序开头部分定义了一个<code>osThreadId_t</code>类型的变量<code>defaultTaskHandle</code>。<code>osThreadId_t</code>类型实际上是void类型指针，是文件<code>cmsis_0s.h</code>中的一个类型定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *osThreadId_t;</span><br></pre></td></tr></table></figure>
<p>我们把某个对象的指针类型变量称为<strong>句柄变量</strong>，所以，把<code>defaultTaskHandle</code>称为表示任务<code>defaultTask</code>的句柄变量。</p>
<p>在程序开头部分还定义了一个<code>osThreadAttr_t</code>结构体类型变量<code>defaultTask_attributes</code>，并且为其成员变量赋值。<code>defaultTaskHandle</code>和<code>defaultTask_attributes</code>这两个变量，在函数<code>MX_FREERTOS_Init()</code>里创建任务<code>defaultTask</code>时会用到。</p>
<p><em>在程序开头部分还声明了两个函数的原型。因为文件<code>freertos.c</code>没有对应的头文件<code>freerots.h</code>所以需要在文件开头部分声明函数原型。</em></p>
<p><strong>函数<code>MX_FREERTOS_Init()</code>用于创建FreeRTOS中的任务、信号量、互斥量等对象。所以可以称这个函数为FreeRTOS对象初始化函数</strong>。这个函数里面有多个沙箱段，用于创建互斥量、信号量、任务等对象，如果在CubeMX中可视化地设计了这些对象，就会在这里自动生成相应的代码。用户也可以在这些沙箱段内自己添加代码创建对象，因为某些对象不能在CubeMX里可视化设计，如事件组。</p>
<p><strong>FreeRTOS要运行起来，至少要有一个用户任务</strong>，<code>MX_FREERTOS_Init()</code>调用函数<code>osThreadNew()</code>创建CubeMX中定义的默认任务<code>defaultTask</code>。函数<code>osThreadNew()</code>是在文件<code>cmsis_os2.h</code>中定义的，也就是由<code>CMSIS-RTOS V2</code>标准定义的接口函数。其函数原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, <span class="type">void</span> *argument, <span class="type">const</span> osThreadAttr_t *attr)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>func</code>是任务函数名称，<code>argument</code>是向任务函数传递的参数，<code>attr</code>是任务属性结构体指针。</p>
<p>参数<code>func</code>是<code>osThreadFunc_t</code>类型，这是一个函数指针类型，定义了<strong>任务函数的输入/输出参数形式</strong>，在文件<code>cmsis_os2.h</code>中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*osThreadFunc_t)</span> <span class="params">(<span class="type">void</span> *argument)</span>;</span><br></pre></td></tr></table></figure>
<p>函数<code>MX_FREERTOS_Init()</code>中创建任务<code>defaultTask</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">defaultTaskHandle = osThreadNew(StartDefaultTask, <span class="literal">NULL</span>, &amp;defaultTask_attributes);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数<code>StartDefaultTask</code>是任务<code>deaultTask</code>的任务函数名称，每一个任务实际上就是一个函数；</li>
<li>第二个参数值为<code>NULL</code>，是传递给任务函数的参数；</li>
<li>第三个参数是<code>defaultTask_attributes</code>的指针，是任务的属性定义，在文件<code>freertos.c</code>的私有变量部分定义了任务属性变量<code>defaultTask_attributes</code>；</li>
<li>函数的返回值是<code>defaultTaskHandle</code>，也就是任务<code>defaultTask</code>的句柄变量；</li>
</ul>
<p>任务<code>defaultTask</code>的任务属性<code>defaultTask_attributes</code>在定义时就成为成员变量赋值了，这些赋值与CubeMX中设计的任务属性时对应的。</p>
<p>表示任务属性的结构体<code>osThreadAttr_t</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>                   *name;	<span class="comment">//任务的名称，只用于备注</span></span><br><span class="line">  <span class="type">uint32_t</span>                 attr_bits;	<span class="comment">//属性位</span></span><br><span class="line">  <span class="type">void</span>                      *cb_mem;	<span class="comment">//用于控制块的存储空间</span></span><br><span class="line">  <span class="type">uint32_t</span>                   cb_size;	<span class="comment">//控制块存储空间的大小，单位：字</span></span><br><span class="line">  <span class="type">void</span>                   *stack_mem;	<span class="comment">//栈的存储空间</span></span><br><span class="line">  <span class="type">uint32_t</span>                stack_size;	<span class="comment">//栈存储空间的大小，单位：字</span></span><br><span class="line">  osPriority_t              priority;	<span class="comment">//任务的初始化优先级，默认值：osPriorityNormal</span></span><br><span class="line">  TZ_ModuleId_t            tz_module;	<span class="comment">//TrustZone模块标识符</span></span><br><span class="line">  <span class="type">uint32_t</span>                  reserved;	<span class="comment">//保留变量，必须是0</span></span><br><span class="line">&#125; osThreadAttr_t;</span><br></pre></td></tr></table></figure>
<p>CubeMX中对任务属性的配置窗口如下：</p>
<p><img src="/img/loading.gif" data-original="CubeMX中的Edit Task对话框.png" alt="CubeMX中的Edit Task对话框"></p>
<p>图中显示的任务属性参数作用解释如下：</p>
<ul>
<li><code>Task Name</code>：任务名称，仅用于备注；</li>
<li><code>Priority</code>：优先级。每个任务都需要设置一个优先级，优先级和任务调度有关。优先级个数由文件<code>FreeRTOSConfig.h</code>中的宏定义<code>configMAX_PRIORITIES</code>决定，默认是56个。<strong>任务的优先级数字越小，优先级越低</strong>。枚举类型<code>osPriority_t</code>定义了常用的一些优先级，如<code>osPriorityLow</code>、<code>osPriorityNormal</code>、<code>osPriorityHigh</code>等，<em>一个任务在创建时，其默认优先级是<code>osPriorityNormal</code></em>。</li>
<li><code>Stack Size</code>：栈空间大小。<strong>每个任务其实就是一个内部有是循环的函数，FreeRTOS在进行任务切换时，要进行场景的保存与恢复，这就需要使用栈(stack)</strong>。栈实际上就是一个内存空间，每个任务都需要分配一个栈空间。<strong>在FreeRTOS中，栈空间存储元素类型是<code>uint32_t</code>，栈空间的大小单位是字(word)</strong>。<em><code>Cortex-M</code>是32位处理器，一个字的长度是4个字节</em>。但是结构体<code>osThreadAttr_t</code>的成员变量<code>stack_size</code>表示栈的存储空间大小，单位是字节，所以在文件<code>freertos.c</code>中为任务<code>defaultTask</code>的任务属性结构体变量<code>defaultTask_arttributes</code>的成员变量赋值时，相当于如下的语句：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">defaultTask_attributes.stack_size = <span class="number">128</span> * <span class="number">4</span>;	<span class="comment">//栈存储空间大小，即128x4=512字节</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Entry Function</code>：入口函数。也就是任务函数。一个任务就是一个内部有是循环的函数，如<code>StartDefaultTask</code>。<strong>任务函数名称不是结构体<code>osThreadAttr_t</code>的成员变量，而是任务创建函数<code>osThreadNew()</code>的参数</strong>。</li>
<li><code>Code Generation Option</code>：生成代码的选项。有<code>Default</code>和<code>As weak</code>两个选项。<ul>
<li><strong>如果选择<code>As weak</code>，就是任务函数定义成一个弱函数，也就是函数名前面有修饰符<code>__weak</code>。</strong></li>
<li><strong>选择<code>Default</code>就是生成正常的函数。</strong></li>
</ul>
</li>
<li><code>Parameter</code>：参数。为任务函数传递的参数，如果不需要传递参数，就设置为<code>NULL</code>。</li>
<li><code>Allocation</code>：<strong>内存分配方式。是指任务的栈和控制块内存的分配方式</strong>，选项包括<code>Dynamic</code>和<code>Static</code>。<ul>
<li><strong><code>Dynamic</code>表示由<code>osTreadNew()</code>函数内部为任务动态创建栈存储空间<code>stack_mem</code>和任务控制块存储空间<code>cb_mem</code></strong>。</li>
<li><strong>如果选择为<code>Static</code>，则需要在调用<code>osThreadNew()</code>之前，为<code>stack_mem</code>和<code>cb_mem</code>赋值，即静态分配内存</strong>。</li>
</ul>
</li>
</ul>
<p>如果设置<code>Allocation</code>为<code>Static</code>，设置<code>Buffer Name</code>为<code>defaultTaskBuffer</code>，设置<code>Control Block Name</code>为<code>defaultTaskControlBlcok</code>，则在<code>freertos.c</code>的私有变量部分，会定义如下的一些变量，生成如下的任务属性赋值代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osThreadId_t defaultTaskHandle;             <span class="comment">//任务句柄变量</span></span><br><span class="line"><span class="type">uint32_t</span> defaultTaskControlBlock[<span class="number">128</span>];      <span class="comment">//栈空间数组</span></span><br><span class="line">osStaticThreadDef_t defaultTaskControlBlock;<span class="comment">//控制块结构体变量</span></span><br><span class="line"><span class="comment">//任务属性赋值</span></span><br><span class="line"><span class="type">const</span> osThreadAttr_t defaultTask_attributes = &#123;</span><br><span class="line">    .name = <span class="string">&quot;defaultTask&quot;</span>,                      <span class="comment">//任务名称</span></span><br><span class="line">    .stack_mem = &amp;defaultTaskBuffer[<span class="number">0</span>],         <span class="comment">//栈数组地址</span></span><br><span class="line">    .stack_size = <span class="keyword">sizeof</span>(defaultTaskBuffer),    <span class="comment">//栈数组大小</span></span><br><span class="line">    .cb_mem = &amp;defaultTaskControlBlock,         <span class="comment">//控制块地址</span></span><br><span class="line">    .cb_size = <span class="keyword">sizeof</span>(defaultTaskControlBlock), <span class="comment">//控制块大小</span></span><br><span class="line">    .priority = (psPriority_t)osPriorityNormal, <span class="comment">//任务优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，使用静态分配内存时，稍微麻烦一点。<strong>但是不管时动态分配内存，还是静态分配内存，函数<code>MX_FREERTOS_Init()</code>还是调用<code>osThreadNoew()</code>创建任务</strong>。</p>
<p><strong>函数<code>osThreadNew()</code>会根据任务属性中的内存分配方式，分别调用FreeRTOS的两个不同的函数创建任务</strong>：</p>
<ul>
<li>动态分配任务时，调用函数<code>xTaskCreate()</code>创建任务；</li>
<li>静态分配内存时，调用函数<code>xTaskCreateStatic()</code>创建任务。</li>
</ul>
<h4 id="2-1-3-编写任务功能实现代码"><a href="#2-1-3-编写任务功能实现代码" class="headerlink" title="2.1.3. 编写任务功能实现代码"></a>2.1.3. 编写任务功能实现代码</h4><p>编写示例，使<code>LED0</code>间隔500ms翻转，任务函数<code>StartDefaultTask()</code>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE END Header_StartDefaultTask */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartDefaultTask</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartDefaultTask */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);</span><br><span class="line">    osDelay(<span class="number">500</span>); <span class="comment">/*!&lt; 延时500个tick(时钟节拍) */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartDefaultTask */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在for循环中，使用的延时函数时<code>osDelay()</code>，这是<code>CMSIS-RTOS</code>标准接口函数，内部调用FreeRTOS的延时函数<code>vTaskDelay()</code>，延时单位时时钟节拍(tick)。<strong>FreeRTOS的基础时钟产生的滴答信号周期是1ms，所以一个节拍就是1ms</strong>。</p>
<p>在FreeRTOS的任务管理中，延时函数<code>vTaskDelay()</code>是非常重要的。任务函数的主体一般就是一个死循环，<strong>任务函数在执行延时函数<code>vTaskDelay()</code>时，会交出CPU的使用权，由FreeRTOS进行任务调度，使其他任务可以获取CPU的使用权，否则，高优先级任务将总是占用CPU，其他任务无法执行</strong>。</p>
<h2 id="3、FreeRTOS的文件组成和基本原理"><a href="#3、FreeRTOS的文件组成和基本原理" class="headerlink" title="3、FreeRTOS的文件组成和基本原理"></a>3、FreeRTOS的文件组成和基本原理</h2><h3 id="3-1-FreeRTOS文件组成"><a href="#3-1-FreeRTOS文件组成" class="headerlink" title="3.1 FreeRTOS文件组成"></a>3.1 FreeRTOS文件组成</h3><p>在上面的LED灯示例中，与FreeRTOS相关的程序文件主要分为<strong>可修改的用户程序文件</strong>和<strong>不可修改的FreeRTOS源程序文件</strong>。前面介绍的<code>freertos.c</code>是可修改的用户程序文件，FreeRTOS中任务、信号量等对象的创建，用户任务函数都在这个文件里面实现。</p>
<p>项目中FreeRTOS的源程序文件都在目录<code>\Middlewares\Third_Party\FreeRTOS\Source</code>下，这些是针对选择的MCU信号做好了移植的文件。<em>使用CubeMX生成代码时，用户无需关心FreeRTOS的移植问题，所需的源程序文件也为用户组织好了</em>。</p>
<p>FreeRTOS的源程序文件大致可以分为5类，如下所示：</p>
<p><img src="/img/loading.gif" data-original="FreeRTOS的文件组成.png" alt="FreeRTOS的文件组成"></p>
<p>用户配置和程序文件有两个文件，用于对FreeRTOS进行各种配置和功能裁剪，以及实现用户任务的功能。</p>
<ul>
<li>文件<code>FreeRTOSConfig.h</code>，是对FreeRTOS进行各种配置的文件，<strong>FreeRTOS的功能裁剪就是通过这个文件里面的各种宏定义实现的</strong>。</li>
<li>文件<code>freertos.c</code>包含FreeRTOS对象初始化函数<code>MX_FREERTOS_Init()</code>和任务函数，<strong>是编写用户代码的主要文件</strong>。</li>
</ul>
<h4 id="3-1-1-FreeRTOS通用功能文件"><a href="#3-1-1-FreeRTOS通用功能文件" class="headerlink" title="3.1.1 FreeRTOS通用功能文件"></a>3.1.1 FreeRTOS通用功能文件</h4><p>这些是实现FreeRTOS的任务、队列、信号量、软件定时器、事件组等通用功能文件，这些功能与硬件无关。在一个嵌入式操作系统中，任务管理是必须的，某些功能是在用到时才需要加入的，如事件组、软件定时器、信号量、流缓冲区等。CubeMX在生成代码时，将这些文件全部复制到了项目里，但是它不会编译到最终的二进制文件里。用户可以对FreeRTOS的各种参数进行配置，实现功能剪裁，这些参数配置其实就是各种条件编译的条件定义。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">文件</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>croutine.h/.c</code></td>
<td>实现协程(co-routine)功能的程序文件，协程主要用于内存非常小的MCU，现在已经很少使用。</td>
</tr>
<tr>
<td style="text-align:left"><code>event_groups.h/.c</code></td>
<td>实现事件组功能的程序文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>list.h/.c</code></td>
<td>实现链表功能的程序文件，FreeRTOS的任务调度器用到链表。</td>
</tr>
<tr>
<td style="text-align:left"><code>queue.h/.c</code></td>
<td>实现队列功能的程序文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>semphr.h</code></td>
<td>实现信号量功能的文件，信号量是基于队列的，信号量操作的函数都是宏函数，其实现都是调用队列处理的函数。</td>
</tr>
<tr>
<td style="text-align:left"><code>task.h/tasks.c</code></td>
<td>实现任务管理功能的程序文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>timers.h/.c</code></td>
<td>实现软件定时器功能的程序文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>stream_buffer.h/.c</code></td>
<td>实现流缓冲区功能的程序文件。流缓冲区是一种优化的进程间通信机制，是在V10版本中才引入的功能。</td>
</tr>
<tr>
<td style="text-align:left"><code>message_buffer.h</code></td>
<td>实现消息缓冲区的文件。实现缓冲区功能的所有函数都是宏函数，因为消息缓冲区是基于流缓冲区实现的，都调用流缓冲区的函数。消息缓冲区是在V10版本中才引入的功能。</td>
</tr>
<tr>
<td style="text-align:left"><code>mpu_prototypes.h</code><br><code>mpu_wrappers.h</code></td>
<td>MPU(内存保护单元)功能的头文件。该文件定义的函数是在标准函数前面增加前缀”MPU_”，当应用程序使用MPU功能时，FreeRTOS内核会优先执行此文件中的函数。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-1-2-FreeRTOS通用定义文件"><a href="#3-1-2-FreeRTOS通用定义文件" class="headerlink" title="3.1.2 FreeRTOS通用定义文件"></a>3.1.2 FreeRTOS通用定义文件</h4><p>在工程目录<code>FreeRTOS\Source\include</code>下有几个与硬件不管的通用定义文件。</p>
<p><strong>文件<code>FreeRTOS.h</code>。这个文件包含FreeRTOS的默认宏定义、数据类型定义、接口函数定义等</strong>。FreeRTOS.h中有些默认的用于FreeRTOS功能裁剪的宏定义，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> configIDLE_SHOULD_YIELD</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_vTaskDelete</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>FreeRTOS的功能裁剪就是通过这些宏定义实现的，这些用于配置的宏定义主要分为以下两类</strong>。</p>
<ul>
<li>前缀为<code>config</code>的宏表示某种参数设置，一般地，值为1表示开启此功能，值为0表示禁用此功能，如<code>configIDLE_SHOULD_YIELD</code>表示空闲任务是否对同优先级地任务让出处理器使用权。</li>
<li>前缀为<code>INCLUDE_</code>的宏表示是否编译某个函数的源代码，例如，宏<code>INCLUDE_vTaskDelete</code>的值为1，就表示编译函数<code>vTaskDelete()</code>的源代码，值为0就表示不编译函数<code>vTaskDelete()</code>的源代码。</li>
</ul>
<p>在FreeRTOS中，这些宏定义通常称为参数，因为它们决定了系统的一些特性。<strong>文件<code>FreeRTOS.h</code>包含系统默认的一些参数的宏定义，不要直接修改此文件的内容</strong>。用户可以修改的配置文件是<code>FreeRTOSConfig.h</code>，这个文件也包含大量前缀为<code>config</code>和<code>INCLUDE_</code>的宏定义。<strong>如果文件<code>FreeRTOSConfig.h</code>中没有定义某个宏，就使用文件FreeRTOS.h中的默认定义</strong>。</p>
<p>FreeRTOS的大部分功能配置都可以通过CubeMX可视化设置完成，并生成文件<code>FreeRTOSConfig.h</code>中的宏定义代码。</p>
<p>文件<code>projdefs.h</code>。这个文件包含FreeRTOS中的一些通用定义，如错误编号宏定义，逻辑值的宏定义等。文件<code>projdefs.h</code>中常用的几个宏定义及其功能如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pdFALSE</code></td>
<td>0</td>
<td>表示逻辑值<code>false</code></td>
</tr>
<tr>
<td><code>pdTRUE</code></td>
<td>1</td>
<td>表示逻辑值<code>true</code></td>
</tr>
<tr>
<td><code>pdFAIL</code></td>
<td>0</td>
<td>表示逻辑值<code>false</code></td>
</tr>
<tr>
<td><code>pdPASS</code></td>
<td>1</td>
<td>表示逻辑值<code>true</code></td>
</tr>
<tr>
<td><code>pdMS_TO_TICKS(xTimeInMs)</code></td>
<td>-</td>
<td>这是个宏函数，其功能是将<code>xTimeInMs</code>表示的毫秒数转换为时钟节拍数，因为延时函数<code>vTaskDelay()</code>的输入参数是节拍数</td>
</tr>
</tbody>
</table>
</div>
<p>文件<code>stack_macros.h</code>和<code>StackMacros.h</code>。这两个文件的内容完全一样，只是为了向后兼容，才出现了两个文件。这两个文件定义了进行栈溢出检查的函数，如果要使用栈溢出检查功能，需要设置参数<code>configCHECK_FOR_STACK_OVERFLOW</code>的值为1或2。</p>
<h4 id="3-1-3-CMSIS-RTOS标准接口文件"><a href="#3-1-3-CMSIS-RTOS标准接口文件" class="headerlink" title="3.1.3 CMSIS-RTOS标准接口文件"></a>3.1.3 CMSIS-RTOS标准接口文件</h4><p>目录<code>\FreeRTOS\Source\CMSIS_RTOS_V2\</code>下是<code>CMSIS-RTOS</code>标准接口文件，如下图所示：</p>
<p><img src="/img/loading.gif" data-original="CMSIS-RTOS标准接口文件.png" alt="CMSIS-RTOS标准接口文件"></p>
<p>这些文件里的宏定义、数据类型、函数名称等前缀都是<code>os</code>。原理上来说，这些函数和数据类型的名称与具体的RTOS无关，它们是<code>CMSIS-RTOS</code>标准的定义。在具体实现上，这些前缀为<code>os</code>的函数调用具体移植的RTOS的实现函数，<strong>例如，若移植的是FreeRTOS，<code>os</code>函数就调用FreeRTOS的实现函数，若移植的是uC/OS-Ⅱ，<code>os</code>函数就调用uC/OS-Ⅱ的实现函数</strong>。</p>
<p>我们移植的是FreeRTOS，所以<code>os</code>函数就调用FreeRTOS的实现函数。例如，CMSIS-RTOS的延时函数<code>osDelay()</code>的内部就是调用了FreeRTOS的延时函数<code>vTaskDelay()</code>，其完整源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osStatus_t <span class="title function_">osDelay</span> <span class="params">(<span class="type">uint32_t</span> ticks)</span> &#123;</span><br><span class="line">  osStatus_t stat;</span><br><span class="line">  <span class="keyword">if</span> (IS_IRQ()) &#123;</span><br><span class="line">    stat = osErrorISR;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    stat = osOK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ticks != <span class="number">0U</span>) &#123;</span><br><span class="line">      vTaskDelay(ticks);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (stat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>在LED翻转的示例中，就有一些类似的<code>os</code>函数：<code>osThreadNew()</code>的内部调用<code>xTaskCreate()</code>或<code>xTaskCreateStatic()</code>创建任务；<code>osKernelStart()</code>的内部调用<code>vTaskStartScheduler()</code>启动FreeRTOS内核运行。</em></p>
<p>从原理上来说，如果在程序中使用这些<code>CMSIS-RTOS</code>标准接口函数和类型定义，可以减少与具体RTOS的关联。例如，一个应用程序原先是使用FreeRTOS写的，后来要改用其他的实时操作系统，则只需改RTOS移植部分的程序，而无需修改应用程序。但是这种情况可能极少。</p>
<h4 id="3-1-4-硬件相关的移植文件"><a href="#3-1-4-硬件相关的移植文件" class="headerlink" title="3.1.4 硬件相关的移植文件"></a>3.1.4 硬件相关的移植文件</h4><p>硬件相关的移植文件就是需要根据硬件类型进行改写的文件，一个移植好的版本成为一个端口(port)，这些文件在目录<code>\FreeRTOS\Source\portable</code>下，又分为处理器架构与编译器文件、内存管理文件两个部分，如下所示：</p>
<p><img src="/img/loading.gif" data-original="硬件相关移植文件.png" alt="硬件相关移植文件"></p>
<p>由于我在工程中生成了<code>Keil</code>和<code>IAR</code>两个工程文件，故架构与编译器的文件夹就有两个。其中：</p>
<ul>
<li><code>IAR</code>文件夹中为<code>IAR</code>工程的处理器架构与编译器文件</li>
<li><code>RVDS</code>文件夹为<code>Keil</code>工程的处理器架构与编译器文件</li>
<li><code>MemMand</code>文件夹内为内存管理文件</li>
</ul>
<ol>
<li><strong>处理器架构与编译器相关文件</strong></li>
</ol>
<p>处理器架构与编译器部分有2个文件，分别为<code>portmacro.h</code>和<code>port.c</code>。<strong>这两个文件里面是一些与硬件相关的基础数据类型、宏定义和函数定义</strong>。因为某些函数的功能实现设计底层操作，其实现代码甚至是用汇编语言写的，所以与硬件密切相关。</p>
<p>FreeRTOS需要使用一个基础数据类型定义头文件<code>stdint.h</code>，这个头文件定义的是<code>uint8_t</code>、<code>uint16_t</code>、<code>uint32_t</code>等基础数据类型，STM32的HAL库包含这个文件。</p>
<p>另外，在文件<code>portmacro.h</code>中，FreeRTOS还重新定义了一些基础的数据类型的类型符号，定义的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portCHAR		char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portFLOAT		float</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portDOUBLE		double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portLONG		long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSHORT		short</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSTACK_TYPE	uint32_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portBASE_TYPE	long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> portSTACK_TYPE StackType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> BaseType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> UBaseType_t;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configUSE_16_BIT_TICKS == 1 )</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">uint16_t</span> TickType_t;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">uint32_t</span> TickType_t;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffffffffUL</span></span><br></pre></td></tr></table></figure>
<p>其中，因为<code>Cortex-M3</code>是32位处理器，所以<code>configUSE_16_BIT_TICKS == 0</code></p>
<ol>
<li><strong>内存管理相关文件</strong></li>
</ol>
<p>内存管理涉及内存动态分配和释放等操作，与具体的处理器密切相关。FreeRTOS提供5种内存管理方案，即<code>heap1~heap5</code>，在CubeMX中设置FreeRTOS参数时选择一种即可。CubeMX生成的默认的内存管理方案。</p>
<p>文件<code>heap_4.c</code>实现了动态分配内存的函数<code>pvPortMalloc()</code>，释放内存的函数<code>vPortFree()</code>，以及其他几个函数。</p>
<h3 id="3-2-FreeRTOS的编码规则"><a href="#3-2-FreeRTOS的编码规则" class="headerlink" title="3.2 FreeRTOS的编码规则"></a>3.2 FreeRTOS的编码规则</h3><p>FreeRTOS的核心源程序文件遵循一套编码规则，其变量命名、函数命名、宏定义命名等都有规律，知道这些规律有助于理解函数名、宏定义的意义。</p>
<h4 id="3-2-1-变量名"><a href="#3-2-1-变量名" class="headerlink" title="3.2.1 变量名"></a>3.2.1 变量名</h4><p>变量名适用类型前缀。通过变量名的前缀，用户可以知道变量的类型。</p>
<ul>
<li><p>对于<code>stdint.h</code>中定义的各种标准类型整数</p>
<ul>
<li>前缀<code>c</code>表示<code>char</code>类型变量，前缀<code>s</code>表示<code>int16_t(short)</code>类型变量</li>
<li>前缀<code>l</code>表示<code>int32_t</code>类型变量。对于无符号<code>uinsigned</code>整数</li>
<li>再在前面增加前缀<code>u</code>，如<code>uc</code>表示<code>uint8_t</code>类型</li>
<li><code>us</code>表示<code>uint16_t</code>，<code>ul</code>表示<code>uint32_t</code>类型。</li>
</ul>
</li>
<li><p><code>BaseType_t</code>和所有其他非标准类型的变量名，如结构体变量、任务句柄、队列句柄等都用前缀<code>x</code>。</p>
</li>
<li><code>UBaseType_t</code>类型的变量使用前缀<code>ux</code>。</li>
<li>指针类型变量在前面再增加一个<code>p</code>，例如<code>pc</code>表示<code>char*</code>类型。</li>
</ul>
<h4 id="3-2-2-函数名"><a href="#3-2-2-函数名" class="headerlink" title="3.2.2 函数名"></a>3.2.2 函数名</h4><p>函数名的前缀由<strong>返回值类型</strong>和<strong>函数所在文件</strong>组成，若返回值位<code>void</code>类型，则类型前缀时<code>v</code>。举例如下：</p>
<ul>
<li>函数<code>xTaskCreate()</code>，其返回值位BaseType_t类型，在文件<code>task.h</code>中定义。</li>
<li>函数<code>vQueueDelete()</code>，其返回值位<code>void</code>，在文件<code>queue.h</code>中定义。</li>
<li>函数<code>pcTimerGetName()</code>，其返回值位<code>char*</code>，在文件<code>timer.h</code>中定义。</li>
<li>函数<code>pvPortMalloc()</code>，其返回值位<code>void*</code>，在文件<code>portable.h</code>中定义。</li>
</ul>
<p>​        如果函数是用<code>static</code>声明的文件内使用的私有函数，则其前缀位<code>prv</code>，例如：<code>tasks.c</code>文件中函数<code>prvAddNewTaskToReadyList()</code>，因为私有函数不会被外部调用，所以函数名中就不用包括返回值类型和所在文件的前缀了。</p>
<p>​        <code>CMSIS-RTOS</code>相关文件中定义的函数前缀都是<code>os</code>，不包括返回值类型和所在文件的前缀。例如，<code>cmsis_os2.h</code>中的函数<code>osThreadNew()</code>、<code>osDelay()</code>等。</p>
<h4 id="3-2-3-宏名称"><a href="#3-2-3-宏名称" class="headerlink" title="3.2.3 宏名称"></a>3.2.3 宏名称</h4><p>宏定义和宏函数的名称一般用大写字母，并使用小写字母前缀表示红的功能分组。FreeRTOS中常用的宏名称如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>前缀</th>
<th>意义</th>
<th>所在文件</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>config</code></td>
<td>用于系统功能配置的宏</td>
<td><code>FreeRTOSConfig.h</code><br><code>FreeRTOS.h</code></td>
<td><code>configUSE_MUTEXES</code><br><code>configTICK_RATE_HZ</code></td>
</tr>
<tr>
<td><code>INCLUDE_</code></td>
<td>条件编译某个函数的就宏</td>
<td><code>FreeRTOSConfig.h</code><br><code>FreeRTOS.h</code></td>
<td><code>INCLUDE_vTaskDelay</code><br><code>INCLUDE_vTaskDelete</code></td>
</tr>
<tr>
<td><code>task</code></td>
<td>任务相关的宏</td>
<td><code>task.h</code><br><code>task.c</code></td>
<td><code>taskENTER_CRITICAL()</code><br><code>taskIDLE_PRIORITY</code></td>
</tr>
<tr>
<td><code>queue</code></td>
<td>队列相关的宏</td>
<td><code>queue.h</code></td>
<td><code>queueQUEUE_TYPE_MUTEX</code></td>
</tr>
<tr>
<td><code>pd</code></td>
<td>项目通用宏定义</td>
<td><code>projdefs.h</code></td>
<td><code>pdTRUE, pdFALSE</code></td>
</tr>
<tr>
<td><code>port</code></td>
<td>移植接口文件定义的宏</td>
<td><code>portable.h</code><br><code>portmacro.h</code><br><code>port.c</code></td>
<td><code>portBYTE_ALIGNMENT_MASK</code><br><code>portCHAR</code><br><code>portMAX_24_BIT_NUMBER</code></td>
</tr>
<tr>
<td><code>tmr</code></td>
<td>软件定时器相关的宏</td>
<td><code>timer.h</code></td>
<td><code>tmrCOMMAND_START</code></td>
</tr>
<tr>
<td><code>os</code></td>
<td>CMSIS-RTOS接口相关的宏</td>
<td><code>cmsis_os.h</code><br><code>cmsis_os2.h</code></td>
<td><code>osFeature_SysTick</code><br><code>osFlagsWaitAll</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-3-FreeRTOS的配置和功能裁剪"><a href="#3-3-FreeRTOS的配置和功能裁剪" class="headerlink" title="3.3 FreeRTOS的配置和功能裁剪"></a>3.3 FreeRTOS的配置和功能裁剪</h3><p>FreeRTOS的配置和功能裁剪主要是通过文件<code>FreeRTOSConfig.h</code>和<code>FreeRTOS.h</code>中的宏定义实现的</p>
<ul>
<li><strong>前缀为<code>config</code>的宏用于配置FreeRTOS的一些参数</strong></li>
<li><strong>前缀为<code>INCLUDE_</code>的宏用于控制是否编译某些函数的源代码</strong>。</li>
</ul>
<p><em>文件<code>FreeRTOS.h</code>中的宏定义是系统默认的宏定义，请勿直接修改。</em><code>FreeRTOSConfig.h</code>是用户可修改的配置文件，如果一个宏没有在文件<code>FreeRTOSConfig.h</code>中重定义，就是用文件<code>FreeRTOS.h</code>中的默认定义。</p>
<p>在CubeMX中，FreeRTOS的配置界面中有<code>Config parameters</code>和<code>Include parameters</code>两个页面，用于对这两类宏进行设置。</p>
<h4 id="3-3-1-config类的宏"><a href="#3-3-1-config类的宏" class="headerlink" title="3.3.1 config类的宏"></a>3.3.1 <code>config</code>类的宏</h4><p><strong>前缀为<code>config</code>的宏用于配置FreeRTOS的一些参数</strong>。LED翻转示例中，完全使用了FreeRTOS的默认配置，其宏定义代码定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION                     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_STATIC_ALLOCATION          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION         1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_IDLE_HOOK                      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICK_HOOK                      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ                       ( SystemCoreClock )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ                       ((TickType_t)1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES                     ( 56 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE                 ((uint16_t)128)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE                    ((size_t)3072)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN                  ( 16 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY                 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS                   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES                        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configQUEUE_REGISTRY_SIZE                8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_RECURSIVE_MUTEXES              1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_COUNTING_SEMAPHORES            1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION  0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Co-routine definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_CO_ROUTINES                    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES          ( 2 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Software timer definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIMERS                         1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_PRIORITY                ( 2 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_QUEUE_LENGTH                 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_STACK_DEPTH             256</span></span><br></pre></td></tr></table></figure>
<p>在CubeMX中修改了值的参数都会在文件<code>FreeRTOConfig.h</code>中生成语句。有默认值的宏定义在文件<code>FreeRTOS.h</code>中，例如，文件<code>FreeRTOS.h</code>中有如下的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> configIDLE_SHOULD_YIELD</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>默认情况下，文件<code>FreeRTOSConfig.h</code>中没有宏定义<code>configIDLE_SHOULD_YIELD</code>，就使用文件<code>FreeRTOS.h</code>中的默认定义。如果通过CubeMX修改了这个参数，在<code>FreeRTOSConfig.h</code>中生成了如下的宏定义，那么就使用<code>FreeRTOSConfig.h</code>中的定义</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD 0</span></span><br></pre></td></tr></table></figure>
<p>在CubeMX中，FreeRTOS参数配置的<code>Config Parameters</code>页面的参数，分为好几组。这些参数对应于文件<code>FreeRTOSConfig.h</code>和<code>FreeRTOS.h</code>中相应的宏，下面，我们分别介绍这几组参数设置的内容。</p>
<ol>
<li><code>Kernel settings</code>：内核设置，是FreeRTOS内核的一些参数，设置的具体参数及其默认值如下：</li>
</ol>
<p><img src="/img/loading.gif" data-original="FreeRTOS内核设置.png" alt="FreeRTOS内核设置"></p>
<p>其中一些参数是不允许修改的，就显示为灰色字体。一些参数只能选择一个参数值，例如，<code>USE_MUTEXES</code>只能选择<code>Enable</code>。</p>
<p>CubeMX中<code>Kernel settings</code>页面的参数与<code>FreeRTOSConfig.h</code>或<code>FreeRTOS.h</code>中的宏是对应的，只是去掉了前缀<code>config</code>，如<code>USE_PREEMPTION</code>对应的宏是<code>configUSE_PREEMPTION</code>。界面中逻辑型参数的可选值是<code>Enable</code>和<code>Disable</code>，对应宏定义的值是1和0，这些宏一般是条件编译的条件，用于条件编译某一段代码。</p>
<p><code>Kernel settings</code>页面中的参数的意义和默认值如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配置参数</th>
<th>默认值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>USE_PREEMPTION</code></td>
<td><code>Enabled</code></td>
<td><code>Enabled</code>表示使用<strong>抢占式任务调度器</strong>；<br><code>Disabled</code>表示使用<strong>合作式任务调度器</strong>；</td>
</tr>
<tr>
<td><code>CPU_CLOCK_HZ</code></td>
<td><code>SystemCoreClock</code></td>
<td>系统核心时钟，即MCU的HCLK时钟</td>
</tr>
<tr>
<td><code>TICK_RATE_HZ</code></td>
<td>1000</td>
<td>系统滴答时钟频率，设置范围为1至1000，默认为1000Hz，所以周期是1ms</td>
</tr>
<tr>
<td><code>MAX_PRIORITES</code></td>
<td>56</td>
<td>任务的最多优先级个数，这里固定为56，<strong>不可修改</strong></td>
</tr>
<tr>
<td><code>MINIAL_STACK_SIZE</code></td>
<td>128 Words</td>
<td>系统空闲任务的栈空间的最小值，设置范围为64至3840.在FreeRTOS中，栈空间的大小单位是字，在Cortex-M架构中，一个字是4字节</td>
</tr>
<tr>
<td><code>MAX_TASK_NAME_LEN</code></td>
<td>16</td>
<td>任务名称字符串的最大长度，设置范围为12至255</td>
</tr>
<tr>
<td><code>USE_16_BIT_TICKS</code></td>
<td><code>Disabled</code></td>
<td>决定文件<code>potymacro.h</code>中定义的节拍数据类型<code>TickType_t</code>的具体类型。若这个值是<code>Disabled</code>，则<code>TickType_t</code>是<code>uint32_t</code>类型，否则，是<code>uint16_t</code>类型。Contex-M架构上<code>TickType_t</code>是<code>uint32_t</code>类型</td>
</tr>
<tr>
<td><code>IDLE_SHOULD_YIELD</code></td>
<td><code>Enabled</code></td>
<td>空闲任务是否对同优先级的任务主动让出CPU使用权</td>
</tr>
<tr>
<td><code>USE_MUTEXES</code></td>
<td><code>Enabled</code></td>
<td>是否使用互斥量，<strong>只能选择<code>Enabled</code></strong></td>
</tr>
<tr>
<td><code>USE_RECURSIVE_MUTEXES</code></td>
<td><code>Enabled</code></td>
<td>是否使用递归互斥量，<strong>只能选择<code>Enabled</code></strong></td>
</tr>
<tr>
<td><code>USE_COUNTING_SEMAPHORES</code></td>
<td><code>Enabled</code></td>
<td>是否使用计数信号量，<strong>只能选择<code>Enabled</code></strong></td>
</tr>
<tr>
<td><code>QUEUE_REGISTRY_SIZE</code></td>
<td>8</td>
<td>可注册的队列和信号量的最大数量，设置范围为0至255，<strong>使用内核调试器查看信号量和队列时，需要先注册队列和信号量</strong></td>
</tr>
<tr>
<td><code>USE_APPLICATION_TASK_TAG</code></td>
<td><code>Disabled</code></td>
<td>是否使用应用程序的任务标签，若对应的宏是1，则会编译一些代码段，特别是文件<code>tasks.c</code>中的3个相关函数：<br><code>vTaskSetApplicationTaskTag()</code><br><code>xTaskGetApplicationTaskTag()</code><br><code>xTaskGetApplicationTaskHook()</code></td>
</tr>
<tr>
<td><code>ENABLE_BACKWARD_COMPATIBILITY</code></td>
<td><code>Enabled</code></td>
<td>是否向后兼容旧的版本</td>
</tr>
<tr>
<td><code>USB_PORT_OPTIMISED_TASK_SELECTION</code></td>
<td><code>Disabled</code></td>
<td>任务调度时，选择下一个运行任务的方法，Disbaled表示通用的方法，不依赖于具体的硬件，在使用Cortex-M0或CMSIS-RTOSV2，只能是Disbaled</td>
</tr>
<tr>
<td><code>USE_TICKLESS_IDLE</code></td>
<td><code>Disbaled</code></td>
<td>是否使用无节拍的低功耗模式。若是设置为<code>Enabled</code>，可自动进入低功耗模式，降低系统功耗。</td>
</tr>
<tr>
<td><code>USE_TASK_NOTIFICATIONS</code></td>
<td><code>Enabled</code></td>
<td>是否使用任务通知功能。若设置为<code>Enabled</code>，则编译相关的函数，每个人物的栈多消耗8字节空间</td>
</tr>
<tr>
<td><code>RECORE_STACK_HIGH_ADDRESS</code></td>
<td><code>Disabled</code></td>
<td>是否将栈的起始地址保存到每个任务的控制模块中(假设栈是向下生长的)</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p><code>Memory management settings</code>：内存管理设置。内存管理的参数设置界面如下图所示，只有三个参数。</p>
<p> <img src="/img/loading.gif" data-original="内存管理的参数设置界面.png" alt="内存管理的参数设置界面"></p>
</li>
</ol>
<ul>
<li><p><code>Memory Allocation</code>：内存分配方式，固定为<code>Dynamic/Static</code>，也就是同时支持动态分配和静态分配。这个参数对应于文件<code>FreeRTOSConfig.h</code>中的两个宏。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_STATIC_ALLOCATION          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION         1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个参数不能在CubeMX里面修改，但是可以在文件<code>FreeRTOSConfig.h</code>里面修改宏定义。</p>
<ul>
<li><code>TOTAL_HEAP_SIZE</code>：FreeRTOS总的堆空间大小，设置范围为<code>512B~128KB</code>.FreeRTOS中创建的所有对象，如任务、队列、软件定时器、信号量、互斥量等，都需要从FreeRTOS的堆空间分配内存。在CubeMX中，<code>FreeRTOS Heap Usage</code>页面显示了当前配置下，FreeRTOS的堆空间使用情况，如下图所示。界面中显示了剩余的可用内存，以及各个任务、各种对象使用的内存量。</li>
</ul>
<p><img src="/img/loading.gif" data-original="FreeRTOS_Heap_Usage页面显示堆空间使用信息.png" alt="FreeRTOS Heap Usage页面显示堆空间使用信息"></p>
<ul>
<li><p><code>Memory Management scheme</code>：内存管理方案。有5种可选的内存管理方案，从<code>heap_1</code>到<code>heap_5</code>，使用哪种方案，就在文件<code>FreeRTOSConfig.h</code>中生成对应那种方案的宏定义。例如，使用方案<code>heap_4</code>，生成的宏定义如下：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USE_FreeRTOS_HEAP_4</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p><code>Hook function related definitions</code>：钩子函数相关定义，钩子函数类似回调函数，就是在某个功能或函数执行时要调用的一个函数。钩子函数的代码由用户编写，用于实现一些自定义的处理。钩子函数的数字界面如下图所示：</p>
<p> <img src="/img/loading.gif" data-original="钩子函数的设置界面.png" alt="钩子函数的设置界面"></p>
<p> 默认情况下，这些参数值都是<code>Disable</code>，也就是不实现相应的钩子函数。如果设置<code>Enabled</code>，CubeMX会在文件<code>freertos.c</code>中自动生成相应钩子函数的函数框架。</p>
<p> <code>Hook function related definitions</code>各个参数意义以及设置为<code>Enabled</code>时对应的钩子函数名称如下：</p>
<p> | 钩子函数配置参数               | 调用场合                               | 对应的钩子函数名称                    |<br> | ——————————————— | ——————————————————— | ——————————————————- |<br> | <code>USE_IDLE_HOOK</code>                | 空闲任务里调用                         | <code>vApplicationIdleHook()</code>              |<br> | <code>USE_TICK_HOOK</code>                | 滴答定时器中断服务函数里调用           | <code>vApplicationTickHook()</code>              |<br> | <code>USE_MALLOC_FAILED_HOOK</code>       | 使用<code>pvPortMalloc()</code>分配内存失败时调用 | <code>vApplicationMallocFaileHook()</code>       |<br> | <code>USE_DAEMON_TASK_STARTUP_HOOK</code> | 守护(Daemon)任务启动时调用             | <code>vApplicationDaemonTaskStartupHook()</code> |<br> | <code>CHECK_FOR_STACK_OVERFLOW</code>     | 栈溢出时调用                           | <code>vApplicationStackOverflowHook()</code>     |</p>
<p> 其中<code>CHECK_FOR_STACK_OVERFLOW</code>的选项比较特殊，它提供<code>Option1</code>和<code>Option2</code>两个选项，对应与FreeRTOS内部两种不同的栈溢出处理方法，但是对应的钩子函数名称是相同的。 </p>
</li>
<li><p><code>Run time and task stats gathering related definitions</code>：运行时间和任务状态收集相关定义。FreeRTOS可以收集任务运行时间和任务状态信息，相关参数如下图所示：</p>
<p> <img src="/img/loading.gif" data-original="运行时间和任务状态收集相关定义.png" alt="运行时间和任务状态收集相关定义"></p>
</li>
</ol>
<ul>
<li><code>GENERATE_RUN_TIME_STATS</code>：若设置为<code>Enabled</code>，则会启动任务运行时间统计功能，并可以通过函数<code>vTaskGetRunTimeStats()</code>读取这些信息。</li>
<li><code>USE_TRACE_FACILITY</code>：若设置为<code>Enabled</code>，则会增加一些结构体成员和函数，用于可视化和跟踪调试。</li>
<li><code>USE_STATS_FORMATTING_FUNCTIONS</code>：若<code>USE_TRACE_FACILITY</code>和这个参数都设置为<code>Enabled</code>，则会编译函数<code>vTaskList()</code>和<code>vTaskGetRunTimeStats()</code>。这两个参数中只要有一个设置为<code>Disabled</code>，就不会编译这个函数。</li>
</ul>
<ol>
<li><p><code>Co-routine related definitions</code>：协程相关定义。使用协程可以节省内存，主要用于功能有限、内存很小的MCU。现在的MCU内存一般比较充足，就很少使用协程了，所以禁用此功能即可。</p>
<p> <img src="/img/loading.gif" data-original="协程相关定义.png" alt="协程相关定义"></p>
</li>
<li><p><code>Software timer definitions</code>：软件定时器定义。FreeRTOS可以创建软件定时器，其功能类似于高级语言(如C++)中的软件定时器。软件定时器相关参数的设置界面如下图所示：</p>
<p> <img src="/img/loading.gif" data-original="软件定时器相关参数的设置界面.png" alt="软件定时器相关参数的设置界面"></p>
</li>
</ol>
<ul>
<li><code>USE_TIMERS</code>：是否使用软件定时器，默认设置为<code>Enabled</code>，且不可修改。</li>
<li><code>TIMER_TASK_PRIORITY</code>：定时器服务任务的优先级，默认值是2，属于比较低的优先级。设置范围是0到55，因为总的优先级个数是56。</li>
<li><code>TIMER_QUEUE_LENGTH</code>：定时器指令队列的长度，设置范围是1到255。</li>
<li><code>TIMER-TASK_STACK_DEPTH</code>：定时器服务任务的栈空间大小，默认值256个字，设置范围是128到32768个字。<strong>注意，栈空间的单位是字，而不是字节</strong>。</li>
</ul>
<ol>
<li><p><code>Interrupt nesting behaviour configuration</code>：中断嵌套行为配置。如下图所示：</p>
<p> <img src="/img/loading.gif" data-original="中断嵌套行为配置.png" alt="中断嵌套行为配置"></p>
</li>
</ol>
<h4 id="3-3-2-INCLUDE-类的宏"><a href="#3-3-2-INCLUDE-类的宏" class="headerlink" title="3.3.2 INCLUDE_类的宏"></a>3.3.2 INCLUDE_类的宏</h4><p>前缀为<code>INCLUDE_</code>的宏，用作一些函数的条件编译的条件，控制是否编译这些函数的源代码，从而实现对FreeRTOS的功能裁剪。不编译应用程序中用不到的FreeRTOS API函数，可以使最终编译出的程序尽量小。</p>
<p>在文件<code>FreeRTOSConfig</code>和<code>FreeRTOS.h</code>中，都有<code>INCLUDE_</code>类的宏定义。与<code>config_</code>类的宏定义一样，文件<code>FreeRTOS.h</code>中的是默认的宏定义，例如，文件<code>FreeRTOS.h</code>中有如下的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_vTaskDelete</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这表示如果没有宏定义<code>INCLUDE_vTaskDelete</code>，就将这个宏定义为0。文件<code>FreeRTOS.h</code>中的定义是默认定义，<strong>请勿直接修改文件<code>FreeRTOS.h</code>里的内容</strong>。</p>
<p>文件<code>FreeRTOSConfig.h</code>是用户可修改的配置文件，在CubeMX里设置的<code>INCLUDE_</code>参数会在这个文件里生成宏定义。例如，文件<code>FreeRTOSConfig.h</code>中部分<code>INCLUDE_</code>类的宏定义如下，其中就有宏定义<code>INCLUDE_vTaskDelete</code>，其值定义为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskPrioritySet            1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskPriorityGet           1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete                 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskCleanUpResources       0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskSuspend                1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelayUntil             1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelay                  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetSchedulerState      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTimerPendFunctionCall      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xQueueGetMutexHolder        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskGetStackHighWaterMark 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_eTaskGetState               1</span></span><br></pre></td></tr></table></figure>
<p>前缀为<code>INCLUDE_</code>的宏一般用于函数代码的条件编译，例如，函数<code>vTaskDelete()</code>的源代码就有如下的条件编译，这表示当参数<code>INCLUDE_vTaskDelete</code>值为1时，才编译函数<code>vTaskDelete()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( INCLUDE_vTaskDelete == 1 )</span></span><br><span class="line"></span><br><span class="line">	PRIVILEGED_DATA <span class="type">static</span> List_t xTasksWaitingTermination = &#123;<span class="number">0</span>&#125;;				</span><br><span class="line">	PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>有些函数代码的编译条件还是多个参数的组合，例如，函数<code>eTaskGetState()</code>的编译条件如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )</span></span><br><span class="line">	eTaskState <span class="title function_">eTaskGetState</span><span class="params">( TaskHandle_t xTask )</span></span><br><span class="line">	&#123;</span><br><span class="line">        .......</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_eTaskGetState */</span></span></span><br></pre></td></tr></table></figure>
<p>在CubeMX的FreeRTOS配置部分，<code>Include parameters</code>页面用于设置<code>INCLUDE_</code>类宏的值，如下图所示：</p>
<p><img src="/img/loading.gif" data-original="Include_parameters设置界面.png" alt="Include parameters设置界面"></p>
<h2 id="4、FreeRTOS的任务管理"><a href="#4、FreeRTOS的任务管理" class="headerlink" title="4、FreeRTOS的任务管理"></a>4、FreeRTOS的任务管理</h2><p> 一个嵌入式操作系统的核心功能就是多任务管理系统，<strong>FreeRTOS的任务调度器具有基于优先级的抢占式任务调度方式</strong>，能满足实时性的要求。下面，将简单介绍FreeRTOS的多任务运行原理，各种任务调度方法的特点与应用。</p>
<h3 id="4-1-任务相关的一些概念"><a href="#4-1-任务相关的一些概念" class="headerlink" title="4.1 任务相关的一些概念"></a>4.1 任务相关的一些概念</h3><h4 id="4-1-1-多任务运行基本机制"><a href="#4-1-1-多任务运行基本机制" class="headerlink" title="4.1.1 多任务运行基本机制"></a>4.1.1 多任务运行基本机制</h4><p><strong>在FreeRTOS中，一个任务就是实现某种功能的一个函数</strong>，任务函数的内部一般有一个死循环结构。在<strong>任何时候都不允许从任务函数退出，也就是不能出现<code>return</code>语句</strong>。<u>如果需要结束任务，在任务函数里，可以跳出死循环，然后使用函数<code>vTaskDelete()</code>删除任务自己，也可以在其他任务里调用函数<code>vTaskDelete()</code>删除这个任务。</u></p>
<p>在FreeRTOS里，用户可以创建多个任务。每个任务需要分配一个栈(stack)空间和一个任务控制块(Task Control Block,TCB)空间。每个任务还需要设定一个优先级，优先级的数字越小，表示优先级越低。</p>
<p>在单核处理器上，任何时刻只能有一个任务占用CPU并运行。但是在FreeRTOS系统上，运行多个任务时，运行起来却好像多个任务在同时运行，这是由于RTOS的任务调度使得多个任务对CPU实现了<strong>分时复用功能。</strong></p>
<p><img src="/img/loading.gif" data-original="最简单的基于时间片的多任务运行原理.png" alt="最简单的基于时间片的多任务运行原理"></p>
<p>上图所示是最简单的基于时间片的多任务运行原理。假设只有两个任务，并且任务Task1和Task2具有相同的优先级。圆周表示CPU时间，如同钟表的一周，RTOS将CPU时间分成基本的时间片(time slice)，例如，<strong>FreeRTOS默认的时间片长度是1ms，也就是SysTick定时器的定时周期</strong>。在一个时间片内，会有一个任务占用CPU并执行，假设当前运行的任务是Task1。在一个时间片结束时(实际就是SysTick定时器发生中断时)进行任务调度，由于Task1和Task2具有相同的优先级，RTOS会将CPU使用权交给Task2。<strong>Task1交出CPU使用权时，会将CPU的当前场景(CPU各个核心寄存器的值)压入自己的栈空间，而Task2获取CPU使用权时，会用自己栈空间保存的数据恢复CPU场景，因而Task2可以从上次运行的状态继续运行</strong>。</p>
<p>基于时间片的多任务调度就是这样控制多个同等优先级任务实现CPU的分时复用，从而实现多任务运行的。因为时间片的长度很短(默认是1ms)，任务切换速度很快，所以程序运行时，给用户的感觉就像是同时在运行。</p>
<p>当多个任务的优先级不同时，FreeRTOS还会使用基于优先级的抢占式任务调度方法，每个人物获得的CPU使用时间长度是不同的。</p>
<h4 id="4-1-2-任务的状态"><a href="#4-1-2-任务的状态" class="headerlink" title="4.1.2 任务的状态"></a>4.1.2 任务的状态</h4><p>由单核CPU的多任务运行机制可知，任何时刻，只能由一个任务占用CPU并运行，这个任务的状态成为运行(running)状态，其它未占用CPU的任务的状态都可称为非运行(not running)状态。非运行状态又可以细分为3个状态（挂起状态、就绪状态、阻塞状态），任务的各个状态的切换如下所示：</p>
<p><img src="/img/loading.gif" data-original="任务的状态以及状态之间的转换.png" alt="任务的状态以及状态之间的转换"></p>
<p>FreeRTOS任务调度有抢占式(pre-emptive)和合作式(co-operative)两种方式，一般使用<strong>基于任务优先级的抢占式任务调度方法</strong>。下面使用抢占式任务调度方法为例。</p>
<ol>
<li><strong>就绪状态</strong></li>
</ol>
<p>任务被创建之后就处于就绪(ready)状态。FreeRTOS的任务调度器在基础时钟每次中断时进行一次任务调度申请，根据抢占式任务调度的特点，任务调度的结果有以下几种情况。</p>
<ul>
<li>如果当前没有其他处于运行状态的任务，处于就绪状态的任务进入运行状态。</li>
<li>如果就绪任务的优先级高于或等于当前任务的优先级，处于就绪状态的任务进入运行状态。</li>
<li>如果就绪任务的优先级低于当前任务的优先级，处于就绪状态的任务无法获得CPU使用权，继续处于就绪状态。</li>
</ul>
<p>就绪的任务获取CPU的使用权，进入运行状态，这个过程称为切入(switch in)。相应的，处于运行状态的任务被调度器调度为就绪状态，这个过程称为切出(switch out)。</p>
<ol>
<li><strong>运行状态</strong></li>
</ol>
<p>在单核处理器上，占有CPU运行的任务就处于运行状态。处于运行状态的高优先级任务如果一直运行，将一直占用CPU，在任务调度时，低优先级的就绪任务就无法获得CPU的使用权，无法实现多任务的运行。因此，<strong>处于运行状态的任务，应该在空闲时让出CPU的使用权。</strong></p>
<p>处于就绪状态的任务，有两种方式可以让出CPU使用权的方法，<strong>一种是执行函数<code>vTaskSuspend()</code>进入挂起状态，另一种是执行阻塞式函数进入阻塞状态</strong>。这两种状态都是非运行状态，运行的状态就交出了CPU的使用权，任务调度器可以使其他就绪状态的任务进入运行状态。</p>
<ol>
<li><strong>阻塞状态</strong></li>
</ol>
<p><strong>阻塞(blocked)状态就是任务暂时让出CPU的使用权，处于等待的状态</strong>。运行状态的任务可以调用两类函数进入阻塞状态。</p>
<p>一类是时间延迟函数，如<code>vTaskDelay()</code>或<code>vTaskDelayUntil()</code>。处于运行状态的任务调用这类函数之后，就进入阻塞状态，并延迟指定时间。<strong>延迟时间到了之后，就又进入就绪状态，参与任务调度之后，又可以进入运行状态。</strong></p>
<p>另一类是用于进程间通信的事件请求函数，例如，请求信号量的函数<code>xSemaphoreTake()</code>。处于运行状态的任务执行函数<code>xSemaphoreTake()</code>后，就进入阻塞状态，如果其他任务释放了信号量，或等待的超时时间到了，任务就从阻塞状态进入就绪状态。</p>
<p>在运行状态的任务中调用函数<code>vTaskSuspend()</code>，可以间一个处于阻塞状态的任务转入挂起状态。</p>
<ol>
<li><strong>挂起状态</strong></li>
</ol>
<p><strong>挂起(suspended)状态的任务就是暂停的任务，不参与调度器的调度</strong>。其他3种状态的任务都可以通过<code>vTaskSuspend()</code>进入挂起状态。<strong>处于挂起状态的任务不能自动退出挂起状态，需要在其他任务里调用函数<code>vTaskResume()</code>，才能使一个挂起的任务变为就绪状态。</strong></p>
<h4 id="4-1-3-任务的优先级"><a href="#4-1-3-任务的优先级" class="headerlink" title="4.1.3 任务的优先级"></a>4.1.3 任务的优先级</h4><p>在FreeRTOS中，每个任务都必须设置一个优先级。总的优先级个数由文件<code>FreeRTOSConfig.h</code>中的宏<code>configAX_PRIORITIES</code>定义，默认值是56。<strong>优先级数字越小，优先级越低，所以最低优先级是0</strong>，在任务运行起来后，还可以修改优先级。多个任务可以具有相同的优先级。</p>
<p>另外，参数<code>configMAX_PRIORITIES</code>可设置的最大值，以及调度器决定那个就绪任务进入运行状态，还与参<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>的取值有关。根据这个参数的取值，任务调度器有两种方法。</p>
<p>(1) 通用方法。<strong>若<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>设置为0，则为通用方法</strong>。通用方法是使用C语言实现的，可以在所有的FreeRTOS移植版本上使用，<code>configMAX_PRIORITIES</code>的最大值页不受限制。</p>
<p>(2) 架构优化的方法。<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>设置为1，则为架构优化方法，部分代码是用汇编语言写的，运行速度比通用方法快。使用架构优化方法时，<code>configMAX_PRIORITIES</code>的最大值不能超过32。<strong>在使用Cortex-M0架构或CMSIS-RTOS V2接口时，不能使用架构优化方法。</strong></p>
<h4 id="4-1-4-空闲任务"><a href="#4-1-4-空闲任务" class="headerlink" title="4.1.4 空闲任务"></a>4.1.4 空闲任务</h4><p>在main()函数中，调用<code>osKernelStart()</code>启动FreeRTOS的任务调度器时，FreeRTOS会自动创建一个空闲任务(idle task)，空闲任务的优先级为0，也就是最低优先级。</p>
<p><strong>在FreeRTOS中，任何时候都需要有一个任务占用CPU，处于运行状态</strong>。如果用户创建的任务都不处于运行状态，空闲任务就占用CPU处于运行状态。</p>
<p>空闲任务是比较重要的。与空闲任务相关的配置函数有如下几个：</p>
<ul>
<li><code>configUSE_TICK_HOOK</code>：是否使用空闲任务的钩子函数，若配置为1，则可以利用空闲任务的钩子函数，在系统空闲时做一些处理。例如，利用空闲任务钩子函数使系统进入低功耗状态。</li>
<li><code>configIDLE_SHOULD_YIELD</code>：空闲任务是否对同等优先级的用户任务主动让出CPU使用权。</li>
<li><code>configUSE_TICKLESS_IDLE</code>：是否使用tickless低功耗模式，若设置为1，可以实现系统的低功耗。</li>
</ul>
<h4 id="4-1-5-基础时钟与滴答信号"><a href="#4-1-5-基础时钟与滴答信号" class="headerlink" title="4.1.5 基础时钟与滴答信号"></a>4.1.5 基础时钟与滴答信号</h4><p>FreeRTOS自动采用SysTick定时器作为FreeRTOS的基础时钟。<strong>SysTick定时器只有定时器中断功能，其定时频率由参数<code>configTICK_RATE_HZ</code>指定，默认值为1000，也就是1ms中断一次</strong>。</p>
<p>在FreeRTOS中有一个全局变量<code>xTickCount</code>，在SysTick每次中断时，这个变量加1，也就是1ms变化一次。所谓的FreeRTOS滴答信号，就是指全局变量<code>xTickCount</code>的值发生变化的值，延时函数<code>vTaskDelay()</code>和<code>vTaskDelayUntil()</code>就是通过滴答信号实现毫秒延时的。</p>
<p><strong>SysTick定时器中断不仅用于产生滴答信号，还用于产生任务切换申请</strong>。</p>
<h3 id="4-2-FreeRTOS任务调度"><a href="#4-2-FreeRTOS任务调度" class="headerlink" title="4.2 FreeRTOS任务调度"></a>4.2 FreeRTOS任务调度</h3><h4 id="4-2-1-任务调度方法概述"><a href="#4-2-1-任务调度方法概述" class="headerlink" title="4.2.1 任务调度方法概述"></a>4.2.1 任务调度方法概述</h4><p>FreeRTOS有两种调度算法，<strong>基于优先级的抢占式调度算法</strong>与<strong>合作式调度算法</strong>。其中抢占式调度算法可以使用时间片，也可以不使用时间片。通过参数的设置，用户可以选择具体的调度算法。FreeRTOS的任务调度方法有三种。其对应的参数名称、取值及特点如下：</p>
<p><img src="/img/loading.gif" data-original="FreeRTOS的任务调度方法.png" alt="FreeRTOS的任务调度方法"></p>
<p>在FreeRTOS中，默认的是<strong>使用带有时间片的抢占式任务调度方法</strong>。在CubeMX中用户不能设置参数<code>configUSE_TIME_CLICING</code>，其值默认为1。</p>
<h4 id="4-2-2-使用时间片的抢占式调度方式"><a href="#4-2-2-使用时间片的抢占式调度方式" class="headerlink" title="4.2.2 使用时间片的抢占式调度方式"></a>4.2.2 使用时间片的抢占式调度方式</h4><p>抢占式任务调度方式，是FreeRTOS主动进行任务调度，分为使用时间片贺不适用时间片两种情况。<strong>FreeRTOS基础时钟的一个定时周期称为一个时间片，FreeRTOS的基础时钟是SysTick定时器。基础时钟的定时周期由参数<code>configTICK_RATE_HZ</code>决定，默认值为1000Hz，所以时间片时长为1ms。</strong>当使用时间片时， 在基础时钟的每次中断里，系统会要求进行一次<strong>上下文切换</strong>。文件<code>port.c</code>中的函数<code>xPortSysTickHandler()</code>就是SysTick定时中断的处理函数，其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xPortSysTickHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*!&lt; SysTick中断的抢占优先级时15，优先级最低，所以使用这个中断时需要禁用所有中断 */</span></span><br><span class="line">	portDISABLE_INTERRUPTS(); <span class="comment">/*!&lt; 禁用所有中断 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Increment the RTOS tick. */</span></span><br><span class="line">		<span class="keyword">if</span>( xTaskIncrementTick() != pdFALSE ) <span class="comment">/*!&lt; 增加RTOS滴答计数器的值 */</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">/*!&lt;将PendSV中断的挂起标志位置位，申请进行上下文切换，在PenSV中断里处理上下文切换*/</span></span><br><span class="line">			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	portENABLE_INTERRUPTS(); <span class="comment">/*!&lt; 使能中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的功能是将PendSV(Pendable request for system serivce，可挂起的系统服务请求)中断的挂起标志位置位，也就是发起上下文切换的请求，<strong>而进行上下文切换是在PendSV的中断服务函数里面完成的</strong>。文件<code>port.c</code>中的函数<code>xPortPendSVHandler()</code>是FreeRTOS的PendSV中断服务函数，其功能就是<strong>根据任务调度计算的结果，选择下一个任务进入运行状态</strong>。</p>
<p>在CubeMX中，一个项目使用了FreeRTOS之后，会自动对NVIC做一些设置。<strong>系统自动将优先级分组方案设置为4位全部用于抢占式优先级</strong>，SysTick和PendSV中断的抢占式优先级都是15，也就是最低优先级。<strong>FreeRTOS在最低优先级的PendSV的中断服务函数里进行上下文切换，所以，FreeRTOS的任务切换的优先级总是低于系统中断的优先级。</strong></p>
<p>使用时间片的抢占式调度方法特点如下：</p>
<ul>
<li>在基础时钟每个中断里发起一次任务调度请求。</li>
<li>在PendSV中断服务函数里进行上下文切换。</li>
<li>在上下文切换时，高优先级的就绪任务获得CPU的使用权。</li>
<li>若多个就绪状态的任务的优先级相同，则将轮流获得CPU的使用权。</li>
</ul>
<p>如下图所示是使用带时间片的抢占式任务调度方法时，3个任务运行的时序图，其中Task2具有高优先级，Task1具有正常优先级，且这两个任务的优先级都高于空闲任务的优先级。</p>
<p><img src="/img/loading.gif" data-original="带时间片的抢占式任务调度方法任务运行时序图.png" alt="带时间片的抢占式任务调度方法任务运行时序图"></p>
<p>可以从图上看到具体的任务运行和切换过程如下：</p>
<ul>
<li><em>t</em>1时刻开始是空闲任务在运行，这时候系统里面没有其他任务处于就绪状态。</li>
<li>在<em>t</em>2时刻进行调度时，Task1抢占CPU开始运行。</li>
<li>在<em>t</em>3时刻，Task1进入阻塞状态，暂时让出CPU使用权，空闲任务又进入运行状态。</li>
<li>在<em>t</em>4时刻，Task1又进入运行状态。</li>
<li>在<em>t</em>5时刻，更高优先级的Task2抢占了CPU开始运行，Task1进入就绪状态。</li>
<li>在<em>t</em>6时刻，Task2运行后进入阻塞状态，让出CPU使用权，Task1从就绪状态变为运行状态。</li>
<li>在<em>t</em>7时刻，Task1进入阻塞状态，空闲任务又进入运行状态。</li>
</ul>
<p>可以看出，<strong>在低优先级任务运行时，高优先级的任务能抢占获得CPU的使用权。在没有其他任务运行时，空闲任务处于运行状态，否则，空闲状态处于就绪状态</strong>。</p>
<p><strong>当多个就绪状态的任务优先级相同时，它们将轮流获得CPU的使用，每个任务占用CPU运行1个时间片的时间</strong>。</p>
<p><strong>如果就绪任务的优先级与空闲任务的优先级都相同时，参数<code>configIDLE_SHOULD_YIELD</code>就会影响任务调度的结果</strong>。</p>
<ul>
<li>如果<code>configIDLE_SHOULD_YIELD</code>设置为0，表示<strong>空闲任务不会主动让出CPU的使用权，空闲任务与其他优先级为0的就绪任务轮流使用CPU</strong>。</li>
<li>如果<code>configIDLE_SHOULD_YIELD</code>设置为1，表示<strong>空闲任务会主动让出CPU的使用权，空闲任务不会占用CPU</strong>。</li>
</ul>
<p>参数<code>configIDLE_SHOULD_YIELD</code>的默认值为1。设计用户任务时，用户任务的优先级一般要高于空闲任务。</p>
<h4 id="4-2-3-不使用时间片的抢占式调度方法"><a href="#4-2-3-不使用时间片的抢占式调度方法" class="headerlink" title="4.2.3 不使用时间片的抢占式调度方法"></a>4.2.3 不使用时间片的抢占式调度方法</h4><p>当配置为不使用时间片的抢占式调度方法时，任务选择和抢占式的算法是错误的，只是<strong>对于相同优先级的任务，不再使用时间片平均分配CPU使用时间</strong>。</p>
<p>使用时间片的抢占式调度算法，在基础时钟每次中断时进行一次上下文切换请求，从而进行任务调度；而不使用时间片的抢占式调度算法，只在以下情况下才进行任务调度。</p>
<ul>
<li>有更高优先级的任务进入就绪状态时。</li>
<li>运行状态的任务进入阻塞状态或挂起状态时。</li>
</ul>
<p>所以，<strong>不使用时间片时，进行上下文切换的频率比使用时间片时低</strong>，从而可降低CPU的负担。但是，<strong>对于同等优先级的任务，可能会出现占用CPU时间相差很大的情况</strong>。</p>
<p>如下图所示的是不适用时间片的抢占式任务调度方式，存在同等优先级任务时的任务运行时序图。</p>
<p><img src="/img/loading.gif" data-original="不使用时间片的抢占式任务调度方法，存在同等优先级任务运行时序图.png" alt="不使用时间片的抢占式任务调度方法，存在同等优先级任务运行时序图"></p>
<p>其中，Task0与空闲任务优先级相同，且是连续运行的。具体任务运行和切换过程如下：</p>
<ul>
<li>在<em>t</em>1时刻，空闲任务占用CPU，因为系统里没有其他处于就绪状态的任务。</li>
<li>在<em>t</em>2时刻，Task0进入就绪状态，但是Task0与空闲任务优先级相同，且调度算法不使用时间片，不会让Task0和空闲任务轮流使用CPU，所以Task0就保持就绪状态。</li>
<li>在<em>t</em>4时刻，高优先级的Task1抢占CPU。</li>
<li>在<em>t</em>5时刻，Task1进入阻塞状态，系统进行一次任务调度，Task0获得CPU的使用权。</li>
<li>在<em>t</em>6时刻，Task1再次抢占Task0又进入就绪状态。</li>
<li>在<em>t</em>7时刻，Task1进入阻塞状态，系统进行一次任务调度，空闲任务获得CPU使用权。之后没有发生任务调度的机会，所以Task0就一直处于就绪状态。</li>
</ul>
<h4 id="4-2-4-合作式任务调度方法"><a href="#4-2-4-合作式任务调度方法" class="headerlink" title="4.2.4 合作式任务调度方法"></a>4.2.4 合作式任务调度方法</h4><p>使用合作式任务调度方法时，FreeRTOS不主动进行上下文切换，而是<strong>当运行状态的任务进入阻塞状态时，或运行状态的任务调用函数<code>taskYIELD()</code>时，才会进行一次上下文切换</strong>。任务不会发生抢占，所以也不使用时间片。函数<code>taskYIELD()</code>的作用就是主动申请进行一次上下文切换。</p>
<p>如下图时使用合作式任务调度方法时，3个不同优先级的任务时序图，可以体现合作式任务调度方法的特点。</p>
<p><img src="/img/loading.gif" data-original="使用合作式任务调度方法的任务运行时序图.png" alt="使用合作式任务调度方法的任务运行时序图"></p>
<ul>
<li>在<em>t</em>1时刻，低优先级的Task1处于运行状态。</li>
<li>在<em>t</em>2时刻，中等优先级的Task2进入就绪状态，但不能抢占CPU。</li>
<li>在<em>t</em>3时刻，高优先级的Task3进入就绪状态，但是也不能抢占CPU。</li>
<li>在<em>t</em>4时刻，Task1调用函数<code>taskYIELD()</code>，主动申请进行一次上下文切换，高优先级的Task3获得CPU使用权。</li>
<li>在<em>t</em>5时刻，Task3进入阻塞状态，就绪的Task2获得CPU的使用权。</li>
<li>在<em>t</em>6时刻，Task2进入阻塞状态，Task1又获得CPU使用权。</li>
</ul>
<h3 id="4-3-任务管理相关函数"><a href="#4-3-任务管理相关函数" class="headerlink" title="4.3 任务管理相关函数"></a>4.3 任务管理相关函数</h3><h4 id="4-3-1-相关函数概述"><a href="#4-3-1-相关函数概述" class="headerlink" title="4.3.1 相关函数概述"></a>4.3.1 相关函数概述</h4><p>在FreeRTOS中，任务的管理主要包括<strong>任务的创建、删除、挂起、恢复</strong>等操作，还包含<strong>任务调度器的启动、挂起与恢复，以及使任务进入阻塞状态的延迟函数等</strong>。</p>
<p>FreeRTOS中任务管理相关的函数都在文件<code>task.h</code>中定义，在文件<code>tasks.c</code>中实现。在CMSIS-RTOS中还有一些函数，对FreeRTOS的函数进行了封装，也就是调用相应的FreeRTOS函数实现相同的功能，这些标准接口函数的定义在文件<code>cmsis_os.h</code>和<code>cmsis_os2.h</code>中。<strong>CubeMX生成的代码一般使用CMSIS-RTOS标准接口函数，在用户自己编写的程序中，一般直接使用FreeRTOS的函数</strong>。</p>
<p>任务管理常用的一些函数及其功能如下：</p>
<p><img src="/img/loading.gif" data-original="任务管理常用的一些函数及其功能描述.png" alt="任务管理常用的一些函数及其功能描述"></p>
<p>上表中的FreeRTOS函数基本都有对应的CMSIS-RTOS标准函数，只有以下几个比较特殊。</p>
<ul>
<li>FreeRTOS创建任务的函数有两个，<strong><code>xTaskCreate()</code>用于创建动态分配内存的任务</strong>，<strong><code>xTaskCreateStatic()</code>用于创建静态分配内存的任务</strong>。对应的CMSIS-RTOS标准函数<code>osThreadNew()</code>会根据任务的参数自动调用其中的某个函数。</li>
<li><p>函数<code>vTaskDelete()</code>可以根据传递传递的参数不同，删除另一个任务或当前任务，对应的CMSIS-RTOS标准函数有两个，<strong><code>osThreadTerminate()</code>用于删除另一个任务，<code>osThreadExit()</code>用于删除当前任务</strong>。</p>
</li>
<li><p>函数<code>xTaskAbortDelay()</code><strong>用于终止另一个任务的延时，使其退出阻塞状态</strong>，这个函数没有对应的CMSIS-RTOS的函数。</p>
</li>
</ul>
<p>除了上述这些函数，文件<code>task.h</code>中还有几个常用的宏函数，其定义代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskDISABLE_INTERRUPTS() portDISABLE_INTERRUPTS() <span class="comment">//关闭MCU所有可屏蔽中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENABLE_INTERRUPTS() portENABLE_INTERRUPTS()   <span class="comment">//使能MCU的中断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL() portENTER_CRITICAL()         <span class="comment">//开始临界代码段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL()	portEXIT_CRITICAL()		      <span class="comment">//结束临界代码段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL_FROM_ISR(x) portCLEAR_INTERRUPT_MASK_FROM_ISR(x)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>宏函数<code>taskDISABLE_INTERRUPTS()</code>和<code>taskENABLE_INTERRUPTS()</code>用于关闭和开启MCU的可屏蔽中断，<strong>用于界定不受其他中断干扰的代码段</strong>。<strong>只能关闭FreeRTOS可管理的中断优先级</strong>，即参数<code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>定义的最高优先级。<strong>这两个函数必须成对使用，且不能嵌套使用</strong>。</li>
<li>函数<code>taskENTER_CRITICAL()</code>和<code>taskEXIT_CRITICAL()</code>用于界定临界代码段。<strong>在临界代码段内，任务不会被更高优先级的任务抢占</strong>，可以保证代码执行的连续性。<em>例如，一段代码需要通过串口上传一批数据，如果被更高优先级的任务抢占了PCU的使用权，上传的过程被打断，上传数据就可能出现问题，这时就可以将这段代码界定为临界代码段</em>。函数<code>taskENTER_CRITICAL()</code>内部会调用关闭可屏蔽中断的函数<code>portDISABLE_INTERRUPTS()</code>，与宏函数<code>taskDISABLE_INTERRUPTS()</code>实现的功能相似。<strong>函数<code>taskENTER_CRITICAL()</code>和<code>taskEXIT_CRITICAL()</code>必须成对使用，但可以嵌套使用</strong>。</li>
<li><code>taskENTER_CRITICAL_FROM_ISR()</code>是<code>taskENTER_CRITICAL()</code>的ISR版本，用于在终端服务例程中调用。<em>注意，FreeRTOS的所有API函数分为普通版本和ISR版本，<strong>如果要在ISR里面调用FreeRTOS的API函数，必须使用其ISR版本</strong></em>。</li>
</ul>
<h4 id="4-3-2-主要函数功能说明"><a href="#4-3-2-主要函数功能说明" class="headerlink" title="4.3.2 主要函数功能说明"></a>4.3.2 主要函数功能说明</h4><ol>
<li><strong>创建任务</strong></li>
</ol>
<p>在之前的LED翻转实验中可以看到，CubeMX生成的代码中，在<code>MX_FREERTOS_Init()</code>中使用函数<code>osThreadNew()</code>创建任务，根据任务的属性设置，<code>osThreadNew()</code>内部会自动调用<code>xTaskCreate()</code>以动态分配内存的方式创建任务，或者调用<code>xTaskCreateStatic()</code>以静态分配内存方式创建任务。函数<code>osThreadNew()</code>的原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, <span class="type">void</span> *argument, <span class="type">const</span> osThreadAttr_t *attr)</span></span><br></pre></td></tr></table></figure>
<p>返回的数据是所创建任务的句柄，数据类型<code>osThreadID_t</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *osThreadId_t;</span><br></pre></td></tr></table></figure>
<p>使用动态分配内存方式创建任务的函数为<code>xTaskCreate()</code>，其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(TaskFunction_t pxTaskCode,       <span class="comment">//任务函数名称</span></span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,                  <span class="comment">//任务的备注名称</span></span></span><br><span class="line"><span class="params">			<span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,  <span class="comment">//栈空间大小，单位：字</span></span></span><br><span class="line"><span class="params">			<span class="type">void</span> * <span class="type">const</span> pvParameters,                  <span class="comment">//传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">			UBaseType_t uxPriority,                     <span class="comment">//任务优先级</span></span></span><br><span class="line"><span class="params">			TaskHandle_t * <span class="type">const</span> pxCreatedTask)</span>         <span class="comment">//任务的句柄</span></span><br></pre></td></tr></table></figure>
<p>函数<code>xTaskCreate()</code>返回值的类型为<code>BaseType_t</code>，若其值为<code>pdPASS</code>表示任务创建成功。创建的任务的句柄是函数中的参数<code>pxCreateTask</code>，其类型是<code>TaskHandle_t</code>。这个类型的定义与<code>osThreadID_t</code>是相同的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *TaskHandle_t;</span><br></pre></td></tr></table></figure>
<p>使用静态分配内存方式创建任务的函数为<code>xTasskCreateStatic()</code>，其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">(TaskFunction_t pxTaskCode,<span class="comment">//任务函数名称</span></span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,                   <span class="comment">//任务的备注名称</span></span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,                 <span class="comment">//栈空间大小，单位：字</span></span></span><br><span class="line"><span class="params">            <span class="type">void</span> * <span class="type">const</span> pvParameters,                   <span class="comment">//传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">            UBaseType_t uxPriority,                      <span class="comment">//任务优先级</span></span></span><br><span class="line"><span class="params">            StackType_t * <span class="type">const</span> puxStackBuffer,          <span class="comment">//任务的栈空间数组</span></span></span><br><span class="line"><span class="params">            StaticTask_t * <span class="type">const</span> pxTaskBuffer)</span>           <span class="comment">//任务控制块存储空间</span></span><br></pre></td></tr></table></figure>
<p>函数<code>xTaskCreateStatic()</code>返回的数据类型为<code>TaskHandle_t</code>，返回的数据就是所创建任务的句柄。</p>
<p><strong>用户可以在启动任务调度器之前创建所有的任务，也可以在启动任务调度器之后，在一个任务的任务函数里创建其他任务</strong>。</p>
<ol>
<li><strong>删除任务</strong></li>
</ol>
<p>删除任务的函数时<code>vTaskDelete()</code>，其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span></span><br></pre></td></tr></table></figure>
<p><code>TaskHandle_t</code>类型的参数<code>xTaskToDelete</code>是需要删除的任务的句柄。<strong>如果要删除任务自己，则传递参数<code>NULL</code>即可。</strong> <em>注意，如果要删除任务自己，<strong>必须在跳出任务死循环之后，在退出任务函数之前执行<code>vTaskDelete(NULL)</code></strong></em>。</p>
<p>删除任务时，FreeRTOS会自动释放系统自动分配的内存，如动态分配的占空间和任务控制块，但是<strong>在任务内由用户自己分配的内存，需要在删除任务之前手工释放</strong>。</p>
<ol>
<li><strong>挂起任务</strong></li>
</ol>
<p>挂起一个任务的函数为<code>vTaskSuspend()</code>，其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspend</span><span class="params">(TaskHandle_t xTaskToSuspend)</span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>xTaskToSuspend</code>是需要挂起的任务的句柄，如果是要挂起任务自己，则传递参数<code>NULL</code>。被挂起的任务将不再参与任务调度，但是还存在于系统中，可以被恢复。</p>
<ol>
<li><strong>恢复任务</strong></li>
</ol>
<p>恢复一个挂起的任务的函数为<code>vTaskResume()</code>，其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">(TaskHandle_t xTaskToResume)</span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>xTaskToResume</code>为需要恢复的任务的句柄，<strong>一个挂起的任务不能在任务函数里面恢复自己，只能在其他任务的函数里面恢复，所以参数不能是<code>NULL</code></strong>。</p>
<ol>
<li><strong>启动任务调度器</strong></li>
</ol>
<p>函数<code>vTaskStartScheduler()</code>可以用于启动任务调度器，开始FreeRTOS的运行，其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskStartScheduler</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>
<p>函数<code>vTaskStartScheduler()</code>会自动创建一个空闲任务，空闲任务的优先级为0。如果设置参数<code>configUSE_TIMERS</code>的值为1，也就是需要软件定时器，还会自动创建一个<strong>时间守护任务</strong>。</p>
<ol>
<li><strong>延时函数</strong></li>
</ol>
<p>延时函数<code>vTaskDelay()</code>用于延时一定节拍数，它会使当前任务进入阻塞状态。<strong>任何任务都需要在空闲的时候进入阻塞状态</strong>，以让出CPU的使用权，是其他低优先级的任务可以获得CPU使用权，否则，一个高优先级的任务将总是占据CPU，导致其他低优先级的任务无法运行。函数<code>vTaskDelay()</code>的原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">(<span class="type">const</span> TickType_t xTicksToDelay)</span></span><br></pre></td></tr></table></figure>
<p>其中<code>xTicksToDelay</code>是需要延时的节拍数，是基础时钟的节拍数。<strong>一般，我们会结合宏函数<code>pdMS_TO_TICKS()</code>，将一个以毫秒为单位的时间转换为节拍数，然后调用<code>vTaskDelay()</code>，这样可以使延时时间不受FreeRTOS基础时钟频率变化的影响</strong>。</p>
<p>一般的，使用延时函数进入阻塞状态的任务函数的基本代码结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_Function</span><span class="params">(<span class="type">void</span> *argument)</span>&#123;</span><br><span class="line">	<span class="comment">/*!&lt; 任务初始化 */</span></span><br><span class="line">	TickType_t ticks2 = pdMS_TO_TICKS(<span class="number">500</span>); <span class="comment">//延时时间500ms转换为节拍数</span></span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="comment">/*!&lt; 死循环内的功能代码 */</span></span><br><span class="line">		vTaskDelay(ticks2); <span class="comment">//空闲时进行延时，进入阻塞状态</span></span><br><span class="line">	&#125;</span><br><span class="line">	vTaskDelete(<span class="literal">NULL</span>); <span class="comment">//如果跳出死循环，需要在函数退出前删除任务自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>绝对延时函数</strong></li>
</ol>
<p>绝对延时函数<code>vTaskDelayUntil()</code>的功能与延时函数<code>vTaskDelay()</code>的相似，也用于延时，并且使得任务进入阻塞状态。不同的是，<strong>函数<code>vTaskDelay()</code>的延时时间长度是相对于进入阻塞状态的时刻的</strong>，但是对于任务的死循环，一个循环的周期时间是不确定的，因为循环内执行的代码的时间长度是未知的，可能被其他任务抢占。</p>
<p>如果需要在任务函数内实现严格的周期性的循环，那么可以使用绝对延时函数<code>vTaskDelayUntil()</code>，其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">(TickType_t * <span class="type">const</span> pxPreviousWakeTime, <span class="type">const</span> TickType_t xTimeIncrement)</span></span><br></pre></td></tr></table></figure>
<p>其中<code>pxPreviousWakeTime</code>为上次任务唤醒时基础计数器的值，参数<code>xTimeIncrement</code>表示相当于上次唤醒时刻延时的节拍数。函数<code>vTaskDelayUntil()</code>每次会自动更新<code>pxPreviousWakeTime</code>的值，但是在第一次调用时，需要给一个初值。</p>
<p>函数<code>vTaskDelay()</code>和<code>vTaskDelayUntil()</code>的意义和区别如下图所示：</p>
<p><img src="/img/loading.gif" data-original="函数vTaskDelay和vTaskDelayUntil的意义和区别.png" alt="函数vTaskDelay和vTaskDelayUntil的意义和区别"></p>
<p><strong>其中高电平为任务运行时间，低电平为阻塞时间</strong>。</p>
<p>用户可以通过函数<code>xTaskGetTickCount()</code>返回滴答信号当前计数值，作为<code>pxPreviousWakeTime</code>的初始值。使用<code>vTaskDelayUntil</code>的任务函数的一般代码结构如下，可以实现任务的循环周期为比较精确的1000ms。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_Function</span><span class="params">(<span class="type">void</span> *argument)</span>&#123;</span><br><span class="line">	<span class="comment">/*!&lt; 任务初始化 */</span></span><br><span class="line">	TickType_t previousWakeTime = xTaskGetTickCount();<span class="comment">//获得滴答信号当前计数值</span></span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="comment">/*!&lt; 死循环内的功能代码 */</span></span><br><span class="line">		vTaskDelayUntil(&amp;previousWakeTime, pdMS_TO_TICKS(<span class="number">1000</span>)); <span class="comment">//循环周期1000ms</span></span><br><span class="line">	&#125;</span><br><span class="line">	vTaskDelte(<span class="literal">NULL</span>);<span class="comment">//如果跳出死循环，需要在函数退出前删除任务自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-多任务编程示例（一）"><a href="#4-4-多任务编程示例（一）" class="headerlink" title="4.4 多任务编程示例（一）"></a>4.4 多任务编程示例（一）</h3><h4 id="4-4-1-示例功能与CubeMX项目设置"><a href="#4-4-1-示例功能与CubeMX项目设置" class="headerlink" title="4.4.1 示例功能与CubeMX项目设置"></a>4.4.1 示例功能与CubeMX项目设置</h4><p>设计一个示例，以测试FreeRTOS的多任务功能。使用战舰开发板作为开发平台，使用开发板上的两个LED灯，任务1里使LED1闪烁，任务2里使LED2闪烁。</p>
<p>在CubeMX中配置时钟与GPIO，与之前LED闪烁的配置类似，这里不再赘述，在FreeRTOS配置界面的<code>Tasks and Queues</code>中新建一个任务，并且将默认任务进行修改。</p>
<p><img src="/img/loading.gif" data-original="两个任务的基本参数.png" alt="两个任务的基本参数"></p>
<p>本次示例的两个任务的设置有如下要点：</p>
<ul>
<li>两个任务的优先级都设置为<code>osPriorityNormal</code>，也就是具有相同的优先级。</li>
<li>两个任务采用了不同的内存分配方式，Task_LED0使用动态分配内存，Task_LED1使用静态分配内存。使用静态分配内存时，需要在设置作为占空间的数组名称以及控制块名称。</li>
</ul>
<h4 id="4-4-2-初始程序分析"><a href="#4-4-2-初始程序分析" class="headerlink" title="4.4.2 初始程序分析"></a>4.4.2 初始程序分析</h4><ol>
<li><strong>主程序</strong></li>
</ol>
<p>本示例中使用CubeMX生成的代码的主程序<code>main.c</code>代码和之前的LED闪烁示例中一样，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/*!&lt; 系统时钟配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">/*!&lt; FreeRTOS对象初始化函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line"> </span><br><span class="line">  osKernelInitialize(); <span class="comment">/*!&lt; 初始化FreeRTOS的调度器 */</span></span><br><span class="line">  MX_FREERTOS_Init();   <span class="comment">/*!&lt; FreeRTOS对象初始化函数 */</span></span><br><span class="line">  osKernelStart();      <span class="comment">/*!&lt; 启动FreeRTOS的任务调度器 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*!&lt; 程序无法运行到这里，因为RTOS的任务调度器接管了系统的控制 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>任务的创建</strong></li>
</ol>
<p>使用CubeMX生成的<code>freertos.c</code>文件代码，基本上和之前的LED闪烁示例一样，只是多了一个<code>AppTask_LED1</code>任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> StaticTask_t osStaticThreadDef_t;</span><br><span class="line"><span class="comment">/* Definitions for Task_LED0 */</span></span><br><span class="line">osThreadId_t Task_LED0Handle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t Task_LED0_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;Task_LED0&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Definitions for Task_LED1 */</span></span><br><span class="line">osThreadId_t Task_LED1Handle;</span><br><span class="line"><span class="type">uint32_t</span> Task_LED1Buffer[ <span class="number">128</span> ];</span><br><span class="line">osStaticThreadDef_t Task_LED1ControlBlock;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t Task_LED1_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;Task_LED1&quot;</span>,</span><br><span class="line">  .cb_mem = &amp;Task_LED1ControlBlock,</span><br><span class="line">  .cb_size = <span class="keyword">sizeof</span>(Task_LED1ControlBlock),</span><br><span class="line">  .stack_mem = &amp;Task_LED1Buffer[<span class="number">0</span>],</span><br><span class="line">  .stack_size = <span class="keyword">sizeof</span>(Task_LED1Buffer),</span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN FunctionPrototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END FunctionPrototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* (MISRA C 2004 rule 8.1) */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  FreeRTOS initialization</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 创建任务Task_LED0 */</span></span><br><span class="line">  Task_LED0Handle = osThreadNew(AppTask_LED0, <span class="literal">NULL</span>, &amp;Task_LED0_attributes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务ask_LED1 */</span></span><br><span class="line">  Task_LED1Handle = osThreadNew(AppTask_LED1, <span class="literal">NULL</span>, &amp;Task_LED1_attributes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    osDelay(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    osDelay(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-3-编写用户功能代码"><a href="#4-4-3-编写用户功能代码" class="headerlink" title="4.4.3 编写用户功能代码"></a>4.4.3 编写用户功能代码</h4><p> 下面开始为两个任务函数编写代码，并且对任务的属性稍微做些修改，这样可以观察带时间片的抢占式任务调度方法的特点，以及<code>vTaskDelay()</code>和<code>vTaskDelayUntil()</code>等函数的使用方法。</p>
<ol>
<li><strong>相同优先级的任务的执行</strong></li>
</ol>
<p>在CubeMX的项目设置中，<strong>FreeRTOS使用默认的带时间片的抢占式任务调度方法</strong>，并且将两个任务的优先级都设置为<code>osPriorityNormal</code>，在文件<code>freertos.c</code>中，我们为两个任务的任务函数编写代码，使两个LED分别以不同的周期闪烁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_LED0 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin);</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END Header_AppTask_LED1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_LED1 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个任务函数的功能很简单，就是分别使LED0和LED1以不同的周期闪烁。注意，任务的延时函数使用<code>HAL_Delay()</code>而不是<code>osDelay()</code>，这样任务就不会进入阻塞状态，而是一直处于连续运行状态。</p>
<p>编译项目后，下载到战舰开发板运行，发现LED0和LED1都能闪烁，两个任务都可以执行。程序中两个任务与空闲任务的运行时序图如下所示：</p>
<p><img src="/img/loading.gif" data-original="两个相同优先级的连续任务运行任务时序.png" alt="两个相同优先级的连续任务运行任务时序"></p>
<p><strong>带时间片的抢占式任务调度器会在基础是中每次中断时，进行一次任务调度申请，在没有其他中断处理时，就会进行任务调度</strong>。</p>
<p>两个任务具有相同的优先级，所以调度器使两个任务轮流占用CPU。<strong>两个任务都是连续运行的，所以每个任务每次占用CPU的时间都是一个滴答信号周期，不占用CPU时，就处于就绪状态</strong>。系统中还有一个空闲任务，但是因为用户的两个任务时连续执行的，且优先级高于空闲任务，所以空闲任务总是无法获得CPU的使用权，总是处于就绪状态。</p>
<ol>
<li><strong>低优先级任务被饿死的情况</strong></li>
</ol>
<p>修改<code>Task_LED1</code>任务优先级为<code>osPriorityBelowNormal</code>，<code>Task_LED0</code>仍然为<code>osPriorityNormal</code>，编译后，烧录到战舰开发板发现，只有LED0闪烁，LED1不闪烁。</p>
<p>这个程序中3个任务的运行时序图如下：</p>
<p><img src="/img/loading.gif" data-original="两个连续执行的任务，高优先级任务总是占用CPU.png" alt="两个连续执行的任务，高优先级任务总是占用CPU"></p>
<p><code>Task_LED0</code>具有高优先级，而且是连续运行的，它会一直占用CPU，不会进入阻塞状态，所以低优先级的任务<code>Task_LED1</code>和空闲任务都无法使用CPU的使用权，只能一直处于就绪状态，它们被饿死了。</p>
<ol>
<li><strong>高优先级任务主动进入阻塞状态</strong></li>
</ol>
<p>再在2的程序上稍作修改，保持<code>Task_LED1</code>的优先级为<code>osPriorityBelowNormal</code>，<code>Task_LED0</code>仍然为<code>osPriorityNormal</code>。但是在任务中，进行一些改动如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_LED0 */</span></span><br><span class="line">  TickType_t ticks1 = pdMS_TO_TICKS(<span class="number">1000</span>); <span class="comment">//时间(ms)转换为节拍数(Ticks)</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin);</span><br><span class="line">    vTaskDelay(ticks1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED0 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE BEGIN Header_AppTask_LED1 */</span></span><br><span class="line"><span class="comment">/* USER CODE END Header_AppTask_LED1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_LED1 */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对<code>Task_LED0</code>的任务函数代码进行了修改。<strong><code>pdMS_TO_TICKS()</code>宏函数的功能是将ms时间转换为基础时钟节拍数</strong>。将延时函数由<code>HAL_Delay()</code>替代为<strong><code>vTaskDelay()</code>，这个函数的作用不但包括延时，而且使当前任务进入阻塞状态，以便低优先级任务可以在任务调度时获得CPU的使用权。</strong></p>
<p>在这次改动中，并没有修改任务<code>Task_LED1</code>的任务函数代码，在for循环中，还是使用延时函数<code>HAL_Delay()</code>，所以任务<code>Task_LED1</code>还是连续运行的。</p>
<p>编译后，烧录到开发板运行，发现LED0和LED1都能闪烁，两个任务都能执行。以上程序中的3个任务运行时序如下所示：</p>
<p><img src="/img/loading.gif" data-original="任务Task_LED0周期性进入阻塞状态，Task_LED1连续运行.png" alt="任务Task_LED0周期性进入阻塞状态，Task_LED1连续运行"></p>
<ul>
<li>在for循环里，任务<code>Task_LED0</code>每次执行完功能代码后，就调用<code>vTaskDelay()</code>函数延时1000ms，并且进入阻塞状态，所以任务<code>Task_LED0</code>大部分时间处于阻塞状态。</li>
<li>虽然任务<code>Task_LED1</code>的优先级比任务<code>Task_LED0</code>的低，但是在任务<code>Task_LED0</code>处于阻塞状态时，任务<code>Task_LED1</code>可以会的CPU的使用权。此外，因为<code>Task_LED1</code>是连续运行的，所以它占用了CPU的大部分时间。</li>
<li>任务<code>Task_LED0</code>在延时结束后，因为其优先级高，可以重新抢占CPU的使用权。</li>
<li>因为任务<code>Task_LED1</code>是连续运行的，不会进入阻塞状态，空闲任务还是无法获得CPU的使用权。</li>
</ul>
<ol>
<li><strong>任务函数设计的一般原则</strong></li>
</ol>
<p><u>在使用抢占式任务调度方法时，一般要根据任务的重要性分配不同的优先级，然后在任务函数里，在任务函数里，在任务空闲时让出CPU的使用权，进入阻塞状态，以便系统进行任务调度，使其他就绪状态的任务能获得CPU的使用权。</u>任务进入阻塞状态主要 有两种方式：<strong>一种是调用延时函数，如<code>vTaskDelay()</code></strong>；<strong>另一种是在进程间通信时，请求信号量、队列等事件</strong>。</p>
<p>再在3的程序上稍作修改，保持<code>Task_LED1</code>的优先级为<code>osPriorityBelowNormal</code>，<code>Task_LED0</code>仍然为<code>osPriorityNormal</code>。但是在任务中，进行一些改动如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TickType_t ticks0 = pdMS_TO_TICKS(<span class="number">1000</span>); <span class="comment">//时间(ms)转换为节拍数(Ticks)</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin);</span><br><span class="line">    vTaskDelay(ticks0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TickType_t ticks1 = pdMS_TO_TICKS(<span class="number">500</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);</span><br><span class="line">    vTaskDelay(ticks1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，烧录到开发板，发现LED0和LED1都能闪烁，两个任务都可以执行。以上程序中的3个任务运行时序如下所示：</p>
<p><img src="/img/loading.gif" data-original="优化的任务运行模式.png" alt="优化的任务运行模式"></p>
<p>用户的两个任务<code>Task_LED0</code>和<code>Task_LED1</code>大部分时间处于阻塞状态，由系统的空闲任务获得CPU的使用权。这样可以降低CPU的负荷，使任务的调度更及时。<strong>一般的FreeRTOS嵌入式系统种，CPU的大部分时间就是处于空闲任务占据</strong>，如果将参数<code>configUSE_TICKLESS_IDLE</code>配置为1，还可以实现系统的低功耗。</p>
<ol>
<li><strong>使用<code>vTaskDelayUntil()</code>函数</strong></li>
</ol>
<p>在前文我们介绍过了<code>vTaskDelayUntil()</code>和<code>vTaskDelay()</code>的区别，如果要在任务函数的循环中实现严格的周期性，就应该使用<code>vTaskDelayUntil()</code>。我们对4中的程序稍作修改，在两个任务函数中使用<code>vTaskDelayUntil()</code>。修改后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TickType_t ticks0 = pdMS_TO_TICKS(<span class="number">1000</span>); <span class="comment">//时间(ms)转换为节拍数(Ticks)</span></span><br><span class="line">  TickType_t previousWakeTime = xTaskGetTickCount();</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin);</span><br><span class="line">    vTaskDelayUntil(&amp;previousWakeTime, ticks0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TickType_t ticks1 = pdMS_TO_TICKS(<span class="number">500</span>);</span><br><span class="line">  TickType_t previousWakeTime = xTaskGetTickCount();</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);</span><br><span class="line">    vTaskDelayUntil(&amp;previousWakeTime, ticks1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数<code>vTaskDelayUntil()</code>延时的时间是从任务上次转入运行时间开始的绝对时间，例如，在任务<code>Task_LED0</code>中执行的延时语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vTaskDelayUntil(&amp;previousWakeTime, ticks0);</span><br></pre></td></tr></table></figure>
<p>第一次执行时，需要通过函数<code>xTaskGetTickCount()</code>获取滴答信号的当前计数值，作为<code>previousWakeTime</code>的初始值。<strong>执行上面的语句，表示从<code>previousWakeTime</code>值开始延时<code>ticks0</code>个节拍，函数内会自动更新变量<code>previousWakeTime</code>的值，也会自动处理滴答信号计数值溢出的情况。</strong></p>
<p>编译后，烧录到开发板，发现LED0和LED1都能闪烁，两个任务都可以执行。以上程序中的3个任务运行时序如下所示：</p>
<p><img src="/img/loading.gif" data-original="优化的任务运行模式.png" alt="优化的任务运行模式"></p>
<h3 id="4-5-任务管理工具函数"><a href="#4-5-任务管理工具函数" class="headerlink" title="4.5 任务管理工具函数"></a>4.5 任务管理工具函数</h3><h4 id="2-5-1-相关函数概述"><a href="#2-5-1-相关函数概述" class="headerlink" title="2.5.1 相关函数概述"></a>2.5.1 相关函数概述</h4><p>FreeRTOS中还有一些API函数，用于操作任务或者获取任务信息，这些函数及其基本功能如下：</p>
<p><img src="/img/loading.gif" data-original="任务管理工具函数.png" alt="任务管理工具函数"></p>
<h4 id="2-5-2-获取任务句柄"><a href="#2-5-2-获取任务句柄" class="headerlink" title="2.5.2 获取任务句柄"></a>2.5.2 获取任务句柄</h4><p><strong>在单个任务进行操作的函数，一般需要一个<code>TaskHandle_t</code>类型的表示任务句柄的变量作为参数</strong>。在使用函数<code>osThreadNew()</code>创建任务时，会返回一个<code>osThreadId_t</code>类型的变量作为任务句柄。这两个类型的定义其实是一样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *osThreadId_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *TaskHandle_t;</span><br></pre></td></tr></table></figure>
<p>所以用<code>osThreadNew()</code>创建任务获得的任务句柄变量，可以作为FreeRTOS任务操作函数的任务句柄输入参数。</p>
<p>FreeRTOS中还有3个用于获取任务句柄的函数。</p>
<ul>
<li>函数<code>xTaskGetCurrentTaskHandle()</code>，用于获取当前任务的句柄，其原型定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskGetCurrentTaskHandle</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>要使用这个函数，需要将参数<code>INCLUDE_xTaskGetCurrentTaskHandle</code>设置为1（默认为0），可以在CubeMX里设置。</strong></p>
<ul>
<li>函数<code>xTaskGetIdleTaskHandle()</code>，用于获得空闲任务的句柄，其原型定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskGetIdleTaskHandle</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>要使用这个函数，需要将参数<code>INCLUDE_xTaskGetIdleTaskHandle</code>设置为1（默认为0）。这个参数在CubeMX里面设置，需要用户在<code>FreeRTOSConfig.h</code>文件中自己添加宏定义，添加到文件<code>FreeRTOSConfig.h</code>的用户定义代码沙箱段，示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数<code>xTaskGetHandle()</code>，用于通过任务名称获得任务句柄，其原型定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskGetHandle</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *pcNameToQuery )</span>;</span><br></pre></td></tr></table></figure>
<p>其中，参数<code>pcNameToQuery</code>是任务名称字符串，这个函数运行时间相对较长，不宜大量使用。<strong>如果两个任务具有相同的任务名称，则函数返回的结果是不确定的</strong>。函数使用示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *taskName = <span class="string">&quot;Task_LED0&quot;</span>;</span><br><span class="line">TaskHandle_t taskHandle = xTaskGetHandle(taskName);</span><br></pre></td></tr></table></figure>
<p>要使用这个函数，需要将参数<code>INCLUDE_xTaskGetHandle</code>设置为1（默认值为0），可以在CubeMX里设置。</p>
<h4 id="4-5-3-单个任务的操作"><a href="#4-5-3-单个任务的操作" class="headerlink" title="4.5.3 单个任务的操作"></a>4.5.3 单个任务的操作</h4><ol>
<li><strong>获取和设置任务的优先级</strong></li>
</ol>
<p>程序在运行时，可以获取或改变一个任务的优先级，相关的3个函数的原型定义如下。<strong>要使用这3个函数，需要将参数<code>INCLUDE_uxTaskPriorityGet</code>或<code>INCLUDE_vTaskPrioritySet</code>设置为1（默认值都是1），可以在CubeMX中设置。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">(TaskHandle_t xTask)</span>;<span class="comment">//返回一个任务的优先级</span></span><br><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGetFromISR</span><span class="params">(TaskHandle_t xTask)</span>;<span class="comment">//函数的ISR版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskPrioritySet</span><span class="params">(TaskHandle_t xTask, UBaseType_t uxNewPriority)</span>;<span class="comment">//设置优先级</span></span><br></pre></td></tr></table></figure>
<p>在这3个函数中，优先级用<code>UBaseType_t</code>类型的数表示，在文件<code>cmsis_os2.h</code>中，定义了优先级的枚举类型<code>osPriority_t</code>，其部分定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  osPriorityNone          =  <span class="number">0</span>,         <span class="comment">///&lt; No priority (not initialized).</span></span><br><span class="line">  osPriorityIdle          =  <span class="number">1</span>,         <span class="comment">///&lt; Reserved for Idle thread.</span></span><br><span class="line">  osPriorityLow           =  <span class="number">8</span>,         <span class="comment">///&lt; Priority: low</span></span><br><span class="line">  osPriorityLow1          =  <span class="number">8</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: low + 1</span></span><br><span class="line">  osPriorityLow2          =  <span class="number">8</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: low + 2</span></span><br><span class="line">  osPriorityLow3          =  <span class="number">8</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: low + 3</span></span><br><span class="line">  osPriorityLow4          =  <span class="number">8</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: low + 4</span></span><br><span class="line">  osPriorityLow5          =  <span class="number">8</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: low + 5</span></span><br><span class="line">  osPriorityLow6          =  <span class="number">8</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: low + 6</span></span><br><span class="line">  osPriorityLow7          =  <span class="number">8</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: low + 7</span></span><br><span class="line">  osPriorityBelowNormal   = <span class="number">16</span>,         <span class="comment">///&lt; Priority: below normal</span></span><br><span class="line">  osPriorityBelowNormal1  = <span class="number">16</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: below normal + 1</span></span><br><span class="line">  osPriorityBelowNormal2  = <span class="number">16</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: below normal + 2</span></span><br><span class="line">  osPriorityBelowNormal3  = <span class="number">16</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: below normal + 3</span></span><br><span class="line">  osPriorityBelowNormal4  = <span class="number">16</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: below normal + 4</span></span><br><span class="line">  osPriorityBelowNormal5  = <span class="number">16</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: below normal + 5</span></span><br><span class="line">  osPriorityBelowNormal6  = <span class="number">16</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: below normal + 6</span></span><br><span class="line">  osPriorityBelowNormal7  = <span class="number">16</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: below normal + 7</span></span><br><span class="line">  osPriorityNormal        = <span class="number">24</span>,         <span class="comment">///&lt; Priority: normal</span></span><br><span class="line">  osPriorityNormal1       = <span class="number">24</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: normal + 1</span></span><br><span class="line">  osPriorityNormal2       = <span class="number">24</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: normal + 2</span></span><br><span class="line">  osPriorityNormal3       = <span class="number">24</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: normal + 3</span></span><br><span class="line">  osPriorityNormal4       = <span class="number">24</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: normal + 4</span></span><br><span class="line">  osPriorityNormal5       = <span class="number">24</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: normal + 5</span></span><br><span class="line">  osPriorityNormal6       = <span class="number">24</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: normal + 6</span></span><br><span class="line">  osPriorityNormal7       = <span class="number">24</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: normal + 7</span></span><br><span class="line">  osPriorityAboveNormal   = <span class="number">32</span>,         <span class="comment">///&lt; Priority: above normal</span></span><br><span class="line">  osPriorityAboveNormal1  = <span class="number">32</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: above normal + 1</span></span><br><span class="line">  osPriorityAboveNormal2  = <span class="number">32</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: above normal + 2</span></span><br><span class="line">  osPriorityAboveNormal3  = <span class="number">32</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: above normal + 3</span></span><br><span class="line">  osPriorityAboveNormal4  = <span class="number">32</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: above normal + 4</span></span><br><span class="line">  osPriorityAboveNormal5  = <span class="number">32</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: above normal + 5</span></span><br><span class="line">  osPriorityAboveNormal6  = <span class="number">32</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: above normal + 6</span></span><br><span class="line">  osPriorityAboveNormal7  = <span class="number">32</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: above normal + 7</span></span><br><span class="line">  osPriorityHigh          = <span class="number">40</span>,         <span class="comment">///&lt; Priority: high</span></span><br><span class="line">  osPriorityHigh1         = <span class="number">40</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: high + 1</span></span><br><span class="line">  osPriorityHigh2         = <span class="number">40</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: high + 2</span></span><br><span class="line">  osPriorityHigh3         = <span class="number">40</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: high + 3</span></span><br><span class="line">  osPriorityHigh4         = <span class="number">40</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: high + 4</span></span><br><span class="line">  osPriorityHigh5         = <span class="number">40</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: high + 5</span></span><br><span class="line">  osPriorityHigh6         = <span class="number">40</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: high + 6</span></span><br><span class="line">  osPriorityHigh7         = <span class="number">40</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: high + 7</span></span><br><span class="line">  osPriorityRealtime      = <span class="number">48</span>,         <span class="comment">///&lt; Priority: realtime</span></span><br><span class="line">  osPriorityRealtime1     = <span class="number">48</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: realtime + 1</span></span><br><span class="line">  osPriorityRealtime2     = <span class="number">48</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: realtime + 2</span></span><br><span class="line">  osPriorityRealtime3     = <span class="number">48</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: realtime + 3</span></span><br><span class="line">  osPriorityRealtime4     = <span class="number">48</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: realtime + 4</span></span><br><span class="line">  osPriorityRealtime5     = <span class="number">48</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: realtime + 5</span></span><br><span class="line">  osPriorityRealtime6     = <span class="number">48</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: realtime + 6</span></span><br><span class="line">  osPriorityRealtime7     = <span class="number">48</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: realtime + 7</span></span><br><span class="line">  osPriorityISR           = <span class="number">56</span>,         <span class="comment">///&lt; Reserved for ISR deferred thread.</span></span><br><span class="line">  osPriorityError         = <span class="number">-1</span>,         <span class="comment">///&lt; 系统无法确定或者非法的优先级</span></span><br><span class="line">  osPriorityReserved      = <span class="number">0x7FFFFFFF</span>  <span class="comment">///&lt; Prevents enum down-size compiler optimization.</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>用户可以在函数<code>vTaskPrioritySet()</code>中使用枚举类型，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t taskHandle = xTaskGetCurrentTaskHandle();<span class="comment">//获取当前任务的句柄</span></span><br><span class="line">vTaskPrioritySet(taskHandle, (UBaseType_t)osPriorityAboveNormal);<span class="comment">//设置优先级</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>函数<code>vTaskGetInfo()</code></strong></li>
</ol>
<p><code>vTaskGetInfo()</code>用于获取一个任务的信息，要使用这个函数，必须将参数<code>configUSE_TRACE_FACILITY</code>设置为1(默认值为1)，可在CubeMX里设置。这个函数的原型定义如下，各参数的意义见注释：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskGetInfo</span><span class="params">(TaskHandle_t xTask,<span class="comment">//任务的句柄</span></span></span><br><span class="line"><span class="params">                  TaskStatus_t *pxTaskStatus, <span class="comment">//用于存储任务状态信息的结构体指针</span></span></span><br><span class="line"><span class="params">                  BaseType_t xGetFreeStackSpace, <span class="comment">//是否返回栈空间高水位值</span></span></span><br><span class="line"><span class="params">                  eTaskState eState)</span>;<span class="comment">//指定任务的状态</span></span><br></pre></td></tr></table></figure>
<p>其中，参数<code>pxTaskStatus</code>是用于存储任务状态信息的TaskStatus_t结构体指针，这个结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xTASK_STATUS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TaskHandle_t xHandle;<span class="comment">//任务的句柄</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *pcTaskName;<span class="comment">//任务的名称</span></span><br><span class="line">	UBaseType_t xTaskNumber;<span class="comment">//任务的唯一编号	</span></span><br><span class="line">	eTaskState eCurrentState;<span class="comment">//任务的状态</span></span><br><span class="line">	UBaseType_t uxCurrentPriority;<span class="comment">//任务的优先级</span></span><br><span class="line"><span class="comment">/* 在使用互斥量时，为避免优先级反转而继承的优先级，参数configUSE_MUTEXES设置为1时此变量才有意义 */</span></span><br><span class="line">	UBaseType_t uxBasePriority;</span><br><span class="line"><span class="comment">/* 任务的总运行时间，configGENERATE_RUN_TIME_STATS设置为1时此变量才有意义 */</span></span><br><span class="line">	<span class="type">uint32_t</span> ulRunTimeCounter;		</span><br><span class="line">	StackType_t *pxStackBase;<span class="comment">//指向栈空间的低地址	</span></span><br><span class="line">	<span class="type">uint16_t</span> usStackHighWaterMark;<span class="comment">//栈空间的高水位值，单位是字</span></span><br><span class="line">&#125; TaskStatus_t;</span><br></pre></td></tr></table></figure>
<p>其中，参数<code>eCurrentState</code>任务的状态是枚举类型，表示了任务的运行、就绪、阻塞、挂起等状态。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	eRunning = <span class="number">0</span>, <span class="comment">//运行状态</span></span><br><span class="line">	eReady, <span class="comment">//就绪状态</span></span><br><span class="line">	eBlocked, <span class="comment">//阻塞状态</span></span><br><span class="line">	eSuspended, <span class="comment">//挂起状态，或无限等待时间的阻塞状态</span></span><br><span class="line">	eDeleted, <span class="comment">//任务被删除，但是其任务控制块(TCB)还没有被释放</span></span><br><span class="line">	eInvalid <span class="comment">//无效状态</span></span><br><span class="line">&#125; eTaskState;</span><br></pre></td></tr></table></figure>
<p>函数<code>vTaskGetInfo()</code>中的参数<strong><code>xGetFreeStackSpace</code>，表示是否在结构体<code>TaskStatus_t</code>中返回栈空间的高水位值<code>usStatusHighWaterMark</code>，如果<code>xGetFreeStatusSpace == pdTRUE</code>，就返回高水位值，因为返回任务的高水位值需要较长的时间，若<code>xGetFreeStackSpace == pdFALSE</code>，就可以忽略此过程。</strong></p>
<p><strong>函数<code>vTaskGetInfo()</code>中的参数<code>eState</code>用于指定查询信息时的任务状态</strong>，虽然结构体<code>TaskStatus_t</code>中由获取任务状态的成员变量，到那时不如直接赋值快。<strong>如果需要函数<code>vTaskGetInfo()</code>自动获取任务的状态，将参数<code>eState</code>设置为枚举值<code>eInvalid</code>即可。</strong></p>
<ol>
<li><strong>函数<code>pcTaskGetName()</code></strong></li>
</ol>
<p>函数<code>pcTaskGetName()</code>用于返回一个任务的任务名称字符串，其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">pcTaskGetName</span><span class="params">(TaskHandle_t xTaskToQuery)</span> ;</span><br></pre></td></tr></table></figure>
<p>如果要查询任务自己的任务名称，将参数<code>xTaskToQuery</code>设置为<code>NULL</code>即可。</p>
<ol>
<li><strong>函数<code>uxTaskGetStackHighWaterMark()</code></strong></li>
</ol>
<p>函数<code>uxTaskGetStackHighWaterMark()</code>用于获取一个任务的高水位值，其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetStackHighWaterMark</span><span class="params">(TaskHandle_t xTask)</span>;</span><br></pre></td></tr></table></figure>
<p>如果要查询任务自己的高水位值，将参数<code>xTask</code>设置为<code>NULL</code>即可。</p>
<p>若要使用这个函数，需要将参数<code>INCLUDE_eTaskGetState</code>或<code>configUSE_TRACE_FACILITY</code>设置为1，这两个参数默认值都是1，且都可以在CubeMX里设置。</p>
<h4 id="4-5-4-内核信息统计"><a href="#4-5-4-内核信息统计" class="headerlink" title="4.5.4 内核信息统计"></a>4.5.4 内核信息统计</h4><ol>
<li><strong>函数<code>uxTaskGetNumberOfTasks()</code></strong></li>
</ol>
<p>函数<code>uxTaskGetNumberOfTasks()</code>返回内核当前管理的任务的总数，包括就绪的、阻塞的、挂起的任务，<strong>也包括虽然删除了但还没有在空闲任务里释放的任务</strong>。其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetNumberOfTasks</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>函数<code>vTaskList()</code></strong></li>
</ol>
<p>函数<code>vTaskList()</code>返回内核中所有任务的字符串列表信息，包括每个任务的名称、状态、优先级、高水位值、任务编号等。其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskList</span><span class="params">(<span class="type">char</span> * pcWriteBuffer)</span></span><br></pre></td></tr></table></figure>
<p>参数<code>pcWriteBuffer</code>是预先创建的一个字符数组的指针，用于储存返回的字符串信息。这个字符串数组必须足够大，FreeRTOS不会检查这个数组的大小。这个函数使用的示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> infoBuffer[<span class="number">3000</span>];</span><br><span class="line">vTaskList(infoBuffer);</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>函数<code>uxTaskGetSystemState()</code></strong></li>
</ol>
<p>要使用这个函数，需要将参数<code>configUSE_TRACE_FACILITY</code>配置为1（默认值为1），可以在CubeMX里配置这个参数。</p>
<p>这个函数用于获得系统内所有任务的状态，为每个任务返回一个<code>TaskStatus_t</code>结构体数据，此结构体在函数<code>vTaskGetInfo()</code>部分介绍过。函数<code>uxTaskGetSystemState()</code>的原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetSystemState</span><span class="params">(TaskStatus_t * <span class="type">const</span> pxTaskStatusArray, <span class="type">const</span> UBaseType_t uxArraySize, <span class="type">uint32_t</span> * <span class="type">const</span> pulTotalRunTime)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数<code>pxTaskStatusArray</code>是一个数组的指针，成员是结构体类型<code>TaskStatus_t</code>。需预先分配数组大小，必须大于或等于FreeRTOS内的任务数。返回的数据就储存在这个数组里，每个任务对应一个数组成员。</li>
<li>参数<code>uxArraySize</code>是数据<code>pxTaskStatusArray</code>的大小，表示数组<code>pxTaskStatusArray</code>的成员个数。</li>
<li>参数<code>pulTotalRunTime</code>用于返回FreeRTOS启动后总的运行时间，如果设置为<code>NULL</code>，则不返回这个数据。只有参数<code>configGENERATE_RUN_TIME_STATS</code>设置为1，才会返回这个数据，默认值为0，可在CubeMX里设置。</li>
</ul>
<p>函数的返回值是<code>uxTaskGetSystemState()</code>实际获取的任务信息的条数，也就是FreeRTOS中实际任务的个数，与函数<code>uxTaskGetNumberOfTasks()</code>返回的任务个数相同。</p>
<ol>
<li><strong>函数<code>vTaskGetRunTimeState()</code></strong></li>
</ol>
<p>要使用这个函数，必须将以下两个参数都设置为1。</p>
<ul>
<li><code>configGENERATE_RUN_TIME_STATS</code>，默认值为0，可在CubeMX里设置。</li>
<li><code>configUSE_STATS_FORMATTING_FUNCTIONS</code>，默认值为0，可在CubeMX里设置。</li>
</ul>
<p>函数<code>vTaskGetRunTimeState()</code>用于统计系统内每个任务的运行时间，包括绝对时间和占用CPU的百分比。其原型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskGetRunTimeState</span><span class="params">(<span class="type">char</span> *pcWriteBuffer)</span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>pcWriteBuffer</code>用于存储返回数据的字符数组，返回的数据以文字表格形式表示，与函数<code>vTaskList()</code>返回结果的方式类似。</p>
<p><strong>注意，函数<code>vTaskGetRunTimeStats()</code>运行时，会禁止所有中断，所以，不要在程序正常运行的时候使用这个函数，应该只在程序调试阶段使用。</strong></p>
<ol>
<li><strong>函数<code>xTaskGetSchedulerState()</code></strong></li>
</ol>
<p>这个函数返回调度器的状态，当以下两个参数中的某一个设置为1时，此函数就可用。</p>
<ul>
<li><code>INCLUDE_xTasskGetSchedulerState</code>，默认值为1，可在CubeMX设置</li>
<li><code>configUSE_TIMERS</code>，默认值为1，<strong>CubeMX里有这个参数，但不允许修改</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskGetSchedulerState</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值用如下的3个宏定义常数表示任务调度器的状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 ) <span class="comment">//被挂起</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 ) <span class="comment">//未启动</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 ) <span class="comment">//正常运行</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-多任务编程示例（二）"><a href="#4-6-多任务编程示例（二）" class="headerlink" title="4.6 多任务编程示例（二）"></a>4.6 多任务编程示例（二）</h3><h4 id="4-6-1-示例功能与CubeMX项目设置"><a href="#4-6-1-示例功能与CubeMX项目设置" class="headerlink" title="4.6.1 示例功能与CubeMX项目设置"></a>4.6.1 示例功能与CubeMX项目设置</h4><p>创建工程<code>FreeRTOS_TwoTaskInfo</code>，在FreeRTOS中创建2个任务，任务<code>Task_ADC</code>通过ADC1采集电压值，在LCD上显示；任务<code>Task_Info</code>用于测试任务信息统计的一些工具函数，统计信息在LCD上显示。</p>
<ol>
<li><strong>ADC的设置</strong></li>
</ol>
<p>这次工程中，使用ADC1的通道1进行ADC电压采集，ADC1的模式设置如下所示：</p>
<p><img src="/img/loading.gif" data-original="ADC1的参数设置结果.png" alt="ADC1的参数设置结果"></p>
<p>主要设置为独立模式、12为精度、数据右对齐、软件触发常规转换，无需开启ADC1的硬件中断。</p>
<ol>
<li><strong>FreeRTOS的设置</strong></li>
</ol>
<p>启用FreeRTOS，使用CMSIS_V2接口。<code>Config parameters</code>和<code>Include parameters</code>两个设置页面的参数都保持默认值。我们在FreeRTOS中创建2个任务，设置任务的参数，如下图所示：</p>
<p><img src="/img/loading.gif" data-original="两个任务的主要参数.png" alt="两个任务的主要参数"></p>
<p><strong>两个任务的优先级不同，所以我们将栈空间大小都修改为256，并设置它们都使用动态分配内存方式。</strong></p>
<p><em>上图中两个任务的栈空间大小并不是随意给出的，是在程序运行过程中，通过统计栈空间的高水位值，给出的一个比较安全合理的值，给出的一个比较安全合理的值。栈空间大小，会导致栈空间溢出，程序无法正常运行，栈空间太大，会浪费内存。要设置合理的栈空间大小，最好在调试阶段统计一下任务的高水位值。</em></p>
<h4 id="4-6-2-程序功能实现"><a href="#4-6-2-程序功能实现" class="headerlink" title="4.6.2 程序功能实现"></a>4.6.2 程序功能实现</h4><ol>
<li><strong>主程序</strong></li>
</ol>
<p>完成设置后，CubeMX自动生成代码。其中主程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fsmc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_FSMC_Init();</span><br><span class="line">  MX_ADC1_Init();</span><br><span class="line">    </span><br><span class="line">  lcd_init();</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task Utilities&quot;</span>, RED);</span><br><span class="line">    </span><br><span class="line">  osKernelInitialize(); </span><br><span class="line">  MX_FREERTOS_Init();</span><br><span class="line">  osKernelStart();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在初始化部分，上述程序执行以下3个外设初始化函数。</p>
<ul>
<li><code>MX_GPIO_Init()</code>用于GPIO初始化，主要是两个LED的GPIO引脚的初始化。</li>
<li><code>MX_FSMC_Init()</code>用于FSMC连接TFT LCD接口的初始化。</li>
<li><code>MX_ADC1_Init()</code>用于ADC1的初始化。</li>
</ul>
<p>添加的两行用户代码，用于调用函数LCD的初始化函数，然后在LCD上显示项目文字信息。</p>
<ol>
<li><strong>FreeRTOS对象初始化</strong></li>
</ol>
<p>CubeMX自动生成的文件<code>freertos.c</code>包含两个任务的相关定义、FreeRTOS对象初始化函数<code>MX_FREERTOS_Init()</code>，以及两个任务函数的框架。对象初始化函数<code>MX_FREERTOS_Init()</code>相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Definitions for defaultTask */</span></span><br><span class="line">osThreadId_t defaultTaskHandle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t defaultTask_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;defaultTask&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Definitions for Task_ADC */</span></span><br><span class="line">osThreadId_t Task_ADCHandle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t Task_ADC_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;Task_ADC&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">256</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Definitions for Task_Info */</span></span><br><span class="line">osThreadId_t Task_InfoHandle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t Task_Info_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;Task_Info&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">256</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityLow,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartDefaultTask</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_ADC</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_Info</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* (MISRA C 2004 rule 8.1) */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    defaultTaskHandle = osThreadNew(StartDefaultTask, <span class="literal">NULL</span>, &amp;defaultTask_attributes);</span><br><span class="line">    Task_ADCHandle = osThreadNew(AppTask_ADC, <span class="literal">NULL</span>, &amp;Task_ADC_attributes);</span><br><span class="line">    Task_InfoHandle = osThreadNew(AppTask_Info, <span class="literal">NULL</span>, &amp;Task_Info_attributes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个任务的优先级不同，栈空间大小是256字，比默认的128字大。注意，<strong>在CubeMX中设置的参数<code>configMINIMAL_STACK_SIZE</code>，是系统自动创建的空闲任务的栈空间大小，其默认值是128字</strong>。</p>
<ol>
<li><strong>任务Task_ADC的功能实现</strong></li>
</ol>
<p>在任务<code>Task_ADC</code>里，我们对ADC1的IN1通道用轮询方式进行数据采集，并使用<code>vTaskDleayUntil()</code>函数实现比较精确的周期性采集。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_ADC</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_ADC */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> adcVal = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> adcVal_True = <span class="number">0</span>;</span><br><span class="line">  lcd_show_string(<span class="number">0</span>, <span class="number">70</span>, <span class="number">500</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;=====================!&lt; Get ADC Value &gt;!=====================&quot;</span>, GREEN);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">90</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task_ADC: ADC by polling&quot;</span>, RED);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">110</span> ,<span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;ADC Value(mV) = &quot;</span>, RED);</span><br><span class="line">  TickType_t previousWakeTime = xTaskGetTickCount();</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">    <span class="keyword">if</span> (HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">100</span>) == HAL_OK) <span class="comment">//轮询方式等待转换完成</span></span><br><span class="line">    &#123;</span><br><span class="line">      adcVal = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">      adcVal_True = (<span class="number">3300</span> * adcVal) &gt;&gt; <span class="number">12</span>;</span><br><span class="line">      lcd_show_xnum(<span class="number">150</span>, <span class="number">110</span>, adcVal_True, <span class="number">5</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);</span><br><span class="line">    vTaskDelayUntil(&amp;previousWakeTime, pdMS_TO_TICKS(<span class="number">500</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对ADC以轮询方式进行数据采集的方式是：以<code>HAL_ADC_Start()</code>函数启动转换，然后调用函数<code>HAL_ADC_PollForConversion()</code>以轮询方式等待转换结束，并设置最多等待100ms。转换完成后，调用函数<code>HAL_ADC_GetValue()</code>读取ADC转换原始数值，ADC转换结果是12位有效右对齐数据，然后再转换成毫伏电压值显示。</p>
<ol>
<li><strong>任务<code>Task_Info</code>的功能实现</strong></li>
</ol>
<p>任务Task_Info主要用来测试一些任务管理函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_Info</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_Info */</span></span><br><span class="line"><span class="comment">/*!&lt; ========获取单个任务的信息======== */</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetCurrentTaskHandle(); //获取当前任务句柄</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetIdleTaskHandle(); //获取空闲任务句柄</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetHandle(&quot;Task_ADC&quot;); //通过任务名称获取任务</span></span><br><span class="line">  TaskHandle_t taskHandle = Task_ADCHandle; <span class="comment">//直接使用任务名称获取任务句柄</span></span><br><span class="line">  </span><br><span class="line">  TaskStatus_t taskInfo; <span class="comment">//任务信息结构信息</span></span><br><span class="line">  BaseType_t getFreeStackSpace = pdTRUE; <span class="comment">//是否获取高水位值</span></span><br><span class="line">  eTaskState taskState = eInvalid; <span class="comment">//当前任务状态</span></span><br><span class="line">  vTaskGetInfo(taskHandle, &amp;taskInfo, getFreeStackSpace, taskState); <span class="comment">//获取任务信息</span></span><br><span class="line">  </span><br><span class="line">  taskENTER_CRITICAL(); <span class="comment">/* 临启临界代码段，不允许任务调度 */</span></span><br><span class="line">  lcd_show_string(<span class="number">0</span>, <span class="number">130</span>, <span class="number">500</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;===================!&lt; Get ADC Task Info &gt;!==================&quot;</span>, GREEN);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Get by vTaskGetInfo() &quot;</span>, RED);</span><br><span class="line">  </span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">170</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task Name = &quot;</span>, RED);</span><br><span class="line">  lcd_show_string(<span class="number">130</span>, <span class="number">170</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, (<span class="type">char</span> *)taskInfo.pcTaskName, BLUE);</span><br><span class="line">  </span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">190</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task Number = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">140</span>, <span class="number">190</span>, taskInfo.xTaskNumber, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line">  </span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">210</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task State = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">135</span>, <span class="number">210</span>, taskInfo.eCurrentState, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">230</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task Priority = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">155</span>, <span class="number">230</span>, taskInfo.uxCurrentPriority, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">250</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Stack High Water Mark = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">220</span>, <span class="number">250</span>, taskInfo.usStackHighWaterMark,<span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!&lt; 用函数uxTaskGetStackHighWaterMark()单独获取每个任务的高水位值 */</span></span><br><span class="line">  lcd_show_string(<span class="number">0</span>, <span class="number">270</span>, <span class="number">500</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;============!&lt; Get every task High Water Value &gt;!============&quot;</span>, GREEN);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">290</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;High Water Mark Of tasks&quot;</span>, RED);</span><br><span class="line"></span><br><span class="line">  taskHandle = xTaskGetIdleTaskHandle();</span><br><span class="line">  UBaseType_t highWaterMakr = uxTaskGetStackHighWaterMark(taskHandle);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">310</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Idle Task = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">125</span>, <span class="number">310</span>, highWaterMakr, <span class="number">3</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  taskHandle = Task_ADCHandle; <span class="comment">//Task_ADC任务句柄</span></span><br><span class="line">  highWaterMakr = uxTaskGetStackHighWaterMark(taskHandle);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">330</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task_ADC Task = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">155</span>, <span class="number">330</span>, highWaterMakr, <span class="number">3</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  taskHandle = Task_InfoHandle; <span class="comment">//Task_ADC任务句柄</span></span><br><span class="line">  highWaterMakr = uxTaskGetStackHighWaterMark(taskHandle);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">350</span>, <span class="number">250</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task_Info Task = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">165</span>, <span class="number">350</span>, highWaterMakr, <span class="number">3</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!&lt; 获取内存的信息 */</span></span><br><span class="line">  lcd_show_string(<span class="number">0</span>, <span class="number">370</span>, <span class="number">500</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;====================!&lt; Get Kernel Info &gt;!====================&quot;</span>, GREEN);</span><br><span class="line">  UBaseType_t taskNum = uxTaskGetNumberOfTasks(); <span class="comment">//获取任务个数</span></span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">390</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;uxTaskGetNumberOfTask = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">220</span>, <span class="number">390</span>, taskNum, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  taskEXIT_CRITICAL(); <span class="comment">//结束临界代码段，重新允许任务调度</span></span><br><span class="line">  UBaseType_t loopCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    loopCount++;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">    vTaskDelay(pdMS_TO_TICKS(<span class="number">300</span>));</span><br><span class="line">    <span class="keyword">if</span> (loopCount == <span class="number">10</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">410</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task_Info is deleted&quot;</span>, RED);</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_Info */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段函数主要实现了以下几个功能。</p>
<p>(1) 使用函数<code>vTaskGetInfo()</code>获取一个任务的信息。首先要获取任务的句柄，程序用了多种方法获取任务句柄，即程序中的如下几行语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetCurrentTaskHandle(); //获取当前任务句柄</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetIdleTaskHandle(); //获取空闲任务句柄</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetHandle(&quot;Task_ADC&quot;); //通过任务名称获取任务</span></span><br><span class="line">  TaskHandle_t taskHandle = Task_ADCHandle; <span class="comment">//直接使用任务名称获取任务句柄</span></span><br></pre></td></tr></table></figure>
<p>只需要使用其中的一条语句获取任务句柄，其他语句需注释掉。<strong>另外，使用函数<code>xTaskGetIdleTaskHandle()</code>时，可能会出现编译错误，显示这个函数未定义</strong>。这是因为在源程序<code>tasks.c</code>中，这个函数有个预编译条件，只有当参数<code>INCLUDE_xTaskGetIdleTaskHandle</code>值为1时，才编译这个函数。而在文件<code>FreeTROS.h</code>中，这个参数的默认值为0，我们需要将这个参数的值修改为1。注意，<strong>不能在文件<code>FreeRTOS.h</code>中直接修改这个参数的值，而要在文件<code>FreeRTOSConfig.h</code>的用户代码沙箱段内，重新定义这个宏</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Defines */</span></span><br><span class="line"><span class="comment">/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle 1</span></span><br><span class="line"><span class="comment">/* USER CODE END Defines */</span></span><br></pre></td></tr></table></figure>
<p>这段沙箱段在文件<code>FreeRTOSConfig.h</code>中的最下方，就是用于重新定义一些无法在CubeMX中可视化设置的参数，用于替换其在文件<code>FreeRTOS.h</code>中的默认定义。</p>
<p><em>使用FreeRTOS时，如果编译时遇到函数未定义的错误，要注意查看其源代码里有没有预编译条件。有的函数在头文件里有定义，但是源程序里不一定编译，例如函数<code>vTaskGetIdleTaskHandle()</code></em></p>
<p>调用函数<code>vTaskGetInfo()</code>语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vTaskGetInfo(taskHandle, &amp;taskInfo, getFreeStackSpace, taskState); </span><br></pre></td></tr></table></figure>
<p>函数返回的任务信息存储在结构体变量<code>taskInfo</code>里。参数<code>getFreeStackSpace</code>确定是否获取任务栈空间的高水位值。若参数<code>taskState</code>指定为某种状态，就返回任务在这种状态下的参数，若<code>taskState</code>为<code>eInvaild</code>，就返回任务实际所处状态的信息。</p>
<p><code>vTaskGetInfo()</code>获取的任务信息包括任务编号、名称、优先级等，还有栈空间的高水位值。<strong>高水位值表示任务栈空间的最小可用剩余空间，这个字越小，就说明任务栈空间越容易溢出</strong>。</p>
<p>(2) 使用函数<code>uxTaskGetStackHighWaterMark()</code>获取一个任务的高水位值（单位：字），程序使用该函数分别获取了空闲任务，Task_ADC、Task_Info这三个任务的高水位值并加以显示。</p>
<p>(3) 获取内核其他信息。函数<code>uxTaskGetNumberOfTasks()</code>可获取FreeRTOS中当前管理的任务数。</p>
<p>(4) 定义关键代码段。程序使用函数<code>taskENTER_CRITICAL()</code>和<code>taskEXIT_CRITICAL()</code>定义了临界代码段。<strong>在开始LCD显示之前，使用了函数<code>taskENTER_CRITICAL()</code>定义临界代码段的开始，这样会暂停任务调度，使后面的代码段在执行时不会被其他任务打断</strong>；在进入for循环之前，使用函数<code>taskEXIT_CRITICAL()</code>定义临界代码段的结束，恢复任务调度。</p>
<p>(5) 删除任务。<strong>任务函数的主题一般是一个无限循环，在任务函数中不允许出现return语句，如果跳出了无限循环，需要在任务函数返回之前执行<code>vTaskDelete(NULL)</code>删除任务自己。</strong></p>
<h2 id="5-FreeRTOS的中断管理"><a href="#5-FreeRTOS的中断管理" class="headerlink" title="5 FreeRTOS的中断管理"></a>5 FreeRTOS的中断管理</h2><p>FreeRTOS任务有优先级，MCU的硬件中断有中断优先级，这是两个不同的概念。FreeRTOS的任务管理要用到硬件中断，使用FreeRTOS时也可以使用硬件中断，但是硬件中断ISR的设计要注意一些设计原则。</p>
<h3 id="5-1-FreeRTOS与中断"><a href="#5-1-FreeRTOS与中断" class="headerlink" title="5.1 FreeRTOS与中断"></a>5.1 FreeRTOS与中断</h3><p>中断是MCU的硬件特性，STM32 MCU的NVIC管理硬件中断。而FreeRTOS的运行要用到中断，比如FreeRTOS的上下文切换就是在PendSV中断里进行的，FreeRTOS还需要一个基础时钟产生滴答信号。在CubeMX中启用FreeRTOS后，系统会自动对NVIC做一些设置，以《多任务编程示例（二）》中的<code>FreeRTOS_TwoTaskInfo</code>工程为例，其NVIC设置如下图所示：</p>
<p><img src="/img/loading.gif" data-original="FreeRTOS_TwoTaskInfo的NVIC设置.png" alt="FreeRTOS_TwoTaskInfo的NVIC设置"></p>
<p><strong>启用FreeRTOS后，中断优先级分组策略自动设置为4位全部用于抢占优先级</strong>，所以抢占优先级编号是0到15。这个设置对应于文件<code>FreeRTOSConfig.h</code>中的参数<code>configPRIO_BITS</code>，默认定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configPRIO_BITS         4</span></span><br></pre></td></tr></table></figure>
<p>这个参数在CubeMX中不能修改，固定为4，也就是分组策略使用4位抢占优先级。</p>
<p>在CubeMX中设置FreeRTOS的<code>config</code>参数时，有2个与中断相关的参数设置，如下图所示：</p>
<p><img src="/img/loading.gif" data-original="FreeRTOS中与中断相关的两个参数.png" alt="FreeRTOS中与中断相关的两个参数"></p>
<ul>
<li><code>LIBRARY_LOWEST_INTERRUPT_PRIORITY</code>，<strong>表示中断的最低优先级数值。因为中断分组策略是4位全用于抢占优先级，所以这个数值为15</strong>。  </li>
<li><code>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>，<strong>表示FreeRTOS可管理的最高优先级，默认值为5</strong>。也就是说，<strong>只有在中断优先级数值大于或等于5的中断ISR里，才可以调用FreeRTOS的中断安全API函数</strong>，也就是带<code>FromISR</code>后缀的函数，使用<code>taskDISABLE_INTERRUPTS()</code>函数也只能屏蔽优先级数值大于或等于5的中断。</li>
</ul>
<p><strong><u>参数<code>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>绝对不允许设置为0！绝对不要在高于此优先级的中断ISR里调用FreeRTOS的API函数，即使是带<code>FromISR</code>的中断安全函数也不可以！</u></strong></p>
<p>在NVIC配置中，最右边一列<code>User FreeRTOS functions</code>，<strong>表示是否要在中断的ISR里使用FreeRTOS的API函数</strong>。如果勾选了此列的复选框，那么这个中断的优先级数值就不能小于5。<strong>这个复选框并不会对生成的代码产生任何影响，只是改变了某个中断的抢占优先级可设置范围</strong>。</p>
<p>根据<code>LIBRARY_LOWEST_INTERRUPT_PRIORITY</code>和<code>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>两个参数以及参数<code>configPRIO_BITS</code>的设置，<strong>文件<code>FreeRTOSConfig.h</code>还定义了一个参数<code>configKERNEL_INTERRUPT_PRIORITY</code>，用于写入寄存器的表示最低优先级的数值</strong>，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configKERNEL_INTERRUPT_PRIORITY 		</span></span><br><span class="line">	  ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (<span class="number">8</span> - configPRIO_BITS) )</span><br></pre></td></tr></table></figure>
<p>经过这样计算之后，<code>configKERNEL_INTERRUPT_PRIORITY</code>的值是0xF0。</p>
<p><strong>参数<code>configKERNEL_INTERRUPT_PRIORITY</code>用于定义PendSV和SysTick的中断优先级</strong>，在文件port.c中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portNVIC_PENDSV_PRI   </span></span><br><span class="line">			(((<span class="type">uint32_t</span>) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; <span class="number">16UL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portNVIC_SYSTICK_PRI				</span></span><br><span class="line">			(((<span class="type">uint32_t</span>) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; <span class="number">24UL</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><code>portNVIC_PENDSV_PRI</code>和<code>portNVIC_SYSTICK_PRI</code>是用于写入寄存器的值，其数值与中断优先级的表示有关</strong>。</p>
<p><strong>PendSV（Pendable request for system service，可挂起的系统服务请求）中断用于上下文切换，也即是在这个中断ISR里决定哪个任务占用CPU</strong>。PendSV中断的抢占优先级为15，也就是最低优先级。所以，只有在没有其他中断ISR运行的情况下，FreeRTOS才会执行上下文切换。</p>
<p><strong>SysTick的中断优先级为15，是最低的。系统在SysTick中断里发出任务调度请求，所以，只有在没有其他中断IST运行的情况下，任务调度请求才会被及时响应</strong>。根据NVIC管理中断的特点，同等抢占优先级的中断是不能发生抢占的，所以，即使有一个抢占优先级为15中断在ISR运行，SysTick和PendSV的中断就无法被及时响应，也就是不会发生任务调度，任务函数也不会被执行。</p>
<p><img src="/img/loading.gif" data-original="FreeRTOS中各个优先级中断的作用和分类.png" alt="FreeRTOS中各个优先级中断的作用和分类"></p>
<p>在《多任务编程示例（二）》中的<code>FreeRTOS_TwoTaskInfo</code>工程中，指定了定时器TIM6作为HAL基础时钟源。根据上图可以看出，TIM6中断的抢占优先级为0，也就是最高优先级，所以FreeRTOS无法屏蔽HAL的基础时钟中断。</p>
<h3 id="5-2-任务与中断服务例程"><a href="#5-2-任务与中断服务例程" class="headerlink" title="5.2 任务与中断服务例程"></a>5.2 任务与中断服务例程</h3><h4 id="5-2-1-任务与中断服务函数例程的关系"><a href="#5-2-1-任务与中断服务函数例程的关系" class="headerlink" title="5.2.1 任务与中断服务函数例程的关系"></a>5.2.1 任务与中断服务函数例程的关系</h4><p>MCU的中断有中断优先级，有中断服务例程(ISR)；FreeRTOS的任务有任务优先级，有任务函数。这两者的特点和区别具体如下。</p>
<ul>
<li><strong>中断是MCU的硬件特性，由硬件事件或软件信号引起中断，运行哪个ISR是由硬件决定的</strong>。中断的优先级数值越小，表示优先级越高，所以中断的最高优先级为0。</li>
<li><strong>FreeRTOS的任务是一个纯软件的概念，与硬件系统无关</strong>。任务的优先级是开发者在软件中赋予的，任务的优先级数字越低，表示优先级越低，所以任务的最低优先级为0。FreeRTOS的任务调度器决定哪个任务处于运行状态，FreeRTOS在中断优先级为15的PendSV中断里进行上下文切换，所以，<strong>只要有中断ISR在运行，FreeRTOS就无法进行任务切换</strong>。</li>
<li><strong>任务只有在没有ISR运行的时间才能运行，即使优先级最低的中断，也可以抢占高优先级的任务的执行，而任务不能抢占ISR的运行</strong>。</li>
</ul>
<p>注意对最后一条规则的理解。<strong>根据NVIC管理中断的原则，同等抢占优先级的中断是不能发生抢占的</strong>。<strong>一个优先级为15的RTC唤醒中断是不能抢占优先级为15的SysTick和PendSV中断的执行的</strong>，这是因为SysTick和PendSV中断的ISR运行时间很短，RTC唤醒中断的ISR能被及时执行。但是如果优先级为15的RTC唤醒中断的ISR执行时间很长，那么SysTick和PendSV发生了中断也无法发生抢占，也就是无法进行任务调度，任务函数也无法运行。</p>
<p>任务函数与中断的ISR运行时的关系可以如下图所示：</p>
<p><img src="/img/loading.gif" data-original="任务函数与中断的ISR运行时的关系.png" alt="任务函数与中断的ISR运行时的关系"></p>
<ul>
<li>在t1时刻，User Task进入运行状态，占用CPU；在t2时刻，发生了一个中断ISR1，不管User Task的任务优先级有多高，ISR1都会抢占CPU。ISR1执行完成后，User Task才可以继续执行。</li>
<li>在t6时刻，发生了中断2，ISR2抢占了CPU。但是ISR2CPU的时间比较长，导致User Task执行时长变长，从软件运行响应来说，表现就是软件响应变迟钝了。</li>
</ul>
<p><strong>从上图可以看出，ISR执行时，就无法执行任务函数。所以，如果一个ISR执行的时间比较长，任务函数无法及时执行，FreeRTOS也无法进行任务调度，就会导致软件响应变迟钝</strong>。</p>
<p><strong>在实际的软件设计中，一般要尽量简化ISR的功能，使其尽量少占用CPU的时间</strong>。一般的硬件中断都是处理一些数据的接收或者发送工作的，例如，<u>常用中断方式进行ADC数据采集时，只需在ADC的中断里将数据读取到缓冲区，而对数据进行滤波、频谱计算等耗时的工作就需要转移到任务函数里处理</u>。</p>
<h4 id="5-2-2-中断屏蔽和临界代码段"><a href="#5-2-2-中断屏蔽和临界代码段" class="headerlink" title="5.2.2 中断屏蔽和临界代码段"></a>5.2.2 中断屏蔽和临界代码段</h4><p>一个任务函数在执行的时候，可能会被其他高优先级的任务抢占CPU，也可能被任何一个中断的ISR抢占CPU。在某些时候，任务的某段代码可能很关键，需要连续执行完，不希望被其他任务或者中断打断，这种程序称为<strong>临界段(critical section)</strong>。<strong>在FreeRTOS中，有函数定义临界代码段，也可以屏蔽系统的部分中断</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS() <span class="comment">//屏蔽MCU部分中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()  <span class="comment">//解除中断屏蔽</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL()		portENTER_CRITICAL()     <span class="comment">//开始临界代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL()			    portEXIT_CRITICAL()  <span class="comment">//结束临界代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )</span></span><br></pre></td></tr></table></figure>
<ul>
<li>宏函数<code>taskDISABLE_INTERRUPTS()</code>用于屏蔽MCU中的一些中断，可屏蔽的中断就是之前说的FreeRTOS可屏蔽的中断。注意，在FreeRTOS里，屏蔽中断并不是屏蔽MCU的所有中断，例如，优先级为0的TIM6的中断就是不可屏蔽的。</li>
<li>宏函数<code>taskENABLE_INTERRUPTS()</code>用于杰出中断屏蔽。</li>
<li>函数<code>taskENTER_CRITICAL()</code>和<code>taskEXIT_CRITICAL()</code>用于界定一个临界代码段，在临界代码段内，FreeRTOS会暂停任务调度，所以正在执行的任务不会被更高优先级的任务抢占，能保证代码执行的连续性。</li>
<li><code>taskENTER_CRITICAL_FROM_ISR()</code> 、<code>taskEXIT_CRITICAL_FROM_ISR( x )</code>分别是<code>taskENTER_CRITICAL()</code>、<code>taskEXIT_CRITICAL()</code>的ISR版本，用于在ISR中调用。</li>
</ul>
<p>定义临界代码段和屏蔽中断在功能上几乎是相同的，因为函数<code>taskENTER_CRITICAL()</code>里调用了<code>taskDISABLE_INTERRUPTS()</code>，<code>taskEXIT_CRITICAL()</code>里调用了<code>taskENABLE_INTERRUPTS()</code>。实际临界代码段的两个函数的底层代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortEnterCritical</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	portDISABLE_INTERRUPTS();</span><br><span class="line">	uxCriticalNesting++;</span><br><span class="line">	<span class="keyword">if</span>( uxCriticalNesting == <span class="number">1</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		configASSERT( ( portNVIC_INT_CTRL_REG &amp; portVECTACTIVE_MASK ) == <span class="number">0</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortExitCritical</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	configASSERT( uxCriticalNesting );</span><br><span class="line">	uxCriticalNesting--;</span><br><span class="line">	<span class="keyword">if</span>( uxCriticalNesting == <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		portENABLE_INTERRUPTS();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，<strong>函数<code>taskENTER_CRITICAL()</code>和函数<code>taskEXIT_CRITICAL()</code>使用了嵌套计数器，所以这一对函数可以嵌套使用。函数<code>taskDISABLE_INTERRUPTS()</code>和<code>taskENABLE_INTERRUPTS()</code>不能嵌套使用，只能成对使用。</strong></p>
<h4 id="5-2-3-在ISR中使用FreeRTOS-API函数"><a href="#5-2-3-在ISR中使用FreeRTOS-API函数" class="headerlink" title="5.2.3 在ISR中使用FreeRTOS API函数"></a>5.2.3 在ISR中使用FreeRTOS API函数</h4><p>在中断的ISR里，有时会需要调用FreeRTOS的API函数，但是调用普通的API函数可能会存在问题。例如，<strong>在ISR里调用<code>vTaskDelay()</code>就会出现问题，因为<code>vTaskDelay()</code>会使任务进入阻塞状态，而ISR根本不是任务，ISR运行的时候，也不能进行任务调度</strong>。</p>
<p>为此，FreeRTOS的API函数分为两个版本：一个称为”任务级“，即普通名称的API函数；另一个称为”中断级“，即带后缀<code>FromISR</code>函数或带后缀<code>FROM_ISR</code>的宏函数，<strong>中断级API函数也称为中断安全API函数</strong>。</p>
<p>例如，对应于<code>taskENTER_CRITICAL()</code>的中断级宏函数是<code>taskENTER_CRITICAL_FROM_ISR()</code>，对应于函数<code>xTaskGetTickCount()</code>的中断级函数是<code>xTaskGetTickCountFromISR()</code>。</p>
<p>FreeRTOS将API函数分为两个版本的好处是：在API的实现代码中，无须判断调用这个API函数的是一个ISR，还是一个任务函数，否则需要增加额外的代码，而且不同的MCU判断ISR和任务函数的机制可能不一样。所以，使用两个版本的API函数，使FreeRTOS的代码效率更高。</p>
<p><strong><u>在ISR中，绝对不能使用任务级API函数，但是在任务函数中，可以使用中断级API函数。此外，在FreeRTOS不能管理的高优先级中断的ISR里，连中断级API函数也不能调用。</u></strong></p>
<h4 id="5-2-4-中断及其ISR设计原则"><a href="#5-2-4-中断及其ISR设计原则" class="headerlink" title="5.2.4 中断及其ISR设计原则"></a>5.2.4 中断及其ISR设计原则</h4><p>根据FreeRTOS管理中断的特点，中断的优先级和ISR程序设计应该遵循如下原则。</p>
<ul>
<li>根据参数<code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>的设置，MCU的优先级为0到15的中断，分为FreeRTOS不可屏蔽中断和可屏蔽中断，要根据中断的重要性和功能，为其设置合适的中断优先级，使其成为FreeRTOS不可屏蔽中断或可屏蔽中断。</li>
<li><strong>ISR的代码应该尽量简短，应该将比较耗时的处理功能转移到任务函数里实现</strong>。</li>
<li>在可屏蔽中断的ISR里，能调用中断级的FreeRTOS API函数，绝对不能调用普通的FreeRTOS API函数里。<strong>在不可屏蔽中断的ISR里，不能调用任何的FreeRTOS API函数</strong>。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">林守拙</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/16/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2023/08/16/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">林守拙的个人空间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STM32/">STM32</a><a class="post-meta__tags" href="/tags/FreeRTOS/">FreeRTOS</a></div><div class="post_share"><div class="social-share" data-image="/img/bingbing2_corrosion_port.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="嵌入式软件开发基础知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">嵌入式软件开发基础知识</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/16/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/" title="电力电子技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">电力电子技术</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/31/I2C%E6%80%BB%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" title="I2C总线与通信协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-31</div><div class="title">I2C总线与通信协议</div></div></a></div><div><a href="/2023/07/21/modbus-blog/" title="modbus-blog"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">modbus-blog</div></div></a></div><div><a href="/2023/07/27/%E5%8F%8C%E7%8E%AF%E6%8E%A7%E5%88%B6PID%E7%AE%97%E6%B3%95/" title="双环控制PID算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-27</div><div class="title">双环控制PID算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/bingbing2_corrosion_port.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">林守拙</div><div class="author-info__description">抱朴守拙，行稳致远</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KeyL-SJ"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/KeyL-SJ" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">FreeRTOS学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">1、简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%BB%E5%8A%A1"><span class="toc-text">1.1 任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-text">1.2 任务状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">1.3 任务优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE"><span class="toc-text">1.4 内核配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81CubeMX%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0LED%E7%81%AF%E7%BF%BB%E8%BD%AC"><span class="toc-text">2、CubeMX项目配置实现LED灯翻转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-text">2.1、程序分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.1.1. 主程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-FreeRTOS%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA"><span class="toc-text">2.1.2. FreeRTOS对象初始化函数和任务创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E7%BC%96%E5%86%99%E4%BB%BB%E5%8A%A1%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-text">2.1.3. 编写任务功能实现代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81FreeRTOS%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">3、FreeRTOS的文件组成和基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-FreeRTOS%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90"><span class="toc-text">3.1 FreeRTOS文件组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-FreeRTOS%E9%80%9A%E7%94%A8%E5%8A%9F%E8%83%BD%E6%96%87%E4%BB%B6"><span class="toc-text">3.1.1 FreeRTOS通用功能文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-FreeRTOS%E9%80%9A%E7%94%A8%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6"><span class="toc-text">3.1.2 FreeRTOS通用定义文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-CMSIS-RTOS%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3%E6%96%87%E4%BB%B6"><span class="toc-text">3.1.3 CMSIS-RTOS标准接口文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E7%A7%BB%E6%A4%8D%E6%96%87%E4%BB%B6"><span class="toc-text">3.1.4 硬件相关的移植文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-FreeRTOS%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99"><span class="toc-text">3.2 FreeRTOS的编码规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%8F%98%E9%87%8F%E5%90%8D"><span class="toc-text">3.2.1 变量名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%87%BD%E6%95%B0%E5%90%8D"><span class="toc-text">3.2.2 函数名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E5%AE%8F%E5%90%8D%E7%A7%B0"><span class="toc-text">3.2.3 宏名称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-FreeRTOS%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8A%9F%E8%83%BD%E8%A3%81%E5%89%AA"><span class="toc-text">3.3 FreeRTOS的配置和功能裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-config%E7%B1%BB%E7%9A%84%E5%AE%8F"><span class="toc-text">3.3.1 config类的宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-INCLUDE-%E7%B1%BB%E7%9A%84%E5%AE%8F"><span class="toc-text">3.3.2 INCLUDE_类的宏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">4、FreeRTOS的任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BB%BB%E5%8A%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-text">4.1 任务相关的一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="toc-text">4.1.1 多任务运行基本机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">4.1.2 任务的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">4.1.3 任务的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.1.4 空闲任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-%E5%9F%BA%E7%A1%80%E6%97%B6%E9%92%9F%E4%B8%8E%E6%BB%B4%E7%AD%94%E4%BF%A1%E5%8F%B7"><span class="toc-text">4.1.5 基础时钟与滴答信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-FreeRTOS%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-text">4.2 FreeRTOS任务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-text">4.2.1 任务调度方法概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">4.2.2 使用时间片的抢占式调度方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.3 不使用时间片的抢占式调度方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E5%90%88%E4%BD%9C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.4 合作式任务调度方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">4.3 任务管理相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0"><span class="toc-text">4.3.1 相关函数概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E"><span class="toc-text">4.3.2 主要函数功能说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-text">4.4 多任务编程示例（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E7%A4%BA%E4%BE%8B%E5%8A%9F%E8%83%BD%E4%B8%8ECubeMX%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE"><span class="toc-text">4.4.1 示例功能与CubeMX项目设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E5%88%9D%E5%A7%8B%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-text">4.4.2 初始程序分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E7%BC%96%E5%86%99%E7%94%A8%E6%88%B7%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81"><span class="toc-text">4.4.3 编写用户功能代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="toc-text">4.5 任务管理工具函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0"><span class="toc-text">2.5.1 相关函数概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E5%8F%A5%E6%9F%84"><span class="toc-text">2.5.2 获取任务句柄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-%E5%8D%95%E4%B8%AA%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">4.5.3 单个任务的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-4-%E5%86%85%E6%A0%B8%E4%BF%A1%E6%81%AF%E7%BB%9F%E8%AE%A1"><span class="toc-text">4.5.4 内核信息统计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-text">4.6 多任务编程示例（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-%E7%A4%BA%E4%BE%8B%E5%8A%9F%E8%83%BD%E4%B8%8ECubeMX%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE"><span class="toc-text">4.6.1 示例功能与CubeMX项目设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-2-%E7%A8%8B%E5%BA%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.6.2 程序功能实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-FreeRTOS%E7%9A%84%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-text">5 FreeRTOS的中断管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-FreeRTOS%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-text">5.1 FreeRTOS与中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BB%BB%E5%8A%A1%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B"><span class="toc-text">5.2 任务与中断服务例程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E4%BB%BB%E5%8A%A1%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">5.2.1 任务与中断服务函数例程的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E5%92%8C%E4%B8%B4%E7%95%8C%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-text">5.2.2 中断屏蔽和临界代码段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E5%9C%A8ISR%E4%B8%AD%E4%BD%BF%E7%94%A8FreeRTOS-API%E5%87%BD%E6%95%B0"><span class="toc-text">5.2.3 在ISR中使用FreeRTOS API函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-%E4%B8%AD%E6%96%AD%E5%8F%8A%E5%85%B6ISR%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">5.2.4 中断及其ISR设计原则</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="嵌入式软件开发基础知识">嵌入式软件开发基础知识</a><time datetime="2023-11-01T14:41:25.000Z" title="发表于 2023-11-01 22:41:25">2023-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/16/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="FreeRTOS学习笔记">FreeRTOS学习笔记</a><time datetime="2023-08-16T14:07:49.000Z" title="发表于 2023-08-16 22:07:49">2023-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/16/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/" title="电力电子技术">电力电子技术</a><time datetime="2023-08-16T14:07:49.000Z" title="发表于 2023-08-16 22:07:49">2023-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/31/I2C%E6%80%BB%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" title="I2C总线与通信协议">I2C总线与通信协议</a><time datetime="2023-07-31T14:27:51.000Z" title="发表于 2023-07-31 22:27:51">2023-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/27/%E5%8F%8C%E7%8E%AF%E6%8E%A7%E5%88%B6PID%E7%AE%97%E6%B3%95/" title="双环控制PID算法">双环控制PID算法</a><time datetime="2023-07-27T12:21:44.000Z" title="发表于 2023-07-27 20:21:44">2023-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 林守拙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>