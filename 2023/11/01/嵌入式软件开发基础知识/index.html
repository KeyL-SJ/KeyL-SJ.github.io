<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>嵌入式软件开发基础知识 | 林守拙的个人空间</title><meta name="author" content="林守拙"><meta name="copyright" content="林守拙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、C语言基础1、 基本语法1.1 while与do while的区别 while循环在执行循环体内容之前会进行条件判断，若条件满足，则才会不断执行循环体内的内容，直到条件不满足或者遇到break语句。  do while会先执行一次循环体的内容，之后再进行条件判断，若条件满足，则继续不断执行循环体内的内容。   1.2 数据基本类型 1. 整型整型分为整形常量和整形变量，常量就是我们平时所看到的">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式软件开发基础知识">
<meta property="og:url" content="http://example.com/2023/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="林守拙的个人空间">
<meta property="og:description" content="一、C语言基础1、 基本语法1.1 while与do while的区别 while循环在执行循环体内容之前会进行条件判断，若条件满足，则才会不断执行循环体内的内容，直到条件不满足或者遇到break语句。  do while会先执行一次循环体的内容，之后再进行条件判断，若条件满足，则继续不断执行循环体内的内容。   1.2 数据基本类型 1. 整型整型分为整形常量和整形变量，常量就是我们平时所看到的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bingbing2_corrosion_port.jpg">
<meta property="article:published_time" content="2023-11-01T14:41:25.000Z">
<meta property="article:modified_time" content="2023-11-27T14:57:46.308Z">
<meta property="article:author" content="林守拙">
<meta property="article:tag" content="软件开发">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/bingbing2_corrosion_port.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '嵌入式软件开发基础知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-27 22:57:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/bingbing2_corrosion_port.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/6.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="林守拙的个人空间"><span class="site-name">林守拙的个人空间</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">嵌入式软件开发基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-01T14:41:25.000Z" title="发表于 2023-11-01 22:41:25">2023-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-27T14:57:46.308Z" title="更新于 2023-11-27 22:57:46">2023-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="嵌入式软件开发基础知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、C语言基础"><a href="#一、C语言基础" class="headerlink" title="一、C语言基础"></a>一、C语言基础</h1><h2 id="1、-基本语法"><a href="#1、-基本语法" class="headerlink" title="1、 基本语法"></a>1、 基本语法</h2><h3 id="1-1-while与do-while的区别"><a href="#1-1-while与do-while的区别" class="headerlink" title="1.1 while与do while的区别"></a>1.1 while与do while的区别</h3><ul>
<li><p>while循环在执行循环体内容之前会进行条件判断，若条件满足，则才会不断执行循环体内的内容，直到条件不满足或者遇到break语句。</p>
</li>
<li><p>do while会先执行一次循环体的内容，之后再进行条件判断，若条件满足，则继续不断执行循环体内的内容。</p>
</li>
</ul>
<h3 id="1-2-数据基本类型"><a href="#1-2-数据基本类型" class="headerlink" title="1.2 数据基本类型"></a>1.2 数据基本类型</h3><p><img src="/img/loading.gif" data-original="C数据类型.png" alt="C数据类型"></p>
<h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h4><p>整型分为<strong>整形常量</strong>和整形变量，常量就是我们平时所看到的准确的数字，例如：1、20、333等等，变量则按我的理解是我向内存去申请一个存储空间，告诉内存空间我申请了这个地方用来存放一个整形的数据，但是什么时候放并没有直接确定。一般占4个字节（32位），最高位代表符号，0表示正数，1表示负数，取值是-2147483648~2147483647（-2^31^ ~ 2^31^-1），<strong>在内存中的存储顺序是低位在前、高位在后</strong>，例如0x12345678。</p>
<ul>
<li><p><strong>短整型 short</strong>，内存中占2个字节(2 Bytes)，是short int 的简写。取值范围：-32768 ~ + 32767 (-2^15^ ~ 2^15^-1)。</p>
</li>
<li><p><strong>整型int</strong>，内存中占4个字节(4 Bytes)，是long int的简写。取值范围：-2147483648 ~ +2147483647(-2^31^ ~ 2^31^)。</p>
</li>
<li><p><strong>长整型long long</strong>，32位平台下long 是4个字节，long long 是8字节；但是64位平台下则全是8字节。<strong>因此为了保证平台的通用性，程序中尽量不要使用long数据类型。</strong></p>
</li>
</ul>
<h4 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a>2. 浮点型</h4><ul>
<li><strong>单精度float</strong>，系统的基本浮点类型，至少能精确表示小数点后6位有效数字。<strong>一个float类型占用4个字节的存储位</strong>，<u>其中最高位为符号位，紧接着8位为指数位，剩下的23位为尾数位</u>。</li>
<li><strong>双精度double</strong>，至少能精确表示小数点后12位有效数字。<strong>一个double类型占用8个字节的存储位</strong>，<u>其中最高位为符号位，紧接着8位为指数位，剩下的52位为尾数位</u>。</li>
</ul>
<h4 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3. 字符型"></a>3. 字符型</h4><p>字符型在其本质上就是整形，我们在C语言中使用char表示一个字符型，<strong>他占用一个字符的存储空间</strong>，字符型在存储时其内部存储的依旧是二进制数据。</p>
<h4 id="4-构造类型"><a href="#4-构造类型" class="headerlink" title="4. 构造类型"></a>4. 构造类型</h4><p><strong>4.1 数组</strong></p>
<hr>
<p>数组是按照顺序存储的一系列类型相同的值，如10个char类型的字符或15个int类型的值。整个数组有一个数组名，通过整数下标访问数组中单独的项或元素。</p>
<p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type arrayName[arraySize];</span><br></pre></td></tr></table></figure>
<p><strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double balance[10];</span><br></pre></td></tr></table></figure>
<p>现在 <em>balance</em> 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</p>
<p><strong>4.2 结构体</strong></p>
<hr>
<p>结构体是一种自定义的复合数据类型。例如存储学生信息就会用到此种数据类型。</p>
<p><strong>定义结构体</strong></p>
<p>结构体定义由关键字 <strong>struct</strong> 和结构体名组成，结构体名可以根据需要自行定义。</p>
<p>struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span></span><br><span class="line">  member-<span class="built_in">list</span></span><br><span class="line">  member-<span class="built_in">list</span></span><br><span class="line">  member-<span class="built_in">list</span>  </span><br><span class="line">  ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br></pre></td></tr></table></figure>
<p><strong>tag</strong> 是结构体标签。</p>
<p><strong>member-list</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong>，或者其他有效的变量定义。</p>
<p><strong>variable-list</strong> 结构变量，定义在结构的末尾，最后一个分号之前，可以指定一个或多个结构变量。下面是声明 Book 结构的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line">  <span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span>  book_id;</span><br><span class="line">&#125; book; </span><br></pre></td></tr></table></figure>
<p>在一般情况下，<strong>tag、member-list、variable-list</strong> 这 3 部分至少要出现 2 个。以下为实例：</p>
<p>此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，同时又声明了结构体变量s1，这个结构体并没有标明其标签。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125; s1;</span><br></pre></td></tr></table></figure>
<p>此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，结构体的标签被命名为SIMPLE,没有声明变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用SIMPLE标签的结构体，另外声明了变量t1、t2、t3。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">t1</span>, <span class="title">t2</span>[20], *<span class="title">t3</span>;</span></span><br></pre></td></tr></table></figure>
<p>也可以用typedef创建新类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125; Simple2;</span><br><span class="line"><span class="comment">//现在可以用Simple2作为类型声明新的结构体变量</span></span><br><span class="line">Simple2 u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure>
<p><strong>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针</strong>，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此结构体的声明包含了其他的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COMPLEX</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此结构体的声明包含了指向自己类型的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>    <span class="comment">//对结构体B进行不完整声明</span></span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.3 共用体</strong></p>
<hr>
<p>关键字：<code>union</code>，共用体也叫联合体，<strong>使几个不同类型的变量共占一段内存(相互覆盖)，也就是说共用体的成员共用一片内存</strong>，后赋值的成员变量的数据才是共用体的生效数据，因为前面的赋值已经被覆盖了。共用体所占内存至少能够容纳最大的成员变量所需的空间，应用场景，比如需要一种既可以存储<code>int</code>型数据也可以存储<code>double</code>型数据的变量。</p>
<p><strong>共用体</strong>是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。<strong>可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值</strong>。共用体提供了一种使用相同的内存位置的有效方式。</p>
<p><strong>定义共用体</strong></p>
<p>为了定义共用体，您必须使用 <strong><code>union</code></strong> 语句，方式与定义结构类似。<code>union</code> 语句定义了一个新的数据类型，带有多个成员。<code>union</code> 语句的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> [<span class="title">union</span> <span class="title">tag</span>] &#123;</span></span><br><span class="line">    member definition;   </span><br><span class="line">    member definition;   </span><br><span class="line">    ...   </span><br><span class="line">    member definition; </span><br><span class="line">&#125; [one or more <span class="class"><span class="keyword">union</span> <span class="title">variables</span>];</span></span><br></pre></td></tr></table></figure>
<p><strong>union tag</strong> 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span>   </span><br><span class="line">	<span class="type">int</span> i;   </span><br><span class="line">	<span class="type">float</span> f;   </span><br><span class="line">	<span class="type">char</span>  str[<span class="number">20</span>]; </span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>
<p>现在，<strong>Data</strong> 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</p>
<p><strong>共用体占用的内存应足够存储共用体中最大的成员</strong>。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的，所以该共用体占用的内存位20；</p>
<p><strong>4.4 枚举类型</strong></p>
<hr>
<p>枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读。<strong>枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性</strong>。</p>
<p>定义一个枚举类型，需要使用 <strong>enum</strong> 关键字，后面跟着枚举类型的名称，以及用大括号 <strong>{}</strong> 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 <strong>0</strong> 开始递增。</p>
<p>枚举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>
<p>比如：一星期有 7 天，使用枚举的方式定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span>&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<em>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</em></p>
<p>可以在定义枚举类型时改变枚举元素的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span>spring, summer=<span class="number">3</span>, autumn, winter&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</strong></p>
<p><strong>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的</strong>，所以按照 C 语言规范是没有办法遍历枚举类型的。<strong>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span>&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历枚举元素</span></span><br><span class="line">    <span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;枚举元素：%d \n&quot;</span>, day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">枚举元素：<span class="number">1</span> </span><br><span class="line">枚举元素：<span class="number">2</span> </span><br><span class="line">枚举元素：<span class="number">3</span> </span><br><span class="line">枚举元素：<span class="number">4</span> </span><br><span class="line">枚举元素：<span class="number">5</span> </span><br><span class="line">枚举元素：<span class="number">6</span> </span><br><span class="line">枚举元素：<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>以下枚举类型不连续，这种枚举无法遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    ENUM_0,</span><br><span class="line">    ENUM_10 = <span class="number">10</span>,</span><br><span class="line">    ENUM_11</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>将整数转换为枚举</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    saturday,</span><br><span class="line">    sunday,</span><br><span class="line">    monday,</span><br><span class="line">    tuesday,</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; workday;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">weekend</span>;</span></span><br><span class="line">   weekend = ( <span class="keyword">enum</span> day ) a;  <span class="comment">//类型转换</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-不同MCU下char-short-int-long类型长度"><a href="#1-3-不同MCU下char-short-int-long类型长度" class="headerlink" title="1.3 不同MCU下char,short,int,long类型长度"></a>1.3 不同MCU下char,short,int,long类型长度</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MCU位数</th>
<th>char</th>
<th>short</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
</tr>
</thead>
<tbody>
<tr>
<td>8位</td>
<td>1字节</td>
<td>2字节</td>
<td>2字节</td>
<td>4字节</td>
<td>4字节</td>
<td>4字节</td>
</tr>
<tr>
<td>16位</td>
<td>1字节</td>
<td>2字节</td>
<td>2字节</td>
<td>4字节</td>
<td>4字节</td>
<td>4字节</td>
</tr>
<tr>
<td>32位</td>
<td>1字节</td>
<td>2字节</td>
<td>4字节</td>
<td>4字节</td>
<td>4字节</td>
<td>8字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-4-define和typedef的区别"><a href="#1-4-define和typedef的区别" class="headerlink" title="1.4 define和typedef的区别"></a>1.4 define和typedef的区别</h3><p><strong>typedef和define都是替一个对象取一个别名，以此增强程序的可读性，区别如下：</strong></p>
<p><strong>（1）原理不同</strong></p>
<p><strong>#define是C语言中定义的语法，是预处理指令</strong>，在预处理时进行简单而机械的字符串替换，<strong>不作正确性检查</strong>，只有在编译已被展开的源程序时才会发现可能的错误并报错。</p>
<p><strong>typedef是关键字</strong>，<strong>在编译时处理，有类型检查功能</strong>。它在自己的作用域内给一个已经存在的类型一个别名，<strong>但不能在一个函数定义里面使用typedef</strong>。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。</p>
<p><strong>（2）功能不同</strong></p>
<p><strong>typedef用来定义类型的别名</strong>，起到类型易于记忆的功能。另一个功能是定义机器无关的类型。如定义一个REAL的浮点类型，在目标机器上它可以获得最高的精度：<code>typedef long double REAL</code>， 在不支持long double的机器上，看起来是这样的：<code>typedef double REAL</code>，在不支持double的机器上，是这样的：<code>typedef float REAL</code></p>
<p><strong>#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等</strong>。</p>
<p><strong>（3）作用域不同</strong></p>
<p><strong>#define没有作用域的限制</strong>，只要是之前预定义过的宏，在以后的程序中都可以使用，<strong>而typedef有自己的作用域</strong>。</p>
<p><strong>（4）对指针的操作不同</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR1 int*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* INTPTR2;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> INTPTR1 p1 = &amp;a;</span><br><span class="line"><span class="type">const</span> INTPTR2 p2 = &amp;b;</span><br><span class="line">INTPTR2 <span class="type">const</span> p3 = &amp;c;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>const INTPTR1 p1</code>是一个<strong>常量指针</strong>，<strong>即不可以通过p1去修改p1指向的内容，但是p1可以指向其他内容。</strong></p>
<p><code>const INTPTR2 p2</code>是一个<strong>指针常量</strong>，<strong>不可使p2再指向其他内容</strong>。因为INTPTR2表示一个指针类型，因此用const限定，表示封锁了这个指针类型。</p>
<h4 id="1-5-函数入口参数的判断"><a href="#1-5-函数入口参数的判断" class="headerlink" title="1.5 函数入口参数的判断"></a>1.5 函数入口参数的判断</h4><ul>
<li><strong>入口参数</strong>：参数的值由调用者指定，被调函数使用。</li>
<li><strong>出口参数</strong>：参数的值由被调函数指定，调用者使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="comment">// 出口参数 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_data</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">int</span> sex)</span> &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s\n&quot;</span>, name); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;年龄：%d\n&quot;</span>, age); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;性别：%s\n&quot;</span>, sex ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 入口参数 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_data</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> *age, <span class="type">int</span> *sex)</span> &#123; </span><br><span class="line">    <span class="comment">// 直接指定 // strcpy(name, &quot;张三&quot;); </span></span><br><span class="line">    <span class="comment">// *age = 18; </span></span><br><span class="line">    <span class="comment">// *sex = 1 </span></span><br><span class="line">    <span class="comment">// 通过输入指定 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入姓名：&quot;</span>); </span><br><span class="line">    gets(name); <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄：&quot;</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, age); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入性别(男1女0)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, sex); </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line">    <span class="type">char</span> name[<span class="number">1024</span>]; </span><br><span class="line">    <span class="type">int</span> age, sex; </span><br><span class="line">    <span class="comment">// 调用者现在不知道这三个参数的值， </span></span><br><span class="line">    <span class="comment">// 这三个参数的值由被调函数指定（由用户输入） </span></span><br><span class="line">    get_data(name, &amp;age, &amp;sex); </span><br><span class="line">    <span class="comment">// 调用者现在知道了这三个参数的值， </span></span><br><span class="line">    <span class="comment">// 并传给被调函数使用（显示出来） </span></span><br><span class="line">    print_data(name, age, sex); <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-数组越界的判断及处理"><a href="#1-6-数组越界的判断及处理" class="headerlink" title="1.6 数组越界的判断及处理"></a>1.6 数组越界的判断及处理</h4><p>在 C 语言中，数组必须是静态的。换而言之，数组的大小必须在程序运行前就确定下来。因此，数组下标的取值范围只能预先推断一个值来确定数组的维数，一般情况下，数组的越界错误主要包括两种：<strong>数组下标取值越界</strong>与<strong>指向数组的指针的指向范围越界</strong>。</p>
<p><strong>数组下标取值越界</strong></p>
<hr>
<p><strong>数组下标取值越界主要是指访问数组的时候，下标的取值不在已定义好的数组的取值范围内，而访问的是无法获取的内存地址</strong>。例如，对于数组 int a[3]，它的下标取值范围是 [0，2]（即 a[0]、a[1] 与 a[2]）。如果我们的取值不在这个范围内（如 a[3]），就会发生越界错误。示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d\n&quot;</span>,i,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，在上面的示例程序中，访问 a[3] 是非法的，将会发生越界错误。因此，我们应该将上面的代码修改成如下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d\n&quot;</span>,i,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指向数组的指针指向的地址越界</strong></p>
<hr>
<p>指向数组的指针指向的地址越界指的是在定义数组时会返回一个指向第一个变量的头指针，对这个指针进行加减运算可以移动该指针，进而访问数组中的所有变量，<strong>但是在移动指针时，若是不注意移动的次数和位置，就会使指针指向数组之外的位置，导致数组发生越界错误</strong>。示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="comment">/*数组a的头指针赋值给指针p*/</span></span><br><span class="line">p=a;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*指针p指向的变量*/</span></span><br><span class="line">    *p=i+<span class="number">10</span>;</span><br><span class="line">    <span class="comment">/*指针p下一个变量*/</span></span><br><span class="line">    p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，for 循环会使指针 p 向后移动 10 次，并且每次向指针指向的单元赋值。但是，这里数组 a 的下标取值范围是 [0，4]（即 a[0]、a[1]、a[2]、a[3] 与 a[4]）。因此，<strong>后 5 次的操作会对未知的内存区域赋值，而这种向内存未知区域赋值的操作会使系统发生错误</strong>。正确的操作应该是指针移动的次数与数组中的变量个数相同，如下面的代码所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="comment">/*数组a的头指针赋值给指针p*/</span></span><br><span class="line">p=a;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*指针p指向的变量*/</span></span><br><span class="line">    *p=i+<span class="number">10</span>;</span><br><span class="line">    <span class="comment">/*指针p下一个变量*/</span></span><br><span class="line">    p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C 语言中，为了提高运行效率，给程序员更大的空间，为指针操作带来更多的方便，<strong>C 语言内部本身不检查数组下标表达式的取值是否在合法范围内，也不检查指向数组元素的指针是不是移出了数组的合法区域</strong>。因此，在编程中使用数组时就必须格外谨慎，在对数组进行读写操作时都应当进行相应的检查，以免对数组的操作超过数组的边界，从而发生缓冲区溢出漏洞。</p>
<p><strong>(1) 尽量显式地指定数组的边界</strong></p>
<p>要避免程序因数组越界所发生的错误，首先就需要从数组的边界定义开始。尽量显式地指定数组的边界，即使它已经由初始化值列表隐式指定。示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>很显然，对于上面的数组 a[]，虽然编译器可以根据始化值列表来计算出数组的长度。但是，如果我们显式地指定该数组的长度，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>它不仅使程序具有更好的可读性，并且大多数编译器在数组长度小于初始化值列表的长度时还会发生相应警告。</p>
<p> 当然，<strong>也可以使用宏的形式来显式指定数组的边界</strong>（实际上，这也是最常用的指定方法），如下面的代码所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="type">int</span> a[MAX]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外，在 C99 标准中，还允许我们使用单个指示符为数组的两段“分配”空间，如下面的代码所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[MAX]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[MAX<span class="number">-5</span>]=<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的 a[MAX] 数组中，如果 MAX 大于 10，数组中间将用 0 值元素进行填充（填充的个数为 MAX-10，并从 a[5] 开始进行 0 值填充）；如果 MAX 小于 10，“[MAX-5]”之前的 5 个元素（1，2，3，4，5）中将有几个被“[MAX-5]”之后的 5 个元素（6，7，8，9，10）所覆盖，示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX1 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX2 6</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[MAX]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[MAX<span class="number">-5</span>]=<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[MAX1]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[MAX1<span class="number">-5</span>]=<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> c[MAX2]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[MAX2<span class="number">-5</span>]=<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[MAX]：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d &quot;</span>,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nb[MAX1]：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX1;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b[%d]=%d &quot;</span>,j,b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nc[MAX2]：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(z=<span class="number">0</span>;z&lt;MAX2;z++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c[%d]=%d &quot;</span>,z,c[z]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[MAX]：</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span> a[<span class="number">1</span>]=<span class="number">2</span> a[<span class="number">2</span>]=<span class="number">3</span> a[<span class="number">3</span>]=<span class="number">4</span> a[<span class="number">4</span>]=<span class="number">5</span> a[<span class="number">5</span>]=<span class="number">6</span> a[<span class="number">6</span>]=<span class="number">7</span> a[<span class="number">7</span>]=<span class="number">8</span> a[<span class="number">8</span>]=<span class="number">9</span> a[<span class="number">9</span>]=<span class="number">10</span></span><br><span class="line">b[MAX1]：</span><br><span class="line">b[<span class="number">0</span>]=<span class="number">1</span> b[<span class="number">1</span>]=<span class="number">2</span> b[<span class="number">2</span>]=<span class="number">3</span> b[<span class="number">3</span>]=<span class="number">4</span> b[<span class="number">4</span>]=<span class="number">5</span> b[<span class="number">5</span>]=<span class="number">0</span> b[<span class="number">6</span>]=<span class="number">0</span> b[<span class="number">7</span>]=<span class="number">0</span> b[<span class="number">8</span>]=<span class="number">0</span> b[<span class="number">9</span>]=<span class="number">0</span> b[<span class="number">10</span>]=<span class="number">6</span> b[<span class="number">11</span>]=<span class="number">7</span> b[<span class="number">12</span>]=<span class="number">8</span> b[<span class="number">13</span>]=<span class="number">9</span> b[<span class="number">14</span>]=<span class="number">10</span></span><br><span class="line">c[MAX2]：</span><br><span class="line">c[<span class="number">0</span>]=<span class="number">1</span> c[<span class="number">1</span>]=<span class="number">6</span> c[<span class="number">2</span>]=<span class="number">7</span> c[<span class="number">3</span>]=<span class="number">8</span> c[<span class="number">4</span>]=<span class="number">9</span> c[<span class="number">5</span>]=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 对数组做越界检查，确保索引值位于合法的范围之内</strong></p>
<p>要避免数组越界，除了上面所阐述的显式指定数组的边界之外，<strong>还可以在数组使用之前进行越界检查，检查数组的界限和字符串（也以数组的方式存放）的结束，以保证数组索引值位于合法的范围之内</strong>。例如，在写处理数组的函数时，一般应该有一个范围参数；在处理字符串时总检查是否遇到空字符‘\0’。</p>
<p>来看下面一段代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_NUM 10</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">TestArray</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*ARRAY_NUM);</span><br><span class="line">    <span class="keyword">if</span>(arr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        arr[num] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/*处理arr==NULL*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的“int*TestArray（int num，int value）”函数中不难看出，其中存在着一个很明显的问题，那就是无法保证 num 参数是否越界（即当 num&gt;=ARRAY_NUM 的情况）。因此，应该对 num 参数进行越界检查，示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">TestArray</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*越界检查(越上界)*/</span></span><br><span class="line">    <span class="keyword">if</span>(num&lt;ARRAY_NUM)&#123;</span><br><span class="line">        arr=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*ARRAY_NUM);</span><br><span class="line">        <span class="keyword">if</span>(arr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            arr[num]=value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*处理arr==NULL*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样通过“if（num&lt;ARRAY_NUM）”语句进行越界检查，从而保证 num 参数没有越过这个数组的上界。现在看起来，TestArray() 函数应该没什么问题，也不会发生什么越界错误。</p>
<p> 但是，如果仔细检查，TestArray() 函数仍然还存在一个致命的问题，<strong>那就是没有检查数组的下界</strong>。由于这里的 num 参数类型是 int 类型，因此可能为负数。<strong>如果 num 参数所传递的值为负数，将导致在 arr 所引用的内存边界之外进行写入</strong>。</p>
<p> 当然，可以通过向“if（num&lt;ARRAY_NUM）”语句里面再加一个条件进行测试，如下面的代码所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f(num &gt;= <span class="number">0</span> &amp;&amp; num &lt; ARRAY_NUM)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(3) 获取数组的长度时不要对指针应用 sizeof 操作符</strong></p>
<p><strong>sizeof 是一个单目操作符，不是函数</strong>。其作用就是返回一个操作数所占的内存字节数。其中，<strong>操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型来决定</strong>。例如，对于数组 int a[5]，可以使用“sizeof(a)”来获取数组的长度，使用“sizeof(a[0])”来获取数组元素的长度。</p>
<p>但需要注意的是，<strong>sizeof 操作符不能用于函数类型、不完全类型（指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void 类型等）与位字段</strong>。例如，以下都是不正确形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*若此时max定义为int max()；*/</span></span><br><span class="line"><span class="keyword">sizeof</span>(max)</span><br><span class="line"><span class="comment">/*若此时arr定义为char arr[MAX]，且MAX未知*/</span></span><br><span class="line"><span class="keyword">sizeof</span>(arr)</span><br><span class="line"><span class="comment">/*不能够用于void类型*/</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">void</span>)</span><br><span class="line"><span class="comment">/*不能够用于位字段*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f2 : <span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f3 : <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(S.f1);</span><br></pre></td></tr></table></figure>
<p>了解 sizeof 操作符之后，现在来看下面的示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> arr[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    Init(a);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从表面看，上面代码的输出结果应该是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>但实际结果却出乎我们的意料，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,-858993460,858993460,858993460,858993460,858993460,858993460,858993460,858993460</span><br></pre></td></tr></table></figure>
<p>是什么原因导致这个结果呢？</p>
<p> 很显然，上面的示例代码在“void Init(int arr[])”函数中接收了一个“int arr[]”类型的形参，并且在main函数中向它传递一个“a[10]”实参。同时，在 Init() 函数中通过“sizeof(arr)/sizeof(arr[0])”来确定这个数组元素的数量和初始化值。</p>
<p> 在这里出现了一个很大问题：<strong>由于 arr 参数是一个形参，它是一个指针类型，其结果是“sizeof(arr)=sizeof(int*)”</strong>。在 IA-32 中，“sizeof(arr)/sizeof(arr[0])”的结果为 1。因此，最后的结果出现异常</p>
<p>对于上面的示例代码，我们可以通过传入数组的长度的方式来解决这个问题，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">oid <span class="title function_">Init</span><span class="params">(<span class="type">int</span> arr[],<span class="type">size_t</span> arr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr_len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    Init(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还可以通过指针的方式来解决上面的问题，示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">10</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="keyword">sizeof</span>(*arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*arr)[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    Init(&amp;a);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，Init() 函数中的 arr 参数是一个指向“arr[10]”类型的指针。<strong>需要特别注意的是，这里绝对不能够使用“void Init(int(<em>arr)[])”来声明函数，而是必须指明要传入的数组的大小，否则“sizeof(</em>arr)”无法计算</strong>。但是在这种情况下，再通过 sizeof 来计算数组大小已经没有意义了，因为此时数组大小已经指定为 10 了。</p>
<h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2. 指针"></a>2. 指针</h2><p><strong>什么是指针？</strong></p>
<p>指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type *var_name;</span><br></pre></td></tr></table></figure>
<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C 数据类型，<strong>var_name</strong> 是指针变量的名称。用来声明指针的星号 <strong>*</strong> 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>
<p><strong>如何使用指针？</strong></p>
<p>使用指针时会频繁进行以下几个操作：</p>
<ul>
<li><strong>定义一个指针变量</strong></li>
<li><strong>把变量地址赋值给指针</strong></li>
<li><strong>访问指针变量中可用地址的值</strong></li>
</ul>
<p>这些是通过使用一元运算符 <strong>*</strong> 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="type">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line">    </span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var 变量的地址: %p\n&quot;</span>, &amp;var  );</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ip 变量存储的地址: %p\n&quot;</span>, ip );</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var 变量的地址: <span class="number">0x7ffeeef168d8</span></span><br><span class="line">ip 变量存储的地址: <span class="number">0x7ffeeef168d8</span></span><br><span class="line">*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><strong>C 中的 NULL 指针</strong></p>
<p>变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span>  *ptr = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ptr 的地址是 %p\n&quot;</span>, ptr  );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr 的地址是 <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p>
<p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr)     <span class="comment">/* 如果 p 非空，则完成 */</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)    <span class="comment">/* 如果 p 为空，则完成 */</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-函数指针"><a href="#2-1-函数指针" class="headerlink" title="2.1 函数指针"></a>2.1 函数指针</h3><p>所谓的函数指针即定义一个指向函数的指针变量，定义的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span> y));<span class="comment">//注意：这里的括号不能拿掉，因为括号()的运算优先级比*高</span></span><br></pre></td></tr></table></figure>
<p>这个函数的类型是有两个整型参数，返回值是个整型。对应的函数指针类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*)(<span class="type">int</span> a, <span class="type">int</span> b);</span><br></pre></td></tr></table></figure>
<p>对应的函数指针定义:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> a, <span class="type">int</span> b); <span class="comment">//参数名可以去掉，并且通常都是去掉的，这样指针p就可以保存函数类型为两个整型参数，返回值是整型的函数地址了</span></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>我们一般可以这么使用，通过函数指针调用函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a:b</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> ,<span class="type">int</span>) = <span class="literal">NULL</span>;</span><br><span class="line">p = maxValue;</span><br><span class="line">p(<span class="number">20</span>,<span class="number">45</span>);<span class="comment">//通过指针调用</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-指针函数"><a href="#2-2-指针函数" class="headerlink" title="2.2 指针函数"></a>2.2 指针函数</h3><p>指针函数：指的是函数的返回值是一个指针，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">p</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 注意这里的*和p之间是没有括号的，所以含义是函数p(int,int)会返回一个(int *)指针</span></span><br></pre></td></tr></table></figure>
<p>当然，函数本身也可能返回一个函数指针，后面会说到。</p>
<h3 id="2-3-常量指针"><a href="#2-3-常量指针" class="headerlink" title="2.3 常量指针"></a>2.3 常量指针</h3><p><strong>如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量</strong>，指向常量的指针变量称为常量指针，格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>在这个例子下定义以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a，b；</span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> *p=&amp;a <span class="comment">//常量指针</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作错误</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作成功</span></span><br></pre></td></tr></table></figure>
<p><strong>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，<u>指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变</u></strong>。</p>
<p>如上示例中定义了一个常量指针<code>*p</code>，并且初始化时指向变量<code>a</code>的地址，这时，变量<code>a</code>的值就不能通过指针<code>p</code>修改，所以<code>*p=9;</code>操作错误，但是我们可以让常量指针<code>p</code>指向其他变量地址，就像上面示例中的<code>p=&amp;b</code>，将指针<code>p</code>指向了变量<code>b</code>的地址。</p>
<h3 id="2-4-指针常量"><a href="#2-4-指针常量" class="headerlink" title="2.4 指针常量"></a>2.4 指针常量</h3><p>指针常量：顾名思义它就是一个常量，但是是<strong>指针修饰的</strong>。</p>
<p>格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p <span class="comment">//指针常量</span></span><br></pre></td></tr></table></figure>
<p>在这个例子下定义以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p=&amp;a <span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作成功</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作错误</span></span><br></pre></td></tr></table></figure>
<p>因为声明了指针常量，说明指针变量不允许修改。即<strong><u>指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改</u></strong>。</p>
<p>如上示例中，定义了一个指针常量<code>p</code>，并且指向了变量<code>a</code>的地址，这样指针常量指向的地址只能为<code>a</code>的地址，不能改变，但是可以通过指针常量<code>p</code>修改变量<code>a</code>地址内的值，所以<code>*p=9</code>操作成功，<code>p=&amp;b</code>操作错误。</p>
<p><strong>总结如下</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>定义形式</th>
<th>指针p的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>变量指针</td>
<td>指向变量的指针</td>
<td>int <em>p =&a;<br>int  (</em>p) = &a;</td>
<td>int *</td>
</tr>
<tr>
<td>常量指针</td>
<td>指向常量的指针</td>
<td>int const <em>p = &amp;a<br>const int </em>p = &amp;a</td>
<td>int const *</td>
</tr>
<tr>
<td>指针常量</td>
<td>用指针修饰的常量</td>
<td>int * const p</td>
<td>int * const</td>
</tr>
<tr>
<td>一维数组指针</td>
<td>指向一维数组的指针</td>
<td>int *p = a</td>
<td>int *</td>
</tr>
<tr>
<td>二维数组指针</td>
<td>指向二维数组(第一行整体是首元素的指针)</td>
<td>int (*p)[4] = a</td>
<td>int (*)[4]</td>
</tr>
<tr>
<td>函数指针</td>
<td>指向函数的指针</td>
<td>int (*p)(int a,int b) = add</td>
<td>int (*)(int,int)</td>
</tr>
<tr>
<td>指针函数</td>
<td>函数的返回值是一个指针类型</td>
<td>int *p(int a, int b){}</td>
<td>int *(int a, int b){}</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-基础知识"><a href="#3-基础知识" class="headerlink" title="3. 基础知识"></a>3. 基础知识</h2><h3 id="3-1-堆栈概念"><a href="#3-1-堆栈概念" class="headerlink" title="3.1 堆栈概念"></a>3.1 堆栈概念</h3><p><strong><u>堆栈（stack) 是一种先进后出的、操作受限的线性表，也可以直接称为 栈。</u></strong></p>
<p><strong>堆栈（英语：stack）</strong>，是计算机科学中一种特殊的<strong>串列形式的抽象数据类型</strong>，<strong>其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算</strong>。另外堆栈也可以用一维数组或链表的形式来完成。堆栈的另外一个相对的操作方式称为队列。需要记住的是，<strong>堆：顺序随意，栈：后进先出(Last-In/First-Out)</strong>。</p>
<p><strong>堆（英语：Heap）</strong>，是计算机科学中的一种特别的<strong>树状数据结构</strong>。通常是一个可以被看做一棵树的数组对象。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的父节点，那么 P 的值会小于等于（或大于等于） C 的值”。若父节点的值恒小于等于子节点的值，此堆称为最小堆（英语：min heap）；反之，若父节点的值恒大于等于子节点的值，此堆称为最大堆（英语：max heap）。在堆中最顶端的那一个节点，称作根节点（英语：root node），根节点本身没有父节点（英语：parent node）。</p>
<p><strong>栈（stack）又名堆栈</strong>，它是一种运算受限的线性表。其限制是<strong>仅允许在表的一端进行插入和删除运算。这一端被称为栈顶</strong>，相对地，把另一端称为栈底。<strong>栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来（先进后出）</strong>。</p>
<p><strong>其实堆栈本身就是栈</strong>，只是换了个抽象的名字。其特性是： 最后一个放入堆栈中的物体总是被最先拿出来，这个特性通常称为后进先出(LIFO)队列。堆栈中定义了一些操作。 两个最重要就是上述提到的PUSH和POP。PUSH操作在堆栈的顶部加入一个元素，POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。</p>
<p><strong>程序内存分区中的堆与栈</strong></p>
<hr>
<ul>
<li><p>栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等</p>
</li>
<li><p>堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表</p>
</li>
</ul>
<h3 id="3-2-volatile的作用"><a href="#3-2-volatile的作用" class="headerlink" title="3.2 volatile的作用"></a>3.2 volatile的作用</h3><p>volatile 关键字是一种类型修饰符，用它声明的类型变量<strong>表示可以被某些编译器未知的因素更改</strong>，遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化</strong>，从而可以提供对特殊地址的稳定访问。<strong>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据</strong>。而且读取的数据立刻被保存。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></span><br><span class="line"><span class="type">int</span> b = i;</span><br></pre></td></tr></table></figure>
<p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 <strong>volatile 可以保证对特殊地址的稳定访问</strong>。</p>
<p>一般说来，volatile用在如下的几个地方：</p>
<ul>
<li><p>中断服务程序中修改的供其它程序检测的变量需要加 volatile；</p>
</li>
<li><p>多任务环境下各任务间共享的标志应该加 volatile；</p>
</li>
<li><p>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；</p>
</li>
</ul>
<h3 id="3-3-局部变量和全局变量"><a href="#3-3-局部变量和全局变量" class="headerlink" title="3.3 局部变量和全局变量"></a>3.3 局部变量和全局变量</h3><p><strong>1. 局部变量</strong></p>
<hr>
<p>定义在函数内部的变量称为<strong>局部变量（Local Variable）</strong>，它的作用域仅限于函数内部， 离开该函数后就是无效的，再使用就会报错。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> b,c;  <span class="comment">//a,b,c仅在函数f1()内有效</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;  <span class="comment">//m,n仅在函数main()内有效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几点说明：</p>
<p>1）  在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数中定义的变量。main 函数也是一个函数，与其它函数地位平等。</p>
<p>2） 形参变量、在函数体内定义的变量都是局部变量。实参给形参传值的过程也就是给局部变量赋值的过程。</p>
<p>3） 可以在不同的函数中使用相同的变量名，它们表示不同的数据，分配不同的内存，互不干扰，也不会发生混淆。</p>
<p>4） 在语句块中也可定义变量，它的作用域只限于当前语句块。</p>
<p><strong>2. 全局变量</strong></p>
<hr>
<p>在所有函数外部定义的变量称为<strong>全局变量（Global Variable）</strong>，它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;  <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> x,y;  <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a、b、x、y 都是在函数外部定义的全局变量。C语言代码是从前往后依次执行的，由于 x、y 定义在函数 func1() 之后，所以在 func1() 内无效；而 a、b 定义在源程序的开头，所以在 func1()、func2() 和 main() 内都有效。</p>
<h3 id="3-4-static-用法举例"><a href="#3-4-static-用法举例" class="headerlink" title="3.4 static 用法举例"></a>3.4 static 用法举例</h3><p><strong>（1）局部变量中static的用法</strong></p>
<hr>
<ul>
<li><p><strong>普通局部变量存储于进程栈空间，使用完毕会立即释放</strong>。</p>
</li>
<li><p><strong>静态局部变量使用static修饰符定义</strong>，即使在声明时未赋初值，编译器也会把它初始化为0。且<strong>静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变</strong>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n=%d\n&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n++=%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn_static</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;static n=%d\n&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n++=%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">    fn_static();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">    fn_static();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n=<span class="number">10</span></span><br><span class="line">n++=<span class="number">11</span></span><br><span class="line">--------------------</span><br><span class="line"><span class="type">static</span> n=<span class="number">10</span></span><br><span class="line">n++=<span class="number">11</span></span><br><span class="line">--------------------</span><br><span class="line">n=<span class="number">10</span></span><br><span class="line">n++=<span class="number">11</span></span><br><span class="line">--------------------</span><br><span class="line"><span class="type">static</span> n=<span class="number">11</span></span><br><span class="line">n++=<span class="number">12</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）全局变量中static的用法</strong></p>
<hr>
<ul>
<li><p>全局变量定义在函数体外部，在全局数据区分配存储空间，且编译器会自动对其初始化<strong>。普通全局变量对整个工程可见</strong>，其他文件可以使用extern外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量）。</p>
</li>
<li><p><strong>静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。</strong></p>
</li>
</ul>
<p>在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。</p>
<p><strong>（3）函数中static的用法</strong></p>
<hr>
<p>函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。其特性如下：</p>
<ul>
<li><strong>静态函数只能在声明它的文件中可见，其他文件不能引用该函数</strong></li>
<li><strong>不同的文件可以使用相同名字的静态函数，互不影响</strong></li>
</ul>
<p>非静态函数可以在另一个文件中直接引用，甚至不必使用extern声明。</p>
<h3 id="3-5-inline-和宏的区别"><a href="#3-5-inline-和宏的区别" class="headerlink" title="3.5 inline 和宏的区别"></a>3.5 inline 和宏的区别</h3><p><strong>宏定义</strong>使用预处理器实现，做一些简单的字符替换因此不能进行参数有效性的检测。另外它的返回值不能被强制转换为可转换的合适类型</p>
<p><strong>inline函数</strong>代码是被放到符号表中，使用时像宏一样展开，没有调用的开销效率很高；inline函数是真正的函数，所以要进行一系列的数据类型检查；</p>
<p><strong>区别</strong></p>
<ul>
<li><p>宏定义不会进行类型的判断，只是单存的替换文本；inline会对参数类型进行判断。</p>
</li>
<li><p>宏不是函数，inline修饰的是函数。</p>
</li>
<li><p>宏返回值不能强制转换成合适的类型，inline返回值可以。</p>
</li>
</ul>
<h3 id="3-6-enum字宽"><a href="#3-6-enum字宽" class="headerlink" title="3.6 enum字宽"></a>3.6 enum字宽</h3><h2 id="4-1-通讯基础"><a href="#4-1-通讯基础" class="headerlink" title="4.1 通讯基础"></a>4.1 通讯基础</h2><p><strong>差分通讯原理概述</strong></p>
<p>差分传输是一种信号传输的技术，区别于传统的一根信号线一根地线的做法，差分传输在这两根线上都传输信号，这两个信号的振幅相等，相位相反。在这两根线上传输的信号就是差分信号。</p>
<p>所谓差分方式传输，就是发送端在两条信号线上传输幅值相等相位相反的电信号，接收端对接受的两条线信号作减法运算，这样获得幅值翻倍的信号。其抗干扰的原理是：假如两条信号线都受到了同样（同相、等幅）的干扰信号，由于接受端对接受的两条线的信号作减法运算，因此干扰信号被 基本抵消，那么怎样才能保证两条信号线受到的干扰信号尽量是同相、等幅的呢？办法之一那就要将两根线扭在一起，按照电磁学的原理分析出：可以近似地认为两条信号线受到的干扰信号是同相、等幅的。</p>
<p>发送端将信号调制成为对称的信号用双线发送，称为平衡发送；发送如采用单线（对应有参考电平），称为非平衡发送；接收端采用对称接收称为平衡接收；接收端采用非对称接收（单线接收对应一个基准电平）称接收为非平衡接收。例如差动电路就是一种平衡方式。</p>
<p>RS-232采取不平衡传输方式，即所谓单端通讯。收、发端的数据信号是相对于信号地。典型的RS-232信号在正负电平之间摆动，在发送数据时，发送端驱动器输出正电平在+5~+15V，负电平在-5~-15V电平。当无数据传输时，线上为TTL，从开始传送数据到结束，线上电平从TTL电平到RS-232电平再返回TTL电平。接收器典型的工作电平在+3~+12V与-3~-12V。由于发送电平与接收电平的差仅为2V至3V左右，所以其共模抑制能力差，再加上双绞线上的分布电容，其传送距离最大为约15米，最高速率为20Kbps。RS-232是为点对点（即只用一对收、发设备）通讯而设计的，其驱动器负载为3kΩ~7kΩ。所以RS-232适合本地设备之间的通信。</p>
<p>S-422、RS-485与RS-232不一样，数据信号采用差分传输方式，也称作平衡传输，它使用一对双绞线，将其中一线定义为A，另一线定义为B。通常情况下，发送驱动器A、B之间的正电平在+2 ~ +6V，是一个逻辑状态，负电平在-2V~6V，是另一个逻辑状态。另有一个信号地C，在RS-485中还有一“使能”端，而在RS-422中这是可用可不用的。“使能”端是用于控制发送驱动器与传输线的切断与连接。当“使能”端起作用时，发送驱动器处于高阻状态，称作“第三态”，即它是有别于逻辑“1”与“0”的第三态。 </p>
<p><strong>常用的通讯接口概述</strong></p>
<p>// <em>To Do</em></p>
<h2 id="4-2-I2C"><a href="#4-2-I2C" class="headerlink" title="4.2 I2C"></a>4.2 I2C</h2><h3 id="I2C优缺点"><a href="#I2C优缺点" class="headerlink" title="I2C优缺点"></a>I2C优缺点</h3><p>I2C通信传输速度快、传输方式简单灵活，主要具有以下<strong>优点</strong>：</p>
<ul>
<li><strong>节省引脚资源</strong>：由于只需要SCL和SDA两根线，因此I2C通信相对于其他通信接口而言，可以节省引脚资源。</li>
<li><strong>简单灵活</strong>：I2C通信具有简单的传输方式和灵活的应用场景，可以适应不同设备之间的通信需求。</li>
<li><strong>速度较快</strong>：I2C通信可以实现高速数据传输，一般可以达到400KHz的传输速度。</li>
</ul>
<p>I2C通信同样存在一些<strong>缺点：</strong></p>
<ul>
<li><strong>通信距离有限</strong>：由于I2C通信使用的是电平信号传输，其传输距离受限于电平信号的衰减和噪声干扰。一般来说，传输距离不宜过长。</li>
<li><strong>网络拓扑结构限制</strong>：需要主设备进行总线管理，因此网络拓扑结构受到一定限制，主设备数量和总线长度都有一定的要求。</li>
<li><strong>单主设备</strong>：一般情况下，I2C通信只支持一主多从的连接方式。</li>
</ul>
<h3 id="I2C速度范围"><a href="#I2C速度范围" class="headerlink" title="I2C速度范围"></a>I2C速度范围</h3><div class="table-container">
<table>
<thead>
<tr>
<th>速度模式</th>
<th>最高比特率（bit/s）</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准模式</td>
<td>100K</td>
<td>双向传输，高速模式兼容低速模式</td>
</tr>
<tr>
<td>快速模式</td>
<td>400K</td>
<td>双向传输，高速模式兼容低速模式</td>
</tr>
<tr>
<td>快速模式增强</td>
<td>1M</td>
<td>双向传输，高速模式兼容低速模式</td>
</tr>
<tr>
<td>高速模式</td>
<td>3.4M</td>
<td>双向传输，高速模式兼容低速模式</td>
</tr>
<tr>
<td>超快速模式</td>
<td>5M</td>
<td>单向传输，不兼容其他模式</td>
</tr>
</tbody>
</table>
</div>
<h3 id="I2C时序逻辑"><a href="#I2C时序逻辑" class="headerlink" title="I2C时序逻辑"></a>I2C时序逻辑</h3><p>I2C通信总是由主机启动，<strong>每个通信过程由起始信号开始，由停止信号结束</strong>。一个数据包由8位，每个数据包后有一个应答位(ACk)或者非应答位(NACK)。例如，主设备向从设备发送1字节数据的时序图如下：</p>
<p><img src="/img/loading.gif" data-original="I2C传输1字节的时序图.png" alt="I2C传输1字节的时序图"></p>
<ul>
<li>起始位：<strong>当SCL为高电平时，SDA的下降沿就是起始位</strong>，是启动一次I2C通信的起始信号。</li>
<li>停止位：<strong>当SCL为高电平时，SDA的上升沿就是停止位</strong>，是停止一次I2C通信的结束信号。</li>
<li>数据位：在SCL的一个时钟周期内传输一个数据位，<strong>当SCL位低电平时，发送设备更新SDA的电平，当SCL位高电平时，接收数据读取SDA的电平就是有效的一位数据。</strong></li>
<li>数据包：<strong>I2C数据通信一个数据包总是8位</strong>，也就是1个字节的数据。</li>
<li>应答信号：在发送完8位数据包之后，发送设备在第9个SCL时钟周期采集接收设备的应答信号。<strong>若在SCL的第9个周期采集的SDA为低电平，就是应答信号ACK，如果采集的SDA是高电平，就是非应答信号NACK。</strong></li>
</ul>
<h3 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h3><p><img src="/img/loading.gif" data-original="7Bit设备的数据传输.png" alt="7Bit设备的数据传输"></p>
<p>在I2C通信之中，在起始信号后的首字节由7位从机地址和1位读写位组成，结构如下：</p>
<p><img src="/img/loading.gif" data-original="I2C从机地址结构.png" alt="I2C从机地址结构"></p>
<p>发送完这个字节之后，主机释放SDA总线等待从机给出ACK应答。如果从机给出了ACK应答，表示从机地址正确（有从机响应）并且已知晓是读还是写，便可以开始读写数据。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由master来决定如何处理（STOP或ReSTART）。</p>
<p><strong>1、主机写-从机接收</strong></p>
<p>主机对从机发送数据时，主机对从机发送一个开始字节，然后即可一直发送数据。以示例来讲解，其第一帧数据为要操作的寄存器地址，所以为：“<strong>[1-Byte]开始字节(写) + [1-Byte]寄存器地址 + [1-Byte]寄存器数据</strong>”。</p>
<p><img src="/img/loading.gif" data-original="I2C向一个寄存器写入数据.png" alt="I2C向一个寄存器写入数据"></p>
<p><strong>2、主机读-从机发送</strong></p>
<p><strong>主机对向从机读取数据时，方式同发送数据有所不同，要多一次通信过程</strong>。主机需要先向从机发送一次信号，告诉从机”我要读取数据“，然后重开一次通信，等待从机主动返回数据。以示例来讲解，发送 “<strong>[1-Byte]开始字节(写) + [1-Byte]要读取的寄存器的地址</strong>”，之后结束通信，或者重开始，来进入到第二次通信中，<strong>先发送 [1-Byte]开始字节(读)</strong>，<strong>然后等待读取从机发送过来的 [1-Byte]数据即可</strong>。</p>
<p><img src="/img/loading.gif" data-original="I2C读取一个寄存器的数据.png" alt="I2C读取一个寄存器的数据"></p>
<h2 id="4-3-串口"><a href="#4-3-串口" class="headerlink" title="4.3 串口"></a>4.3 串口</h2><h3 id="串口通信参数配置"><a href="#串口通信参数配置" class="headerlink" title="串口通信参数配置"></a>串口通信参数配置</h3><p>为了正确实现串口间的通信，必须对串口的参数进行设置，主要需要配置的参数如下：</p>
<ul>
<li><strong>波特率</strong>：该参数表示每秒传输的比特数。</li>
<li><strong>数据位</strong>：表示通信中实际数据位的参数。</li>
<li><strong>奇偶校验位</strong>：该位用于串口通信中的简单检错。奇偶校验位主要有：偶校验、奇校验、标记、<strong>空格的方式</strong>，也可以不使用校验。<strong>奇/偶校验是通过统计数据中高位或低位的个数来实现校验的</strong>。而<strong>标记、空格并不真正检测数据</strong>，<strong>只是通过简单的置位来实现对数据的检测</strong>。通过置位方式，可以判断出是否存在噪声干扰数据通信或数据传输，以及接收是否存在不同步的现象。</li>
<li><strong>停止位</strong>：停止位用于标志该数据包数据结束。可以取1位、1.5位或2位，<strong>停止位不仅仅用于数据包的传输结束标志，还提供了计算机之间校正同步时钟的机会</strong>。用于停止位的位数越多，不同时钟同步的容忍程度越大。但是由于停止位占用了数据空间，<strong>过多的停止位将导致数据传输速度的下降</strong>。</li>
</ul>
<h3 id="串口通信协议"><a href="#串口通信协议" class="headerlink" title="串口通信协议"></a>串口通信协议</h3><p>串行通信协议包括：<strong>系统间协议</strong>和<strong>内部系统协议</strong>。</p>
<p><strong>1、系统间协议</strong>：用于通信两个不同设备的系统间协议。就像计算机与微控制器套件之间的通信一样。通过内部总线系统进行通信。<strong>常见的有UART协议、USART协议、USB协议</strong>。</p>
<ul>
<li><strong>UART协议</strong>：UART代表通用<strong>异步发送器和接收器</strong>。<strong>UART协议是具有两个有线协议的串口通信。</strong>数据电缆信号线标记为Rx和Tx。串口通信通常用于发送和接收信号。它被传输并与串口通信接收数据，而<strong>没有类脉冲</strong>。<strong>UART接收数据字节并按顺序发送各个位</strong>。<strong>UART是半双工协议</strong>。<u>半双工意味着具有传输和接收数据的功能，但不能同时进行</u>。</li>
<li><strong>USART协议</strong>：USART代表通用的<strong>同步和异步发送器和接收器</strong>。<strong>它是两线协议的串口通信</strong>。数据电缆信号线标记为Rx和TX。该协议用于逐字节发送和接收数据以及时钟脉冲。<strong>这是一种全双工协议</strong>，<u>意味着同时以不同的板速发送和接收数据</u>。</li>
<li><strong>USB协议</strong>：USB代表<strong>通用串行总线</strong>。同样，<strong>它是两线协议的串行通信。</strong>数据电缆信号线标记为D +和D-。此协议用于与系统外围设备进行通信。USB以不同的模式传输数据。第一个是<strong>10 Kbps至100 Kbps的慢速模式</strong>；<strong>第二个是全速模式500Kbps至10Mbps</strong>，<strong>高速模式25Mbps至400Mbps</strong>。</li>
</ul>
<p><strong>2、内部系统协议</strong>：内部系统协议用于通信电路板上的两个设备。<strong>常见的有I2C协议、SPI协议、CAN协议</strong>。</p>
<h3 id="串口通信物理接口"><a href="#串口通信物理接口" class="headerlink" title="串口通信物理接口"></a>串口通信物理接口</h3><p>常见的串口通信物理接口有<strong>TTL，RS232，RS485等，都是一种逻辑电平的表示方式</strong>。</p>
<p><strong>TTL：</strong>TTL指<strong>双极型三极管逻辑电路</strong>，市面上很多“USB转TTL”模块，实际上是“USB转TTL电平的串口”模块。这种信号0对应0V，1对应3.3V或者5V；TTL电平：<strong>全双工</strong>（逻辑1: 2.4V—5V 逻辑0: 0V—0.5V）。</p>
<p><strong>RS232：</strong>是电子工业协会(Electronic Industries Association，EIA) 制定的异步传输标准接口，同时对应着电平标准和通信协议（时序），其电平标准：<strong>+3V～+15V对应0，-3V～-15V对应1</strong>。RS232 的逻辑电平和TTL 不一样但是协议一样。RS-232电平：<strong>全双工</strong>（逻辑1：-15V—5V 逻辑0：+3V—+15V）。</p>
<p><strong>RS485：</strong>RS485是一种串口接口标准，为了长距离传输采用差分方式传输，传输的是差分信号，抗干扰能力比RS232强很多。<strong>两线压差为-(2 ~ 6)V表示0，两线压差为+(2 ~ 6)V表示1</strong>。RS-485：<strong>半双工</strong>（逻辑1：+2V—+6V 逻辑0： -6V—-2V）这里的电平指AB 两线间的电压差。</p>
<h2 id="4-4-SPI"><a href="#4-4-SPI" class="headerlink" title="4.4 SPI"></a>4.4 SPI</h2><h3 id="SPI优缺点"><a href="#SPI优缺点" class="headerlink" title="SPI优缺点"></a>SPI优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>支持全双工操作</li>
<li>操作简单，没有复杂的从机寻址系统</li>
<li>数据传输速率较高</li>
<li>没有启动和停止位，因此数据可以连续流式传输而不会中断</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>占用IO口较多，需要4根线，如果需要多个从机，还需要额外加1个片选。</li>
<li>没有应答机制确认是否接收到数据</li>
<li>没有错误检查，如UART中的奇偶校验位</li>
<li>只支持一主多从</li>
</ul>
<h3 id="SPI通信基本原理"><a href="#SPI通信基本原理" class="headerlink" title="SPI通信基本原理"></a>SPI通信基本原理</h3><p>SPI接口一般使用四条信号线通信：<strong>SDI（数据输入），SDO（数据输出），SCK（时钟），CS（片选）</strong></p>
<p>SPI是一个同步的数据总线，也就是说它用<strong>单独的数据线</strong>和一个<strong>单独的时钟信号</strong>来保证<strong>发送端和接收端的完美同步</strong>。</p>
<p><strong>时钟是一个振荡信号，它高速接收端在确切的时机对数据线上的信号进行采样</strong>。</p>
<p>产生时钟的一侧称为<strong>主机</strong>，另一侧称为<strong>从机</strong>。<strong>SPI中总是只有一个主机，但是可以有多个从机</strong>，数据的采集时机可能时<strong>时钟信号的上升沿或下降沿</strong>（具体要看SPI的配置）。</p>
<p>SPI通信有4种不同的模式，不同的从设备可能在出厂是就是配置为某种模式，这是不能改变的；但我们的通信双方必须是工作在同一模式下，所以我们可以对我们的主设备的SPI模式进行配置，<strong>通过CPOL（时钟极性）和CPHA（时钟相位）来控制我们主设备的通信模式</strong>，具体如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">CPOL（时钟极性）</th>
<th style="text-align:center">CPHA（时钟相位）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MODE0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">MODE1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">MODE2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">MODE3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p><strong>时钟极性CPOL是用来配置SCLK的电平出于哪种状态时是空闲态或者有效态，时钟相位CPHA是用来配置数据采样是在第几个边沿</strong>:</p>
<ul>
<li><strong>CPOL=0，表示当SCLK=0时处于空闲态，所以有效状态就是SCLK处于高电平时</strong>；</li>
<li><strong>CPOL=1，表示当SCLK=1时处于空闲态，所以有效状态就是SCLK处于低电平时</strong>；</li>
<li><strong>CPHA=0，表示数据采样是在第1个边沿，数据发送在第2个边沿</strong>；</li>
<li><strong>CPHA=1，表示数据采样是在第2个边沿，数据发送在第1个边沿</strong>;</li>
</ul>
<p>对于SPI的四种通讯模式，总结起来，就是：</p>
<ul>
<li><p>CPOL=0，CPHA=0：此时空闲态时，SCLK处于低电平，数据采样是在第1个边沿，也就是SCLK由低电平到高电平的跳变，所以数据采样是在上升沿；</p>
</li>
<li><p>CPOL=0，CPHA=1：此时空闲态时，SCLK处于低电平，数据发送是在第1个边沿，也就是SCLK由低电平到高电平的跳变，所以数据采样是在下降沿；</p>
</li>
<li>CPOL=1，CPHA=0：此时空闲态时，SCLK处于高电平，数据采集是在第1个边沿，也就是SCLK由高电平到低电平的跳变，所以数据采集是在下降沿；</li>
<li>CPOL=1，CPHA=1：此时空闲态时，SCLK处于高电平，数据发送是在第1个边沿，也就是SCLK由高电平到低电平的跳变，所以数据采集是在上升沿。</li>
</ul>
<p>以MODE3为例，主设备对从设备的读写数据时序如下：</p>
<p><img src="/img/loading.gif" data-original="SPI读写时序.png" alt="SPI读写时序"></p>
<p>在SPI中，主机和从机都有一个<strong>串行移位寄存器</strong>，<u>主机通过向它的SPI串行寄存器写入一个字节来发起一次传输</u>；</p>
<p>串行移位寄存器通过MOSI信号线将字节传送给从机，同时从机也将自己的串行移位寄存器中的内容通过MISO信号线返回给主机。这样，两个移位寄存器中的内容就被交换；</p>
<p><strong>外设的写操作和读操作是同步完成的</strong>。<u>如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输</u>。</p>
<p><strong>SPI整体的传输大概可以分为以下几个过程：</strong></p>
<ul>
<li><strong>主机首先拉低对应从机CS（片选）信号线，表示与该从机进行通信</strong>。</li>
<li><strong>主机通过发送SCLK时钟信号，来告诉从机写数据或者读数据</strong>。</li>
<li><strong>主机将要发送的数据写到发送<u>数据缓存区</u>，缓存区经过移位寄存器(0~7)，串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区</strong>。</li>
<li><strong>从机也将自己的串行移位寄存器(0~7)中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换</strong>。</li>
</ul>
<p><img src="/img/loading.gif" data-original="SPI数据传输.png" alt="SPI数据传输"></p>
<h2 id="4-5-CAN"><a href="#4-5-CAN" class="headerlink" title="4.5 CAN"></a>4.5 CAN</h2><h3 id="CAN优缺点"><a href="#CAN优缺点" class="headerlink" title="CAN优缺点"></a>CAN优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li><strong>高速传输</strong>：<strong>CAN总线的传输速度可以达到1Mbps</strong>。</li>
<li><strong>多设备连接</strong>：<strong>它是一种多主总线，即每个节点机均可成为主机，且节点机之间也可进行通信</strong></li>
<li><strong>抗干扰性强</strong>：<strong>CAN总线采用差分信号传输</strong>，<strong>抗干扰性能强，适用于工业环境</strong></li>
<li><strong>可靠性高</strong>：<strong>CAN总线采用了冗余校验和错误重传机制，保证了数据传输的可靠性</strong></li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>成本高</strong>：<strong>CAN总线需要专门的控制器和收发器，成本较高</strong></li>
<li><strong>配置复杂</strong>：<strong>CAN总线需要进行配置和初始化</strong>，<strong>对于初学者来说比较复杂</strong></li>
</ul>
<h3 id="CAN通讯基本原理"><a href="#CAN通讯基本原理" class="headerlink" title="CAN通讯基本原理"></a>CAN通讯基本原理</h3><ul>
<li><strong>以广播的形式发送报文</strong>。当CAN总线上的某个节点需要给其他节点发送消息时，会<strong>以广播的形式发送给总线上所有的节点</strong>，所以总线上的节点不适用地址来进行配置CAN系统，而是根据报文的开头的11位标识符决定是否要接受其他节点发来的报文。</li>
<li>每个节点都有自己的处理器和CAN总线接口控制器；</li>
<li>当一个节点需要发送数据到另一个节点时，自身节点的处理器需要将<strong>要发送的数据</strong>和自己的<strong>标识符</strong>传给自身的总线控制接口，处于准备状态；当获取到总线的使用权后，将数据和标识符组装成报文，将报文以一定格式发出，此时其他的节点处于接收状态。至于其他节点是否接收，由其他节点决定，是都会对某些报文进行过滤。</li>
<li>当新增的节点仅仅是纯粹的数据接收设备时，只需要该设备直接从总线上接收数据即可。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">林守拙</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">http://example.com/2023/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">林守拙的个人空间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></div><div class="post_share"><div class="social-share" data-image="/img/bingbing2_corrosion_port.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/08/16/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/" title="电力电子技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">电力电子技术</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/bingbing2_corrosion_port.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">林守拙</div><div class="author-info__description">抱朴守拙，行稳致远</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KeyL-SJ"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/KeyL-SJ" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-text">一、C语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">1、 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-while%E4%B8%8Edo-while%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.1 while与do while的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.2 数据基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B4%E5%9E%8B"><span class="toc-text">1. 整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-text">2. 浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-text">3. 字符型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B"><span class="toc-text">4. 构造类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%B8%8D%E5%90%8CMCU%E4%B8%8Bchar-short-int-long%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6"><span class="toc-text">1.3 不同MCU下char,short,int,long类型长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-define%E5%92%8Ctypedef%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.4 define和typedef的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-text">1.5 函数入口参数的判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E7%9A%84%E5%88%A4%E6%96%AD%E5%8F%8A%E5%A4%84%E7%90%86"><span class="toc-text">1.6 数组越界的判断及处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8C%87%E9%92%88"><span class="toc-text">2. 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">2.1 函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="toc-text">2.2 指针函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="toc-text">2.3 常量指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-text">2.4 指针常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">3. 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%A0%86%E6%A0%88%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1 堆栈概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-volatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3.2 volatile的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">3.3 局部变量和全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-static-%E7%94%A8%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="toc-text">3.4 static 用法举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-inline-%E5%92%8C%E5%AE%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.5 inline 和宏的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-enum%E5%AD%97%E5%AE%BD"><span class="toc-text">3.6 enum字宽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%80%9A%E8%AE%AF%E5%9F%BA%E7%A1%80"><span class="toc-text">4.1 通讯基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-I2C"><span class="toc-text">4.2 I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">I2C优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E9%80%9F%E5%BA%A6%E8%8C%83%E5%9B%B4"><span class="toc-text">I2C速度范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91"><span class="toc-text">I2C时序逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E5%8D%8F%E8%AE%AE"><span class="toc-text">I2C协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%B8%B2%E5%8F%A3"><span class="toc-text">4.3 串口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-text">串口通信参数配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">串口通信协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="toc-text">串口通信物理接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-SPI"><span class="toc-text">4.4 SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">SPI优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">SPI通信基本原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-CAN"><span class="toc-text">4.5 CAN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAN%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">CAN优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAN%E9%80%9A%E8%AE%AF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">CAN通讯基本原理</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="嵌入式软件开发基础知识">嵌入式软件开发基础知识</a><time datetime="2023-11-01T14:41:25.000Z" title="发表于 2023-11-01 22:41:25">2023-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/16/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/" title="电力电子技术">电力电子技术</a><time datetime="2023-08-16T14:07:49.000Z" title="发表于 2023-08-16 22:07:49">2023-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/16/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="FreeRTOS学习笔记">FreeRTOS学习笔记</a><time datetime="2023-08-16T14:07:49.000Z" title="发表于 2023-08-16 22:07:49">2023-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/31/I2C%E6%80%BB%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" title="I2C总线与通信协议">I2C总线与通信协议</a><time datetime="2023-07-31T14:27:51.000Z" title="发表于 2023-07-31 22:27:51">2023-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/27/%E5%8F%8C%E7%8E%AF%E6%8E%A7%E5%88%B6PID%E7%AE%97%E6%B3%95/" title="双环控制PID算法">双环控制PID算法</a><time datetime="2023-07-27T12:21:44.000Z" title="发表于 2023-07-27 20:21:44">2023-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 林守拙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>