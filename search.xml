<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>嵌入式软件开发基础知识</title>
      <link href="/2023/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、C语言基础"><a href="#一、C语言基础" class="headerlink" title="一、C语言基础"></a>一、C语言基础</h1><h2 id="1、-基本语法"><a href="#1、-基本语法" class="headerlink" title="1、 基本语法"></a>1、 基本语法</h2><h3 id="1-1-while与do-while的区别"><a href="#1-1-while与do-while的区别" class="headerlink" title="1.1 while与do while的区别"></a>1.1 while与do while的区别</h3><ul><li><p>while循环在执行循环体内容之前会进行条件判断，若条件满足，则才会不断执行循环体内的内容，直到条件不满足或者遇到break语句。</p></li><li><p>do while会先执行一次循环体的内容，之后再进行条件判断，若条件满足，则继续不断执行循环体内的内容。</p></li></ul><h3 id="1-2-数据基本类型"><a href="#1-2-数据基本类型" class="headerlink" title="1.2 数据基本类型"></a>1.2 数据基本类型</h3><p><img src="C数据类型.png" alt="C数据类型"></p><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h4><p>整型分为<strong>整形常量</strong>和整形变量，常量就是我们平时所看到的准确的数字，例如：1、20、333等等，变量则按我的理解是我向内存去申请一个存储空间，告诉内存空间我申请了这个地方用来存放一个整形的数据，但是什么时候放并没有直接确定。一般占4个字节（32位），最高位代表符号，0表示正数，1表示负数，取值是-2147483648~2147483647（-2^31^ ~ 2^31^-1），<strong>在内存中的存储顺序是低位在前、高位在后</strong>，例如0x12345678。</p><ul><li><p><strong>短整型 short</strong>，内存中占2个字节(2 Bytes)，是short int 的简写。取值范围：-32768 ~ + 32767 (-2^15^ ~ 2^15^-1)。</p></li><li><p><strong>整型int</strong>，内存中占4个字节(4 Bytes)，是long int的简写。取值范围：-2147483648 ~ +2147483647(-2^31^ ~ 2^31^)。</p></li><li><p><strong>长整型long long</strong>，32位平台下long 是4个字节，long long 是8字节；但是64位平台下则全是8字节。<strong>因此为了保证平台的通用性，程序中尽量不要使用long数据类型。</strong></p></li></ul><h4 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a>2. 浮点型</h4><ul><li><strong>单精度float</strong>，系统的基本浮点类型，至少能精确表示小数点后6位有效数字。<strong>一个float类型占用4个字节的存储位</strong>，<u>其中最高位为符号位，紧接着8位为指数位，剩下的23位为尾数位</u>。</li><li><strong>双精度double</strong>，至少能精确表示小数点后12位有效数字。<strong>一个double类型占用8个字节的存储位</strong>，<u>其中最高位为符号位，紧接着8位为指数位，剩下的52位为尾数位</u>。</li></ul><h4 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3. 字符型"></a>3. 字符型</h4><p>字符型在其本质上就是整形，我们在C语言中使用char表示一个字符型，<strong>他占用一个字符的存储空间</strong>，字符型在存储时其内部存储的依旧是二进制数据。</p><h4 id="4-构造类型"><a href="#4-构造类型" class="headerlink" title="4. 构造类型"></a>4. 构造类型</h4><p><strong>4.1 数组</strong></p><hr><p>数组是按照顺序存储的一系列类型相同的值，如10个char类型的字符或15个int类型的值。整个数组有一个数组名，通过整数下标访问数组中单独的项或元素。</p><p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type arrayName[arraySize];</span><br></pre></td></tr></table></figure><p><strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double balance[10];</span><br></pre></td></tr></table></figure><p>现在 <em>balance</em> 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</p><p><strong>4.2 结构体</strong></p><hr><p>结构体是一种自定义的复合数据类型。例如存储学生信息就会用到此种数据类型。</p><p><strong>定义结构体</strong></p><p>结构体定义由关键字 <strong>struct</strong> 和结构体名组成，结构体名可以根据需要自行定义。</p><p>struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span></span><br><span class="line">  member-<span class="built_in">list</span></span><br><span class="line">  member-<span class="built_in">list</span></span><br><span class="line">  member-<span class="built_in">list</span>  </span><br><span class="line">  ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br></pre></td></tr></table></figure><p><strong>tag</strong> 是结构体标签。</p><p><strong>member-list</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong>，或者其他有效的变量定义。</p><p><strong>variable-list</strong> 结构变量，定义在结构的末尾，最后一个分号之前，可以指定一个或多个结构变量。下面是声明 Book 结构的方式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line">  <span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span>  book_id;</span><br><span class="line">&#125; book; </span><br></pre></td></tr></table></figure><p>在一般情况下，<strong>tag、member-list、variable-list</strong> 这 3 部分至少要出现 2 个。以下为实例：</p><p>此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，同时又声明了结构体变量s1，这个结构体并没有标明其标签。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125; s1;</span><br></pre></td></tr></table></figure><p>此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，结构体的标签被命名为SIMPLE,没有声明变量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用SIMPLE标签的结构体，另外声明了变量t1、t2、t3。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">t1</span>, <span class="title">t2</span>[20], *<span class="title">t3</span>;</span></span><br></pre></td></tr></table></figure><p>也可以用typedef创建新类型。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125; Simple2;</span><br><span class="line"><span class="comment">//现在可以用Simple2作为类型声明新的结构体变量</span></span><br><span class="line">Simple2 u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure><p><strong>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针</strong>，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此结构体的声明包含了其他的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COMPLEX</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此结构体的声明包含了指向自己类型的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>    <span class="comment">//对结构体B进行不完整声明</span></span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.3 共用体</strong></p><hr><p>关键字：<code>union</code>，共用体也叫联合体，<strong>使几个不同类型的变量共占一段内存(相互覆盖)，也就是说共用体的成员共用一片内存</strong>，后赋值的成员变量的数据才是共用体的生效数据，因为前面的赋值已经被覆盖了。共用体所占内存至少能够容纳最大的成员变量所需的空间，应用场景，比如需要一种既可以存储<code>int</code>型数据也可以存储<code>double</code>型数据的变量。</p><p><strong>共用体</strong>是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。<strong>可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值</strong>。共用体提供了一种使用相同的内存位置的有效方式。</p><p><strong>定义共用体</strong></p><p>为了定义共用体，您必须使用 <strong><code>union</code></strong> 语句，方式与定义结构类似。<code>union</code> 语句定义了一个新的数据类型，带有多个成员。<code>union</code> 语句的格式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> [<span class="title">union</span> <span class="title">tag</span>] &#123;</span></span><br><span class="line">    member definition;   </span><br><span class="line">    member definition;   </span><br><span class="line">    ...   </span><br><span class="line">    member definition; </span><br><span class="line">&#125; [one or more <span class="class"><span class="keyword">union</span> <span class="title">variables</span>];</span></span><br></pre></td></tr></table></figure><p><strong>union tag</strong> 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span>   </span><br><span class="line"><span class="type">int</span> i;   </span><br><span class="line"><span class="type">float</span> f;   </span><br><span class="line"><span class="type">char</span>  str[<span class="number">20</span>]; </span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure><p>现在，<strong>Data</strong> 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</p><p><strong>共用体占用的内存应足够存储共用体中最大的成员</strong>。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的，所以该共用体占用的内存位20；</p><p><strong>4.4 枚举类型</strong></p><hr><p>枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读。<strong>枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性</strong>。</p><p>定义一个枚举类型，需要使用 <strong>enum</strong> 关键字，后面跟着枚举类型的名称，以及用大括号 <strong>{}</strong> 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 <strong>0</strong> 开始递增。</p><p>枚举语法定义格式为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure><p>比如：一星期有 7 天，使用枚举的方式定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span>&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<em>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</em></p><p>可以在定义枚举类型时改变枚举元素的值：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span>spring, summer=<span class="number">3</span>, autumn, winter&#125;;</span><br></pre></td></tr></table></figure><p><strong>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</strong></p><p><strong>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的</strong>，所以按照 C 语言规范是没有办法遍历枚举类型的。<strong>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span>&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历枚举元素</span></span><br><span class="line">    <span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;枚举元素：%d \n&quot;</span>, day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">枚举元素：<span class="number">1</span> </span><br><span class="line">枚举元素：<span class="number">2</span> </span><br><span class="line">枚举元素：<span class="number">3</span> </span><br><span class="line">枚举元素：<span class="number">4</span> </span><br><span class="line">枚举元素：<span class="number">5</span> </span><br><span class="line">枚举元素：<span class="number">6</span> </span><br><span class="line">枚举元素：<span class="number">7</span></span><br></pre></td></tr></table></figure><p>以下枚举类型不连续，这种枚举无法遍历。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    ENUM_0,</span><br><span class="line">    ENUM_10 = <span class="number">10</span>,</span><br><span class="line">    ENUM_11</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>将整数转换为枚举</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    saturday,</span><br><span class="line">    sunday,</span><br><span class="line">    monday,</span><br><span class="line">    tuesday,</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; workday;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">weekend</span>;</span></span><br><span class="line">   weekend = ( <span class="keyword">enum</span> day ) a;  <span class="comment">//类型转换</span></span><br></pre></td></tr></table></figure><h3 id="1-3-不同MCU下char-short-int-long类型长度"><a href="#1-3-不同MCU下char-short-int-long类型长度" class="headerlink" title="1.3 不同MCU下char,short,int,long类型长度"></a>1.3 不同MCU下char,short,int,long类型长度</h3><div class="table-container"><table><thead><tr><th>MCU位数</th><th>char</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>8位</td><td>1字节</td><td>2字节</td><td>2字节</td><td>4字节</td><td>4字节</td><td>4字节</td></tr><tr><td>16位</td><td>1字节</td><td>2字节</td><td>2字节</td><td>4字节</td><td>4字节</td><td>4字节</td></tr><tr><td>32位</td><td>1字节</td><td>2字节</td><td>4字节</td><td>4字节</td><td>4字节</td><td>8字节</td></tr></tbody></table></div><h3 id="1-4-define和typedef的区别"><a href="#1-4-define和typedef的区别" class="headerlink" title="1.4 define和typedef的区别"></a>1.4 define和typedef的区别</h3><p><strong>typedef和define都是替一个对象取一个别名，以此增强程序的可读性，区别如下：</strong></p><p><strong>（1）原理不同</strong></p><p><strong>#define是C语言中定义的语法，是预处理指令</strong>，在预处理时进行简单而机械的字符串替换，<strong>不作正确性检查</strong>，只有在编译已被展开的源程序时才会发现可能的错误并报错。</p><p><strong>typedef是关键字</strong>，<strong>在编译时处理，有类型检查功能</strong>。它在自己的作用域内给一个已经存在的类型一个别名，<strong>但不能在一个函数定义里面使用typedef</strong>。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。</p><p><strong>（2）功能不同</strong></p><p><strong>typedef用来定义类型的别名</strong>，起到类型易于记忆的功能。另一个功能是定义机器无关的类型。如定义一个REAL的浮点类型，在目标机器上它可以获得最高的精度：<code>typedef long double REAL</code>， 在不支持long double的机器上，看起来是这样的：<code>typedef double REAL</code>，在不支持double的机器上，是这样的：<code>typedef float REAL</code></p><p><strong>#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等</strong>。</p><p><strong>（3）作用域不同</strong></p><p><strong>#define没有作用域的限制</strong>，只要是之前预定义过的宏，在以后的程序中都可以使用，<strong>而typedef有自己的作用域</strong>。</p><p><strong>（4）对指针的操作不同</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR1 int*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* INTPTR2;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> INTPTR1 p1 = &amp;a;</span><br><span class="line"><span class="type">const</span> INTPTR2 p2 = &amp;b;</span><br><span class="line">INTPTR2 <span class="type">const</span> p3 = &amp;c;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>const INTPTR1 p1</code>是一个<strong>常量指针</strong>，<strong>即不可以通过p1去修改p1指向的内容，但是p1可以指向其他内容。</strong></p><p><code>const INTPTR2 p2</code>是一个<strong>指针常量</strong>，<strong>不可使p2再指向其他内容</strong>。因为INTPTR2表示一个指针类型，因此用const限定，表示封锁了这个指针类型。</p><h4 id="1-5-函数入口参数的判断"><a href="#1-5-函数入口参数的判断" class="headerlink" title="1.5 函数入口参数的判断"></a>1.5 函数入口参数的判断</h4><ul><li><strong>入口参数</strong>：参数的值由调用者指定，被调函数使用。</li><li><strong>出口参数</strong>：参数的值由被调函数指定，调用者使用。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="comment">// 出口参数 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_data</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">int</span> sex)</span> &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s\n&quot;</span>, name); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;年龄：%d\n&quot;</span>, age); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;性别：%s\n&quot;</span>, sex ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 入口参数 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_data</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> *age, <span class="type">int</span> *sex)</span> &#123; </span><br><span class="line">    <span class="comment">// 直接指定 // strcpy(name, &quot;张三&quot;); </span></span><br><span class="line">    <span class="comment">// *age = 18; </span></span><br><span class="line">    <span class="comment">// *sex = 1 </span></span><br><span class="line">    <span class="comment">// 通过输入指定 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入姓名：&quot;</span>); </span><br><span class="line">    gets(name); <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄：&quot;</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, age); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入性别(男1女0)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, sex); </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line">    <span class="type">char</span> name[<span class="number">1024</span>]; </span><br><span class="line">    <span class="type">int</span> age, sex; </span><br><span class="line">    <span class="comment">// 调用者现在不知道这三个参数的值， </span></span><br><span class="line">    <span class="comment">// 这三个参数的值由被调函数指定（由用户输入） </span></span><br><span class="line">    get_data(name, &amp;age, &amp;sex); </span><br><span class="line">    <span class="comment">// 调用者现在知道了这三个参数的值， </span></span><br><span class="line">    <span class="comment">// 并传给被调函数使用（显示出来） </span></span><br><span class="line">    print_data(name, age, sex); <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-数组越界的判断及处理"><a href="#1-6-数组越界的判断及处理" class="headerlink" title="1.6 数组越界的判断及处理"></a>1.6 数组越界的判断及处理</h4><p>在 C 语言中，数组必须是静态的。换而言之，数组的大小必须在程序运行前就确定下来。因此，数组下标的取值范围只能预先推断一个值来确定数组的维数，一般情况下，数组的越界错误主要包括两种：<strong>数组下标取值越界</strong>与<strong>指向数组的指针的指向范围越界</strong>。</p><p><strong>数组下标取值越界</strong></p><hr><p><strong>数组下标取值越界主要是指访问数组的时候，下标的取值不在已定义好的数组的取值范围内，而访问的是无法获取的内存地址</strong>。例如，对于数组 int a[3]，它的下标取值范围是 [0，2]（即 a[0]、a[1] 与 a[2]）。如果我们的取值不在这个范围内（如 a[3]），就会发生越界错误。示例代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d\n&quot;</span>,i,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，在上面的示例程序中，访问 a[3] 是非法的，将会发生越界错误。因此，我们应该将上面的代码修改成如下形式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d\n&quot;</span>,i,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指向数组的指针指向的地址越界</strong></p><hr><p>指向数组的指针指向的地址越界指的是在定义数组时会返回一个指向第一个变量的头指针，对这个指针进行加减运算可以移动该指针，进而访问数组中的所有变量，<strong>但是在移动指针时，若是不注意移动的次数和位置，就会使指针指向数组之外的位置，导致数组发生越界错误</strong>。示例代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="comment">/*数组a的头指针赋值给指针p*/</span></span><br><span class="line">p=a;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*指针p指向的变量*/</span></span><br><span class="line">    *p=i+<span class="number">10</span>;</span><br><span class="line">    <span class="comment">/*指针p下一个变量*/</span></span><br><span class="line">    p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，for 循环会使指针 p 向后移动 10 次，并且每次向指针指向的单元赋值。但是，这里数组 a 的下标取值范围是 [0，4]（即 a[0]、a[1]、a[2]、a[3] 与 a[4]）。因此，<strong>后 5 次的操作会对未知的内存区域赋值，而这种向内存未知区域赋值的操作会使系统发生错误</strong>。正确的操作应该是指针移动的次数与数组中的变量个数相同，如下面的代码所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="comment">/*数组a的头指针赋值给指针p*/</span></span><br><span class="line">p=a;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*指针p指向的变量*/</span></span><br><span class="line">    *p=i+<span class="number">10</span>;</span><br><span class="line">    <span class="comment">/*指针p下一个变量*/</span></span><br><span class="line">    p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C 语言中，为了提高运行效率，给程序员更大的空间，为指针操作带来更多的方便，<strong>C 语言内部本身不检查数组下标表达式的取值是否在合法范围内，也不检查指向数组元素的指针是不是移出了数组的合法区域</strong>。因此，在编程中使用数组时就必须格外谨慎，在对数组进行读写操作时都应当进行相应的检查，以免对数组的操作超过数组的边界，从而发生缓冲区溢出漏洞。</p><p><strong>(1) 尽量显式地指定数组的边界</strong></p><p>要避免程序因数组越界所发生的错误，首先就需要从数组的边界定义开始。尽量显式地指定数组的边界，即使它已经由初始化值列表隐式指定。示例代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>很显然，对于上面的数组 a[]，虽然编译器可以根据始化值列表来计算出数组的长度。但是，如果我们显式地指定该数组的长度，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>它不仅使程序具有更好的可读性，并且大多数编译器在数组长度小于初始化值列表的长度时还会发生相应警告。</p><p> 当然，<strong>也可以使用宏的形式来显式指定数组的边界</strong>（实际上，这也是最常用的指定方法），如下面的代码所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="type">int</span> a[MAX]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>除此之外，在 C99 标准中，还允许我们使用单个指示符为数组的两段“分配”空间，如下面的代码所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[MAX]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[MAX<span class="number">-5</span>]=<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>在上面的 a[MAX] 数组中，如果 MAX 大于 10，数组中间将用 0 值元素进行填充（填充的个数为 MAX-10，并从 a[5] 开始进行 0 值填充）；如果 MAX 小于 10，“[MAX-5]”之前的 5 个元素（1，2，3，4，5）中将有几个被“[MAX-5]”之后的 5 个元素（6，7，8，9，10）所覆盖，示例代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX1 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX2 6</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[MAX]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[MAX<span class="number">-5</span>]=<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[MAX1]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[MAX1<span class="number">-5</span>]=<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> c[MAX2]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[MAX2<span class="number">-5</span>]=<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[MAX]：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d &quot;</span>,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nb[MAX1]：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX1;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b[%d]=%d &quot;</span>,j,b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nc[MAX2]：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(z=<span class="number">0</span>;z&lt;MAX2;z++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c[%d]=%d &quot;</span>,z,c[z]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[MAX]：</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span> a[<span class="number">1</span>]=<span class="number">2</span> a[<span class="number">2</span>]=<span class="number">3</span> a[<span class="number">3</span>]=<span class="number">4</span> a[<span class="number">4</span>]=<span class="number">5</span> a[<span class="number">5</span>]=<span class="number">6</span> a[<span class="number">6</span>]=<span class="number">7</span> a[<span class="number">7</span>]=<span class="number">8</span> a[<span class="number">8</span>]=<span class="number">9</span> a[<span class="number">9</span>]=<span class="number">10</span></span><br><span class="line">b[MAX1]：</span><br><span class="line">b[<span class="number">0</span>]=<span class="number">1</span> b[<span class="number">1</span>]=<span class="number">2</span> b[<span class="number">2</span>]=<span class="number">3</span> b[<span class="number">3</span>]=<span class="number">4</span> b[<span class="number">4</span>]=<span class="number">5</span> b[<span class="number">5</span>]=<span class="number">0</span> b[<span class="number">6</span>]=<span class="number">0</span> b[<span class="number">7</span>]=<span class="number">0</span> b[<span class="number">8</span>]=<span class="number">0</span> b[<span class="number">9</span>]=<span class="number">0</span> b[<span class="number">10</span>]=<span class="number">6</span> b[<span class="number">11</span>]=<span class="number">7</span> b[<span class="number">12</span>]=<span class="number">8</span> b[<span class="number">13</span>]=<span class="number">9</span> b[<span class="number">14</span>]=<span class="number">10</span></span><br><span class="line">c[MAX2]：</span><br><span class="line">c[<span class="number">0</span>]=<span class="number">1</span> c[<span class="number">1</span>]=<span class="number">6</span> c[<span class="number">2</span>]=<span class="number">7</span> c[<span class="number">3</span>]=<span class="number">8</span> c[<span class="number">4</span>]=<span class="number">9</span> c[<span class="number">5</span>]=<span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>(2) 对数组做越界检查，确保索引值位于合法的范围之内</strong></p><p>要避免数组越界，除了上面所阐述的显式指定数组的边界之外，<strong>还可以在数组使用之前进行越界检查，检查数组的界限和字符串（也以数组的方式存放）的结束，以保证数组索引值位于合法的范围之内</strong>。例如，在写处理数组的函数时，一般应该有一个范围参数；在处理字符串时总检查是否遇到空字符‘\0’。</p><p>来看下面一段代码示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_NUM 10</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">TestArray</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*ARRAY_NUM);</span><br><span class="line">    <span class="keyword">if</span>(arr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        arr[num] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/*处理arr==NULL*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的“int*TestArray（int num，int value）”函数中不难看出，其中存在着一个很明显的问题，那就是无法保证 num 参数是否越界（即当 num&gt;=ARRAY_NUM 的情况）。因此，应该对 num 参数进行越界检查，示例代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">TestArray</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*越界检查(越上界)*/</span></span><br><span class="line">    <span class="keyword">if</span>(num&lt;ARRAY_NUM)&#123;</span><br><span class="line">        arr=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*ARRAY_NUM);</span><br><span class="line">        <span class="keyword">if</span>(arr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            arr[num]=value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*处理arr==NULL*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过“if（num&lt;ARRAY_NUM）”语句进行越界检查，从而保证 num 参数没有越过这个数组的上界。现在看起来，TestArray() 函数应该没什么问题，也不会发生什么越界错误。</p><p> 但是，如果仔细检查，TestArray() 函数仍然还存在一个致命的问题，<strong>那就是没有检查数组的下界</strong>。由于这里的 num 参数类型是 int 类型，因此可能为负数。<strong>如果 num 参数所传递的值为负数，将导致在 arr 所引用的内存边界之外进行写入</strong>。</p><p> 当然，可以通过向“if（num&lt;ARRAY_NUM）”语句里面再加一个条件进行测试，如下面的代码所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f(num &gt;= <span class="number">0</span> &amp;&amp; num &lt; ARRAY_NUM)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 获取数组的长度时不要对指针应用 sizeof 操作符</strong></p><p><strong>sizeof 是一个单目操作符，不是函数</strong>。其作用就是返回一个操作数所占的内存字节数。其中，<strong>操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型来决定</strong>。例如，对于数组 int a[5]，可以使用“sizeof(a)”来获取数组的长度，使用“sizeof(a[0])”来获取数组元素的长度。</p><p>但需要注意的是，<strong>sizeof 操作符不能用于函数类型、不完全类型（指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void 类型等）与位字段</strong>。例如，以下都是不正确形式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*若此时max定义为int max()；*/</span></span><br><span class="line"><span class="keyword">sizeof</span>(max)</span><br><span class="line"><span class="comment">/*若此时arr定义为char arr[MAX]，且MAX未知*/</span></span><br><span class="line"><span class="keyword">sizeof</span>(arr)</span><br><span class="line"><span class="comment">/*不能够用于void类型*/</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">void</span>)</span><br><span class="line"><span class="comment">/*不能够用于位字段*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f2 : <span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f3 : <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(S.f1);</span><br></pre></td></tr></table></figure><p>了解 sizeof 操作符之后，现在来看下面的示例代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> arr[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    Init(a);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从表面看，上面代码的输出结果应该是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure><p>但实际结果却出乎我们的意料，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,-858993460,858993460,858993460,858993460,858993460,858993460,858993460,858993460</span><br></pre></td></tr></table></figure><p>是什么原因导致这个结果呢？</p><p> 很显然，上面的示例代码在“void Init(int arr[])”函数中接收了一个“int arr[]”类型的形参，并且在main函数中向它传递一个“a[10]”实参。同时，在 Init() 函数中通过“sizeof(arr)/sizeof(arr[0])”来确定这个数组元素的数量和初始化值。</p><p> 在这里出现了一个很大问题：<strong>由于 arr 参数是一个形参，它是一个指针类型，其结果是“sizeof(arr)=sizeof(int*)”</strong>。在 IA-32 中，“sizeof(arr)/sizeof(arr[0])”的结果为 1。因此，最后的结果出现异常</p><p>对于上面的示例代码，我们可以通过传入数组的长度的方式来解决这个问题，示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">oid <span class="title function_">Init</span><span class="params">(<span class="type">int</span> arr[],<span class="type">size_t</span> arr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr_len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    Init(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们还可以通过指针的方式来解决上面的问题，示例代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">10</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="keyword">sizeof</span>(*arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*arr)[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    Init(&amp;a);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，Init() 函数中的 arr 参数是一个指向“arr[10]”类型的指针。<strong>需要特别注意的是，这里绝对不能够使用“void Init(int(<em>arr)[])”来声明函数，而是必须指明要传入的数组的大小，否则“sizeof(</em>arr)”无法计算</strong>。但是在这种情况下，再通过 sizeof 来计算数组大小已经没有意义了，因为此时数组大小已经指定为 10 了。</p><h2 id="2-指针"><a href="#2-指针" class="headerlink" title="2. 指针"></a>2. 指针</h2><p><strong>什么是指针？</strong></p><p>指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type *var_name;</span><br></pre></td></tr></table></figure><p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C 数据类型，<strong>var_name</strong> 是指针变量的名称。用来声明指针的星号 <strong>*</strong> 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure><p><strong>如何使用指针？</strong></p><p>使用指针时会频繁进行以下几个操作：</p><ul><li><strong>定义一个指针变量</strong></li><li><strong>把变量地址赋值给指针</strong></li><li><strong>访问指针变量中可用地址的值</strong></li></ul><p>这些是通过使用一元运算符 <strong>*</strong> 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="type">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line">    </span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var 变量的地址: %p\n&quot;</span>, &amp;var  );</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ip 变量存储的地址: %p\n&quot;</span>, ip );</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var 变量的地址: <span class="number">0x7ffeeef168d8</span></span><br><span class="line">ip 变量存储的地址: <span class="number">0x7ffeeef168d8</span></span><br><span class="line">*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure><p><strong>C 中的 NULL 指针</strong></p><p>变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span>  *ptr = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ptr 的地址是 %p\n&quot;</span>, ptr  );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr 的地址是 <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p><p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr)     <span class="comment">/* 如果 p 非空，则完成 */</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)    <span class="comment">/* 如果 p 为空，则完成 */</span></span><br></pre></td></tr></table></figure><h3 id="2-1-函数指针"><a href="#2-1-函数指针" class="headerlink" title="2.1 函数指针"></a>2.1 函数指针</h3><p>所谓的函数指针即定义一个指向函数的指针变量，定义的格式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> x, <span class="type">int</span> y));<span class="comment">//注意：这里的括号不能拿掉，因为括号()的运算优先级比*高</span></span><br></pre></td></tr></table></figure><p>这个函数的类型是有两个整型参数，返回值是个整型。对应的函数指针类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*)(<span class="type">int</span> a, <span class="type">int</span> b);</span><br></pre></td></tr></table></figure><p>对应的函数指针定义:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> a, <span class="type">int</span> b); <span class="comment">//参数名可以去掉，并且通常都是去掉的，这样指针p就可以保存函数类型为两个整型参数，返回值是整型的函数地址了</span></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>我们一般可以这么使用，通过函数指针调用函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a:b</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span> ,<span class="type">int</span>) = <span class="literal">NULL</span>;</span><br><span class="line">p = maxValue;</span><br><span class="line">p(<span class="number">20</span>,<span class="number">45</span>);<span class="comment">//通过指针调用</span></span><br></pre></td></tr></table></figure><h3 id="2-2-指针函数"><a href="#2-2-指针函数" class="headerlink" title="2.2 指针函数"></a>2.2 指针函数</h3><p>指针函数：指的是函数的返回值是一个指针，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">p</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 注意这里的*和p之间是没有括号的，所以含义是函数p(int,int)会返回一个(int *)指针</span></span><br></pre></td></tr></table></figure><p>当然，函数本身也可能返回一个函数指针，后面会说到。</p><h3 id="2-3-常量指针"><a href="#2-3-常量指针" class="headerlink" title="2.3 常量指针"></a>2.3 常量指针</h3><p><strong>如果在定义指针变量的时候，数据类型前用const修饰，被定义的指针变量就是指向常量的指针变量</strong>，指向常量的指针变量称为常量指针，格式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p = &amp;a;</span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a，b；</span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> *p=&amp;a <span class="comment">//常量指针</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作错误</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作成功</span></span><br></pre></td></tr></table></figure><p><strong>因为常量指针本质是指针，并且这个指针是一个指向常量的指针，<u>指针指向的变量的值不可通过该指针修改，但是指针指向的值可以改变</u></strong>。</p><p>如上示例中定义了一个常量指针<code>*p</code>，并且初始化时指向变量<code>a</code>的地址，这时，变量<code>a</code>的值就不能通过指针<code>p</code>修改，所以<code>*p=9;</code>操作错误，但是我们可以让常量指针<code>p</code>指向其他变量地址，就像上面示例中的<code>p=&amp;b</code>，将指针<code>p</code>指向了变量<code>b</code>的地址。</p><h3 id="2-4-指针常量"><a href="#2-4-指针常量" class="headerlink" title="2.4 指针常量"></a>2.4 指针常量</h3><p>指针常量：顾名思义它就是一个常量，但是是<strong>指针修饰的</strong>。</p><p>格式为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p <span class="comment">//指针常量</span></span><br></pre></td></tr></table></figure><p>在这个例子下定义以下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p=&amp;a <span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//那么分为一下两种操作</span></span><br><span class="line">*p=<span class="number">9</span>;<span class="comment">//操作成功</span></span><br><span class="line">p=&amp;b;<span class="comment">//操作错误</span></span><br></pre></td></tr></table></figure><p>因为声明了指针常量，说明指针变量不允许修改。即<strong><u>指针指向一个地址该地址不能被修改，但是该地址里的内容可以被修改</u></strong>。</p><p>如上示例中，定义了一个指针常量<code>p</code>，并且指向了变量<code>a</code>的地址，这样指针常量指向的地址只能为<code>a</code>的地址，不能改变，但是可以通过指针常量<code>p</code>修改变量<code>a</code>地址内的值，所以<code>*p=9</code>操作成功，<code>p=&amp;b</code>操作错误。</p><p><strong>总结如下</strong>：</p><div class="table-container"><table><thead><tr><th>名称</th><th>含义</th><th>定义形式</th><th>指针p的类型</th></tr></thead><tbody><tr><td>变量指针</td><td>指向变量的指针</td><td>int <em>p =&a;<br>int  (</em>p) = &a;</td><td>int *</td></tr><tr><td>常量指针</td><td>指向常量的指针</td><td>int const <em>p = &amp;a<br>const int </em>p = &amp;a</td><td>int const *</td></tr><tr><td>指针常量</td><td>用指针修饰的常量</td><td>int * const p</td><td>int * const</td></tr><tr><td>一维数组指针</td><td>指向一维数组的指针</td><td>int *p = a</td><td>int *</td></tr><tr><td>二维数组指针</td><td>指向二维数组(第一行整体是首元素的指针)</td><td>int (*p)[4] = a</td><td>int (*)[4]</td></tr><tr><td>函数指针</td><td>指向函数的指针</td><td>int (*p)(int a,int b) = add</td><td>int (*)(int,int)</td></tr><tr><td>指针函数</td><td>函数的返回值是一个指针类型</td><td>int *p(int a, int b){}</td><td>int *(int a, int b){}</td></tr></tbody></table></div><h2 id="3-基础知识"><a href="#3-基础知识" class="headerlink" title="3. 基础知识"></a>3. 基础知识</h2><h3 id="3-1-堆栈概念"><a href="#3-1-堆栈概念" class="headerlink" title="3.1 堆栈概念"></a>3.1 堆栈概念</h3><p><strong><u>堆栈（stack) 是一种先进后出的、操作受限的线性表，也可以直接称为 栈。</u></strong></p><p><strong>堆栈（英语：stack）</strong>，是计算机科学中一种特殊的<strong>串列形式的抽象数据类型</strong>，<strong>其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算</strong>。另外堆栈也可以用一维数组或链表的形式来完成。堆栈的另外一个相对的操作方式称为队列。需要记住的是，<strong>堆：顺序随意，栈：后进先出(Last-In/First-Out)</strong>。</p><p><strong>堆（英语：Heap）</strong>，是计算机科学中的一种特别的<strong>树状数据结构</strong>。通常是一个可以被看做一棵树的数组对象。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的父节点，那么 P 的值会小于等于（或大于等于） C 的值”。若父节点的值恒小于等于子节点的值，此堆称为最小堆（英语：min heap）；反之，若父节点的值恒大于等于子节点的值，此堆称为最大堆（英语：max heap）。在堆中最顶端的那一个节点，称作根节点（英语：root node），根节点本身没有父节点（英语：parent node）。</p><p><strong>栈（stack）又名堆栈</strong>，它是一种运算受限的线性表。其限制是<strong>仅允许在表的一端进行插入和删除运算。这一端被称为栈顶</strong>，相对地，把另一端称为栈底。<strong>栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来（先进后出）</strong>。</p><p><strong>其实堆栈本身就是栈</strong>，只是换了个抽象的名字。其特性是： 最后一个放入堆栈中的物体总是被最先拿出来，这个特性通常称为后进先出(LIFO)队列。堆栈中定义了一些操作。 两个最重要就是上述提到的PUSH和POP。PUSH操作在堆栈的顶部加入一个元素，POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。</p><p><strong>程序内存分区中的堆与栈</strong></p><hr><ul><li><p>栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等</p></li><li><p>堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表</p></li></ul><h3 id="3-2-volatile的作用"><a href="#3-2-volatile的作用" class="headerlink" title="3.2 volatile的作用"></a>3.2 volatile的作用</h3><p>volatile 关键字是一种类型修饰符，用它声明的类型变量<strong>表示可以被某些编译器未知的因素更改</strong>，遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化</strong>，从而可以提供对特殊地址的稳定访问。<strong>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据</strong>。而且读取的数据立刻被保存。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></span><br><span class="line"><span class="type">int</span> b = i;</span><br></pre></td></tr></table></figure><p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 <strong>volatile 可以保证对特殊地址的稳定访问</strong>。</p><p>一般说来，volatile用在如下的几个地方：</p><ul><li><p>中断服务程序中修改的供其它程序检测的变量需要加 volatile；</p></li><li><p>多任务环境下各任务间共享的标志应该加 volatile；</p></li><li><p>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；</p></li></ul><h3 id="3-3-局部变量和全局变量"><a href="#3-3-局部变量和全局变量" class="headerlink" title="3.3 局部变量和全局变量"></a>3.3 局部变量和全局变量</h3><p><strong>1. 局部变量</strong></p><hr><p>定义在函数内部的变量称为<strong>局部变量（Local Variable）</strong>，它的作用域仅限于函数内部， 离开该函数后就是无效的，再使用就会报错。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> b,c;  <span class="comment">//a,b,c仅在函数f1()内有效</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;  <span class="comment">//m,n仅在函数main()内有效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几点说明：</p><p>1）  在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数中定义的变量。main 函数也是一个函数，与其它函数地位平等。</p><p>2） 形参变量、在函数体内定义的变量都是局部变量。实参给形参传值的过程也就是给局部变量赋值的过程。</p><p>3） 可以在不同的函数中使用相同的变量名，它们表示不同的数据，分配不同的内存，互不干扰，也不会发生混淆。</p><p>4） 在语句块中也可定义变量，它的作用域只限于当前语句块。</p><p><strong>2. 全局变量</strong></p><hr><p>在所有函数外部定义的变量称为<strong>全局变量（Global Variable）</strong>，它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;  <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> x,y;  <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a、b、x、y 都是在函数外部定义的全局变量。C语言代码是从前往后依次执行的，由于 x、y 定义在函数 func1() 之后，所以在 func1() 内无效；而 a、b 定义在源程序的开头，所以在 func1()、func2() 和 main() 内都有效。</p><h3 id="3-4-static-用法举例"><a href="#3-4-static-用法举例" class="headerlink" title="3.4 static 用法举例"></a>3.4 static 用法举例</h3><p><strong>（1）局部变量中static的用法</strong></p><hr><ul><li><p><strong>普通局部变量存储于进程栈空间，使用完毕会立即释放</strong>。</p></li><li><p><strong>静态局部变量使用static修饰符定义</strong>，即使在声明时未赋初值，编译器也会把它初始化为0。且<strong>静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变</strong>。</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n=%d\n&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n++=%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn_static</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;static n=%d\n&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n++=%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">    fn_static();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">    fn_static();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n=<span class="number">10</span></span><br><span class="line">n++=<span class="number">11</span></span><br><span class="line">--------------------</span><br><span class="line"><span class="type">static</span> n=<span class="number">10</span></span><br><span class="line">n++=<span class="number">11</span></span><br><span class="line">--------------------</span><br><span class="line">n=<span class="number">10</span></span><br><span class="line">n++=<span class="number">11</span></span><br><span class="line">--------------------</span><br><span class="line"><span class="type">static</span> n=<span class="number">11</span></span><br><span class="line">n++=<span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>（2）全局变量中static的用法</strong></p><hr><ul><li><p>全局变量定义在函数体外部，在全局数据区分配存储空间，且编译器会自动对其初始化<strong>。普通全局变量对整个工程可见</strong>，其他文件可以使用extern外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量）。</p></li><li><p><strong>静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。</strong></p></li></ul><p>在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。</p><p><strong>（3）函数中static的用法</strong></p><hr><p>函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。其特性如下：</p><ul><li><strong>静态函数只能在声明它的文件中可见，其他文件不能引用该函数</strong></li><li><strong>不同的文件可以使用相同名字的静态函数，互不影响</strong></li></ul><p>非静态函数可以在另一个文件中直接引用，甚至不必使用extern声明。</p><h3 id="3-5-inline-和宏的区别"><a href="#3-5-inline-和宏的区别" class="headerlink" title="3.5 inline 和宏的区别"></a>3.5 inline 和宏的区别</h3><p><strong>宏定义</strong>使用预处理器实现，做一些简单的字符替换因此不能进行参数有效性的检测。另外它的返回值不能被强制转换为可转换的合适类型</p><p><strong>inline函数</strong>代码是被放到符号表中，使用时像宏一样展开，没有调用的开销效率很高；inline函数是真正的函数，所以要进行一系列的数据类型检查；</p><p><strong>区别</strong></p><ul><li><p>宏定义不会进行类型的判断，只是单存的替换文本；inline会对参数类型进行判断。</p></li><li><p>宏不是函数，inline修饰的是函数。</p></li><li><p>宏返回值不能强制转换成合适的类型，inline返回值可以。</p></li></ul><h3 id="3-6-enum字宽"><a href="#3-6-enum字宽" class="headerlink" title="3.6 enum字宽"></a>3.6 enum字宽</h3><h2 id="4-1-通讯基础"><a href="#4-1-通讯基础" class="headerlink" title="4.1 通讯基础"></a>4.1 通讯基础</h2><p><strong>差分通讯原理概述</strong></p><p>差分传输是一种信号传输的技术，区别于传统的一根信号线一根地线的做法，差分传输在这两根线上都传输信号，这两个信号的振幅相等，相位相反。在这两根线上传输的信号就是差分信号。</p><p>所谓差分方式传输，就是发送端在两条信号线上传输幅值相等相位相反的电信号，接收端对接受的两条线信号作减法运算，这样获得幅值翻倍的信号。其抗干扰的原理是：假如两条信号线都受到了同样（同相、等幅）的干扰信号，由于接受端对接受的两条线的信号作减法运算，因此干扰信号被 基本抵消，那么怎样才能保证两条信号线受到的干扰信号尽量是同相、等幅的呢？办法之一那就要将两根线扭在一起，按照电磁学的原理分析出：可以近似地认为两条信号线受到的干扰信号是同相、等幅的。</p><p>发送端将信号调制成为对称的信号用双线发送，称为平衡发送；发送如采用单线（对应有参考电平），称为非平衡发送；接收端采用对称接收称为平衡接收；接收端采用非对称接收（单线接收对应一个基准电平）称接收为非平衡接收。例如差动电路就是一种平衡方式。</p><p>RS-232采取不平衡传输方式，即所谓单端通讯。收、发端的数据信号是相对于信号地。典型的RS-232信号在正负电平之间摆动，在发送数据时，发送端驱动器输出正电平在+5~+15V，负电平在-5~-15V电平。当无数据传输时，线上为TTL，从开始传送数据到结束，线上电平从TTL电平到RS-232电平再返回TTL电平。接收器典型的工作电平在+3~+12V与-3~-12V。由于发送电平与接收电平的差仅为2V至3V左右，所以其共模抑制能力差，再加上双绞线上的分布电容，其传送距离最大为约15米，最高速率为20Kbps。RS-232是为点对点（即只用一对收、发设备）通讯而设计的，其驱动器负载为3kΩ~7kΩ。所以RS-232适合本地设备之间的通信。</p><p>S-422、RS-485与RS-232不一样，数据信号采用差分传输方式，也称作平衡传输，它使用一对双绞线，将其中一线定义为A，另一线定义为B。通常情况下，发送驱动器A、B之间的正电平在+2 ~ +6V，是一个逻辑状态，负电平在-2V~6V，是另一个逻辑状态。另有一个信号地C，在RS-485中还有一“使能”端，而在RS-422中这是可用可不用的。“使能”端是用于控制发送驱动器与传输线的切断与连接。当“使能”端起作用时，发送驱动器处于高阻状态，称作“第三态”，即它是有别于逻辑“1”与“0”的第三态。 </p><p><strong>常用的通讯接口概述</strong></p><p>// <em>To Do</em></p><h2 id="4-2-I2C"><a href="#4-2-I2C" class="headerlink" title="4.2 I2C"></a>4.2 I2C</h2><h3 id="I2C优缺点"><a href="#I2C优缺点" class="headerlink" title="I2C优缺点"></a>I2C优缺点</h3><p>I2C通信传输速度快、传输方式简单灵活，主要具有以下<strong>优点</strong>：</p><ul><li><strong>节省引脚资源</strong>：由于只需要SCL和SDA两根线，因此I2C通信相对于其他通信接口而言，可以节省引脚资源。</li><li><strong>简单灵活</strong>：I2C通信具有简单的传输方式和灵活的应用场景，可以适应不同设备之间的通信需求。</li><li><strong>速度较快</strong>：I2C通信可以实现高速数据传输，一般可以达到400KHz的传输速度。</li></ul><p>I2C通信同样存在一些<strong>缺点：</strong></p><ul><li><strong>通信距离有限</strong>：由于I2C通信使用的是电平信号传输，其传输距离受限于电平信号的衰减和噪声干扰。一般来说，传输距离不宜过长。</li><li><strong>网络拓扑结构限制</strong>：需要主设备进行总线管理，因此网络拓扑结构受到一定限制，主设备数量和总线长度都有一定的要求。</li><li><strong>单主设备</strong>：一般情况下，I2C通信只支持一主多从的连接方式。</li></ul><h3 id="I2C速度范围"><a href="#I2C速度范围" class="headerlink" title="I2C速度范围"></a>I2C速度范围</h3><div class="table-container"><table><thead><tr><th>速度模式</th><th>最高比特率（bit/s）</th><th>备注</th></tr></thead><tbody><tr><td>标准模式</td><td>100K</td><td>双向传输，高速模式兼容低速模式</td></tr><tr><td>快速模式</td><td>400K</td><td>双向传输，高速模式兼容低速模式</td></tr><tr><td>快速模式增强</td><td>1M</td><td>双向传输，高速模式兼容低速模式</td></tr><tr><td>高速模式</td><td>3.4M</td><td>双向传输，高速模式兼容低速模式</td></tr><tr><td>超快速模式</td><td>5M</td><td>单向传输，不兼容其他模式</td></tr></tbody></table></div><h3 id="I2C时序逻辑"><a href="#I2C时序逻辑" class="headerlink" title="I2C时序逻辑"></a>I2C时序逻辑</h3><p>I2C通信总是由主机启动，<strong>每个通信过程由起始信号开始，由停止信号结束</strong>。一个数据包由8位，每个数据包后有一个应答位(ACk)或者非应答位(NACK)。例如，主设备向从设备发送1字节数据的时序图如下：</p><p><img src="I2C传输1字节的时序图.png" alt="I2C传输1字节的时序图"></p><ul><li>起始位：<strong>当SCL为高电平时，SDA的下降沿就是起始位</strong>，是启动一次I2C通信的起始信号。</li><li>停止位：<strong>当SCL为高电平时，SDA的上升沿就是停止位</strong>，是停止一次I2C通信的结束信号。</li><li>数据位：在SCL的一个时钟周期内传输一个数据位，<strong>当SCL位低电平时，发送设备更新SDA的电平，当SCL位高电平时，接收数据读取SDA的电平就是有效的一位数据。</strong></li><li>数据包：<strong>I2C数据通信一个数据包总是8位</strong>，也就是1个字节的数据。</li><li>应答信号：在发送完8位数据包之后，发送设备在第9个SCL时钟周期采集接收设备的应答信号。<strong>若在SCL的第9个周期采集的SDA为低电平，就是应答信号ACK，如果采集的SDA是高电平，就是非应答信号NACK。</strong></li></ul><h3 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h3><p><img src="7Bit设备的数据传输.png" alt="7Bit设备的数据传输"></p><p>在I2C通信之中，在起始信号后的首字节由7位从机地址和1位读写位组成，结构如下：</p><p><img src="I2C从机地址结构.png" alt="I2C从机地址结构"></p><p>发送完这个字节之后，主机释放SDA总线等待从机给出ACK应答。如果从机给出了ACK应答，表示从机地址正确（有从机响应）并且已知晓是读还是写，便可以开始读写数据。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由master来决定如何处理（STOP或ReSTART）。</p><p><strong>1、主机写-从机接收</strong></p><p>主机对从机发送数据时，主机对从机发送一个开始字节，然后即可一直发送数据。以示例来讲解，其第一帧数据为要操作的寄存器地址，所以为：“<strong>[1-Byte]开始字节(写) + [1-Byte]寄存器地址 + [1-Byte]寄存器数据</strong>”。</p><p><img src="I2C向一个寄存器写入数据.png" alt="I2C向一个寄存器写入数据"></p><p><strong>2、主机读-从机发送</strong></p><p><strong>主机对向从机读取数据时，方式同发送数据有所不同，要多一次通信过程</strong>。主机需要先向从机发送一次信号，告诉从机”我要读取数据“，然后重开一次通信，等待从机主动返回数据。以示例来讲解，发送 “<strong>[1-Byte]开始字节(写) + [1-Byte]要读取的寄存器的地址</strong>”，之后结束通信，或者重开始，来进入到第二次通信中，<strong>先发送 [1-Byte]开始字节(读)</strong>，<strong>然后等待读取从机发送过来的 [1-Byte]数据即可</strong>。</p><p><img src="I2C读取一个寄存器的数据.png" alt="I2C读取一个寄存器的数据"></p><h2 id="4-3-串口"><a href="#4-3-串口" class="headerlink" title="4.3 串口"></a>4.3 串口</h2><h3 id="串口通信参数配置"><a href="#串口通信参数配置" class="headerlink" title="串口通信参数配置"></a>串口通信参数配置</h3><p>为了正确实现串口间的通信，必须对串口的参数进行设置，主要需要配置的参数如下：</p><ul><li><strong>波特率</strong>：该参数表示每秒传输的比特数。</li><li><strong>数据位</strong>：表示通信中实际数据位的参数。</li><li><strong>奇偶校验位</strong>：该位用于串口通信中的简单检错。奇偶校验位主要有：偶校验、奇校验、标记、<strong>空格的方式</strong>，也可以不使用校验。<strong>奇/偶校验是通过统计数据中高位或低位的个数来实现校验的</strong>。而<strong>标记、空格并不真正检测数据</strong>，<strong>只是通过简单的置位来实现对数据的检测</strong>。通过置位方式，可以判断出是否存在噪声干扰数据通信或数据传输，以及接收是否存在不同步的现象。</li><li><strong>停止位</strong>：停止位用于标志该数据包数据结束。可以取1位、1.5位或2位，<strong>停止位不仅仅用于数据包的传输结束标志，还提供了计算机之间校正同步时钟的机会</strong>。用于停止位的位数越多，不同时钟同步的容忍程度越大。但是由于停止位占用了数据空间，<strong>过多的停止位将导致数据传输速度的下降</strong>。</li></ul><h3 id="串口通信协议"><a href="#串口通信协议" class="headerlink" title="串口通信协议"></a>串口通信协议</h3><p>串行通信协议包括：<strong>系统间协议</strong>和<strong>内部系统协议</strong>。</p><p><strong>1、系统间协议</strong>：用于通信两个不同设备的系统间协议。就像计算机与微控制器套件之间的通信一样。通过内部总线系统进行通信。<strong>常见的有UART协议、USART协议、USB协议</strong>。</p><ul><li><strong>UART协议</strong>：UART代表通用<strong>异步发送器和接收器</strong>。<strong>UART协议是具有两个有线协议的串口通信。</strong>数据电缆信号线标记为Rx和Tx。串口通信通常用于发送和接收信号。它被传输并与串口通信接收数据，而<strong>没有类脉冲</strong>。<strong>UART接收数据字节并按顺序发送各个位</strong>。<strong>UART是半双工协议</strong>。<u>半双工意味着具有传输和接收数据的功能，但不能同时进行</u>。</li><li><strong>USART协议</strong>：USART代表通用的<strong>同步和异步发送器和接收器</strong>。<strong>它是两线协议的串口通信</strong>。数据电缆信号线标记为Rx和TX。该协议用于逐字节发送和接收数据以及时钟脉冲。<strong>这是一种全双工协议</strong>，<u>意味着同时以不同的板速发送和接收数据</u>。</li><li><strong>USB协议</strong>：USB代表<strong>通用串行总线</strong>。同样，<strong>它是两线协议的串行通信。</strong>数据电缆信号线标记为D +和D-。此协议用于与系统外围设备进行通信。USB以不同的模式传输数据。第一个是<strong>10 Kbps至100 Kbps的慢速模式</strong>；<strong>第二个是全速模式500Kbps至10Mbps</strong>，<strong>高速模式25Mbps至400Mbps</strong>。</li></ul><p><strong>2、内部系统协议</strong>：内部系统协议用于通信电路板上的两个设备。<strong>常见的有I2C协议、SPI协议、CAN协议</strong>。</p><h3 id="串口通信物理接口"><a href="#串口通信物理接口" class="headerlink" title="串口通信物理接口"></a>串口通信物理接口</h3><p>常见的串口通信物理接口有<strong>TTL，RS232，RS485等，都是一种逻辑电平的表示方式</strong>。</p><p><strong>TTL：</strong>TTL指<strong>双极型三极管逻辑电路</strong>，市面上很多“USB转TTL”模块，实际上是“USB转TTL电平的串口”模块。这种信号0对应0V，1对应3.3V或者5V；TTL电平：<strong>全双工</strong>（逻辑1: 2.4V—5V 逻辑0: 0V—0.5V）。</p><p><strong>RS232：</strong>是电子工业协会(Electronic Industries Association，EIA) 制定的异步传输标准接口，同时对应着电平标准和通信协议（时序），其电平标准：<strong>+3V～+15V对应0，-3V～-15V对应1</strong>。RS232 的逻辑电平和TTL 不一样但是协议一样。RS-232电平：<strong>全双工</strong>（逻辑1：-15V—5V 逻辑0：+3V—+15V）。</p><p><strong>RS485：</strong>RS485是一种串口接口标准，为了长距离传输采用差分方式传输，传输的是差分信号，抗干扰能力比RS232强很多。<strong>两线压差为-(2 ~ 6)V表示0，两线压差为+(2 ~ 6)V表示1</strong>。RS-485：<strong>半双工</strong>（逻辑1：+2V—+6V 逻辑0： -6V—-2V）这里的电平指AB 两线间的电压差。</p><h2 id="4-4-SPI"><a href="#4-4-SPI" class="headerlink" title="4.4 SPI"></a>4.4 SPI</h2><h3 id="SPI优缺点"><a href="#SPI优缺点" class="headerlink" title="SPI优缺点"></a>SPI优缺点</h3><p><strong>优点</strong>：</p><ul><li>支持全双工操作</li><li>操作简单，没有复杂的从机寻址系统</li><li>数据传输速率较高</li><li>没有启动和停止位，因此数据可以连续流式传输而不会中断</li></ul><p><strong>缺点</strong>：</p><ul><li>占用IO口较多，需要4根线，如果需要多个从机，还需要额外加1个片选。</li><li>没有应答机制确认是否接收到数据</li><li>没有错误检查，如UART中的奇偶校验位</li><li>只支持一主多从</li></ul><h3 id="SPI通信基本原理"><a href="#SPI通信基本原理" class="headerlink" title="SPI通信基本原理"></a>SPI通信基本原理</h3><p>SPI接口一般使用四条信号线通信：<strong>SDI（数据输入），SDO（数据输出），SCK（时钟），CS（片选）</strong></p><p>SPI是一个同步的数据总线，也就是说它用<strong>单独的数据线</strong>和一个<strong>单独的时钟信号</strong>来保证<strong>发送端和接收端的完美同步</strong>。</p><p><strong>时钟是一个振荡信号，它高速接收端在确切的时机对数据线上的信号进行采样</strong>。</p><p>产生时钟的一侧称为<strong>主机</strong>，另一侧称为<strong>从机</strong>。<strong>SPI中总是只有一个主机，但是可以有多个从机</strong>，数据的采集时机可能时<strong>时钟信号的上升沿或下降沿</strong>（具体要看SPI的配置）。</p><p>SPI通信有4种不同的模式，不同的从设备可能在出厂是就是配置为某种模式，这是不能改变的；但我们的通信双方必须是工作在同一模式下，所以我们可以对我们的主设备的SPI模式进行配置，<strong>通过CPOL（时钟极性）和CPHA（时钟相位）来控制我们主设备的通信模式</strong>，具体如下:</p><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">CPOL（时钟极性）</th><th style="text-align:center">CPHA（时钟相位）</th></tr></thead><tbody><tr><td style="text-align:center">MODE0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MODE1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">MODE2</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MODE3</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p><strong>时钟极性CPOL是用来配置SCLK的电平出于哪种状态时是空闲态或者有效态，时钟相位CPHA是用来配置数据采样是在第几个边沿</strong>:</p><ul><li><strong>CPOL=0，表示当SCLK=0时处于空闲态，所以有效状态就是SCLK处于高电平时</strong>；</li><li><strong>CPOL=1，表示当SCLK=1时处于空闲态，所以有效状态就是SCLK处于低电平时</strong>；</li><li><strong>CPHA=0，表示数据采样是在第1个边沿，数据发送在第2个边沿</strong>；</li><li><strong>CPHA=1，表示数据采样是在第2个边沿，数据发送在第1个边沿</strong>;</li></ul><p>对于SPI的四种通讯模式，总结起来，就是：</p><ul><li><p>CPOL=0，CPHA=0：此时空闲态时，SCLK处于低电平，数据采样是在第1个边沿，也就是SCLK由低电平到高电平的跳变，所以数据采样是在上升沿；</p></li><li><p>CPOL=0，CPHA=1：此时空闲态时，SCLK处于低电平，数据发送是在第1个边沿，也就是SCLK由低电平到高电平的跳变，所以数据采样是在下降沿；</p></li><li>CPOL=1，CPHA=0：此时空闲态时，SCLK处于高电平，数据采集是在第1个边沿，也就是SCLK由高电平到低电平的跳变，所以数据采集是在下降沿；</li><li>CPOL=1，CPHA=1：此时空闲态时，SCLK处于高电平，数据发送是在第1个边沿，也就是SCLK由高电平到低电平的跳变，所以数据采集是在上升沿。</li></ul><p>以MODE3为例，主设备对从设备的读写数据时序如下：</p><p><img src="SPI读写时序.png" alt="SPI读写时序"></p><p>在SPI中，主机和从机都有一个<strong>串行移位寄存器</strong>，<u>主机通过向它的SPI串行寄存器写入一个字节来发起一次传输</u>；</p><p>串行移位寄存器通过MOSI信号线将字节传送给从机，同时从机也将自己的串行移位寄存器中的内容通过MISO信号线返回给主机。这样，两个移位寄存器中的内容就被交换；</p><p><strong>外设的写操作和读操作是同步完成的</strong>。<u>如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输</u>。</p><p><strong>SPI整体的传输大概可以分为以下几个过程：</strong></p><ul><li><strong>主机首先拉低对应从机CS（片选）信号线，表示与该从机进行通信</strong>。</li><li><strong>主机通过发送SCLK时钟信号，来告诉从机写数据或者读数据</strong>。</li><li><strong>主机将要发送的数据写到发送<u>数据缓存区</u>，缓存区经过移位寄存器(0~7)，串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区</strong>。</li><li><strong>从机也将自己的串行移位寄存器(0~7)中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换</strong>。</li></ul><p><img src="SPI数据传输.png" alt="SPI数据传输"></p><h2 id="4-5-CAN"><a href="#4-5-CAN" class="headerlink" title="4.5 CAN"></a>4.5 CAN</h2><h3 id="CAN优缺点"><a href="#CAN优缺点" class="headerlink" title="CAN优缺点"></a>CAN优缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>高速传输</strong>：<strong>CAN总线的传输速度可以达到1Mbps</strong>。</li><li><strong>多设备连接</strong>：<strong>它是一种多主总线，即每个节点机均可成为主机，且节点机之间也可进行通信</strong></li><li><strong>抗干扰性强</strong>：<strong>CAN总线采用差分信号传输</strong>，<strong>抗干扰性能强，适用于工业环境</strong></li><li><strong>可靠性高</strong>：<strong>CAN总线采用了冗余校验和错误重传机制，保证了数据传输的可靠性</strong></li></ul><p><strong>缺点</strong>：</p><ul><li><strong>成本高</strong>：<strong>CAN总线需要专门的控制器和收发器，成本较高</strong></li><li><strong>配置复杂</strong>：<strong>CAN总线需要进行配置和初始化</strong>，<strong>对于初学者来说比较复杂</strong></li></ul><h3 id="CAN通讯基本原理"><a href="#CAN通讯基本原理" class="headerlink" title="CAN通讯基本原理"></a>CAN通讯基本原理</h3><ul><li><strong>以广播的形式发送报文</strong>。当CAN总线上的某个节点需要给其他节点发送消息时，会<strong>以广播的形式发送给总线上所有的节点</strong>，所以总线上的节点不适用地址来进行配置CAN系统，而是根据报文的开头的11位标识符决定是否要接受其他节点发来的报文。</li><li>每个节点都有自己的处理器和CAN总线接口控制器；</li><li>当一个节点需要发送数据到另一个节点时，自身节点的处理器需要将<strong>要发送的数据</strong>和自己的<strong>标识符</strong>传给自身的总线控制接口，处于准备状态；当获取到总线的使用权后，将数据和标识符组装成报文，将报文以一定格式发出，此时其他的节点处于接收状态。至于其他节点是否接收，由其他节点决定，是都会对某些报文进行过滤。</li><li>当新增的节点仅仅是纯粹的数据接收设备时，只需要该设备直接从总线上接收数据即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件开发 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS学习笔记</title>
      <link href="/2023/08/16/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/16/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS学习笔记"><a href="#FreeRTOS学习笔记" class="headerlink" title="FreeRTOS学习笔记"></a>FreeRTOS学习笔记</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>FreeRTOS</strong> 是一个 RTOS 类的嵌入式实时操作系统。它的社会占有量很高，许多半导体厂商产品的 SDK 包就使用 FreeRTOS 作为其操作系统，尤其是 WIFI、蓝牙这些带协议栈的芯片或模块。</p><p><strong>FreeRTOS 的内核支持抢占式， 合作式和时间片调度。</strong>任务与任务、 任务与中断之间可以使用<strong>任务通知、消息队列、二值信号量、数值型信号量、 递归互斥信号量和互斥信号量进行通信和同步</strong>。</p><h3 id="1-1-任务"><a href="#1-1-任务" class="headerlink" title="1.1 任务"></a>1.1 任务</h3><p><strong>RTOS 系统的核心就是任务管理， FreeRTOS 是一个抢占式的实时多任务系统</strong>， 其任务调度器也是<strong>抢占式</strong>的。<strong>高优先级的任务可以打断低优先级任务的运行</strong>而取得 CPU 的使用权，这样就保证了那些紧急任务的运行。 这样我们就可以为那些对实时性要求高的任务设置一个很高的优先级。 高优先级的任务执行完成以后重新把 CPU 的使用权归还给低优先级的任务，这个就是抢占式多任务系统的基本原理。</p><p><strong>在使用 RTOS 的时候一个实时应用可以作为一个独立的任务</strong>。每个任务都有自己的运行环境， 不依赖于系统中其他的任务或者 RTOS 调度器。 <strong>任何一个时间点只能有一个任务运行，具体运行哪个任务是由 RTOS 调度器来决定的</strong>， RTOS 调度器因此就会重复的开启、关闭每个任务。</p><p>任务不需要了解 RTOS 调度器的具体行为， RTOS 调度器的职责是确保当一个任务开始执行的时候其上下文环境(寄存器值，堆栈内容等)和任务上一次退出的时候相同。 为了做到这一点，<strong>每个任务都必须有个堆栈，当任务切换的时候将上下文环境保存在堆栈中</strong>，这样当任务再次执行的时候就可以从堆栈中取出上下文环境， 任务恢复运行。</p><h3 id="1-2-任务状态"><a href="#1-2-任务状态" class="headerlink" title="1.2 任务状态"></a>1.2 任务状态</h3><p><strong>FreeRTOS 中的任务永远处于下面几个状态中的某一个：</strong></p><ul><li><strong>运行态</strong><br>   当一个任务正在运行时， 那么就说这个任务处于运行态， 处于运行态的任务就是当前正在使用处理器的任务。 如果使用的是单核处理器的话那么不管在任何时刻永远都只有一个任务处于运行态。</li><li><strong>就绪态</strong><br>  处于就绪态的任务是那些已经准备就绪(这些任务没有被阻塞或者挂起)， 可以运行的任务，但是<strong>处于就绪态的任务还没有运行，因为有一个同优先级或者更高优先级的任务正在运行！</strong></li><li><strong>阻塞态</strong><br>  <strong>如果一个任务当前正在等待某个外部事件的话就说它处于阻塞态</strong>， 比如说如果某个任务调用了函数 vTaskDelay()的话就会进入阻塞态， 直到延时周期完成。<strong>任务在等待队列、信号量、事件组、通知或互斥信号量的时候也会进入阻塞态。</strong>任务进入阻塞态会有一个超时时间，当超过这个超时时间任务就会退出阻塞态，即使所等待的事件还没有来临！</li><li><strong>挂起态</strong><br>  像阻塞态一样，任务进入挂起态以后也不能被调度器调用进入运行态， 但是<strong>进入挂起态的任务没有超时时间</strong>。任务进入和退出挂起态通过调用函数 <code>vTaskSuspend()</code>和 <code>xTaskResume()</code>。</li></ul><h3 id="1-3-任务优先级"><a href="#1-3-任务优先级" class="headerlink" title="1.3 任务优先级"></a>1.3 任务优先级</h3><p>每 个 任 务 都 可 以 分 配 一 个 从 <code>0 ~ configMAX_PRIORITIES-1</code> 的 优 先 级 ，<code>configMAX_PRIORITIES</code>在文件<code>FreeRTOSConfig.h</code> 中有定义。</p><p>FreeRTOS 调度器确保处于就绪态或运行态的高优先级的任务获取处理器使用权，换句话说就是处于就绪态的最高优先级的任务才会运行。<strong>当宏<code>configUSE_TIME_SLICING</code>定义为 1 的时候多个任务可以共用一个优先级，数量不限</strong>。默认情况下宏<code>configUSE_TIME_SLICING</code>在文件<code>FreeRTOS.h</code>中已经定义为 1。此时处于就绪态的优先级相同的任务就会使用时间片轮转调度器获取运行时间。</p><h3 id="1-4-内核配置"><a href="#1-4-内核配置" class="headerlink" title="1.4 内核配置"></a>1.4 内核配置</h3><ul><li><strong>内核配置一</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">参数说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>USE_PREEMPTION</code></td><td style="text-align:center">定义调度器模式</td></tr><tr><td style="text-align:center"><code>CPU_CLOCK_HZ</code></td><td style="text-align:center">定义CPU的主频</td></tr><tr><td style="text-align:center"><code>TICK_RATE_HZ</code></td><td style="text-align:center">定义系统时钟节拍数</td></tr><tr><td style="text-align:center"><code>MAX_PRIORITIES</code></td><td style="text-align:center">定义可供用户使用的最大优先级数</td></tr><tr><td style="text-align:center"><code>MINIMAL_STACK_SIZE</code></td><td style="text-align:center">定义空闲任务的栈空间大小</td></tr><tr><td style="text-align:center"><code>MAX_TASK_NAME_LEN</code></td><td style="text-align:center">定义任务名最大的字符数</td></tr><tr><td style="text-align:center"><code>USE_16_BIT_TICKS</code></td><td style="text-align:center">系统时钟节拍计数使用TickType_t数据类型定义</td></tr><tr><td style="text-align:center"><code>IDLE_SHOULD_YIELD</code></td><td style="text-align:center">用于使能与空闲任务同优先级的任务</td></tr></tbody></table></div><ul><li><strong>内核配置二</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">参数说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>USE_MUTEXES</code></td><td style="text-align:center">用于使能互斥锁</td></tr><tr><td style="text-align:center"><code>USE_RECURSIVE_MUTEXES</code></td><td style="text-align:center">用于使能递归互斥锁</td></tr><tr><td style="text-align:center"><code>USE_COUNTING_SEMAPHORES</code></td><td style="text-align:center">用于使能计数信号量</td></tr><tr><td style="text-align:center"><code>QUEUE_REGISTRY_SIZE</code></td><td style="text-align:center">用于设置可以注册的信号量和消息队列个数</td></tr><tr><td style="text-align:center"><code>USE_APPLICATION_TASK_TAG</code></td><td style="text-align:center">用于使能任务标记</td></tr><tr><td style="text-align:center"><code>ENABLE_BACKWARD_COMPATIBILITY</code></td><td style="text-align:center">用于使能新版本对老版本的兼容特性</td></tr><tr><td style="text-align:center"><code>USE_PORT_OPTIMISED_TASK_SELECTION</code></td><td style="text-align:center">用于优化优先级列表中药执行的最高优先级任务的算法</td></tr><tr><td style="text-align:center"><code>USE_TICKLESS_IDLE</code></td><td style="text-align:center">用于使能tickless低功耗模式</td></tr><tr><td style="text-align:center"><code>USE_TASK_NOTIFICATIONS</code></td><td style="text-align:center">使能任务间直接的消息传递，包括信号量、事件标志组和消息邮箱</td></tr></tbody></table></div><ul><li><strong>内存管理</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">参数说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>MEMORY_ALLOCATION</code></td><td style="text-align:center">定义内存分配模式</td></tr><tr><td style="text-align:center"><code>TOTAL_HEAP_SIZE</code></td><td style="text-align:center">定义动态内存分配总长度</td></tr><tr><td style="text-align:center"><code>HEAP_NUMBER</code></td><td style="text-align:center">定义动态内存管理方式</td></tr></tbody></table></div><ul><li><strong>任务运行信息获取配置</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">参数说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>GENERATE_RUN_TIME_STATS</code></td><td style="text-align:center">用于使能任务运行状态参数统计</td></tr><tr><td style="text-align:center"><code>USE_TRACE_FACILITY</code></td><td style="text-align:center">使能此配置将添加额外的结构体成员和函数</td></tr><tr><td style="text-align:center"><code>USE_STATS_FORMATTING_FUNCTIONS</code></td><td style="text-align:center">用户配置宏定义<code>configUSE_TRACE_FACILITY</code> 和<code>configUSE_STATS_FORMATTING_FUNCTIONS</code>都为 1 的时候，将使能函数 <code>vTaskList()</code> 和 <code>vTaskGetRunTimeStats()</code>，如果两者中任何一个为 0，那么这两个函数都将被禁能</td></tr></tbody></table></div><ul><li><strong>软件定时器</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">参数说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>USE_TIMERS</code></td><td style="text-align:center">用于使能软件定时器</td></tr></tbody></table></div><ul><li><strong>中断优先级</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">参数说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>LIBRARY_LOWEST_INTERRUPT_PRIORITY</code></td><td style="text-align:center">用于配置 FreeRTOS 用到的 SysTick 中断和 PendSV 中断的优先级</td></tr><tr><td style="text-align:center"><code>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code></td><td style="text-align:center">定义了受 FreeRTOS 管理的最高优先级中断</td></tr></tbody></table></div><ul><li><strong>函数Include配置</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">参数说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>vTaskPrioritySet</code></td><td style="text-align:center">设置任务优先级</td></tr><tr><td style="text-align:center"><code>uxTaskPriorityGet</code></td><td style="text-align:center">获取任务优先级</td></tr><tr><td style="text-align:center"><code>vTaskDelete</code></td><td style="text-align:center">任务删除</td></tr><tr><td style="text-align:center"><code>vTaskCleanUpResources</code></td><td style="text-align:center">清理任务资源</td></tr><tr><td style="text-align:center"><code>vTaskSuspend</code></td><td style="text-align:center">任务挂起</td></tr><tr><td style="text-align:center"><code>vTaskDelayUntil</code></td><td style="text-align:center">任务绝对延时</td></tr><tr><td style="text-align:center"><code>vTaskDela</code></td><td style="text-align:center">任务延时</td></tr><tr><td style="text-align:center"><code>xTaskGetSchedulerState</code></td><td style="text-align:center">获取调度器状态</td></tr><tr><td style="text-align:center"><code>xTaskResumeFromISR</code></td><td style="text-align:center">在中断中恢复任务</td></tr><tr><td style="text-align:center"><code>xQueueGetMutexHolder</code></td><td style="text-align:center">获取互斥锁持有者</td></tr><tr><td style="text-align:center"><code>pcTaskGetTaskName</code></td><td style="text-align:center">获取任务名称</td></tr><tr><td style="text-align:center"><code>uxTaskGetStackHighWaterMark</code></td><td style="text-align:center">获取任务堆栈信息</td></tr><tr><td style="text-align:center"><code>xTaskGetCurrentTaskHandle</code></td><td style="text-align:center">获取当前任务句柄</td></tr><tr><td style="text-align:center"><code>eTaskGetState</code></td><td style="text-align:center">获取任务状态</td></tr><tr><td style="text-align:center"><code>xEventGroupSetBitFromISR</code></td><td style="text-align:center">在中断中设置事件标志组</td></tr><tr><td style="text-align:center"><code>xTimerPendFunctionCall</code></td><td style="text-align:center">定时器挂起后回调函数</td></tr><tr><td style="text-align:center"><code>xTaskAbortDelay</code></td><td style="text-align:center">终止任务延时</td></tr><tr><td style="text-align:center"><code>xTaskGetHandle</code></td><td style="text-align:center">获取任务句柄</td></tr></tbody></table></div><h2 id="2、CubeMX项目配置实现LED灯翻转"><a href="#2、CubeMX项目配置实现LED灯翻转" class="headerlink" title="2、CubeMX项目配置实现LED灯翻转"></a>2、CubeMX项目配置实现LED灯翻转</h2><p>在组件面板的Middleware组里，有FreeRTOS，启用FreeRTOS并进行模式和参数设置，如下如所示：</p><p><img src="FreeRTOS_CubeMX配置.png" alt="FreeRTOS_CubeMX配置"></p><p>在模式设置(Mode)部分，只有一个参数Interface，其右下拉列表框中有3个选项：</p><ul><li>Disable，表示不适用FreeRTOS。</li><li>CMSIS_V1，启用FreeRTOS，并且使用接口CMSIS_V1。</li><li>CMSIS_V2，启用FreeRTOS，并且使用接口CMSIS_V2。</li></ul><p>这里的接口指的是CMSIS-RTOS接口，也就是ARM公司定义的RTOS接口，有V1和V2两个版本。对于新的设计，我们应该使用新的版本，所以选择CMSIS_V2。</p><p>FreeRTOS的配置部分有8个页面，配置的内容比较多。</p><ul><li>Config parameters，参数配置。配置FreeRTOS的多组参数，这些参数对应于文件FreeRTOSConfig.h中的一些宏定义。</li><li>Include parameters，包含参数。配置FreeRTOS的包含参数，是一些函数的条件编译设置，这些包含参数对应于文件FreeRTOSConfig.h中的一些宏定义。</li><li>Advanced settings，高级设置。一些高级参数设置。</li><li>Tasks and Queues，任务和队列。任务和队列的管理，包括创建、删除和编辑等操作。</li><li>Timer and Semaphores，定时器和信号量。管理软件定时器，二值信号量和计数信号量。</li><li>Mutexes，互斥量。管理互斥量和递归互斥量。</li><li>FreeRTOS Heap Usage，FreeRTOS堆空间使用情况统计。</li><li>User Constants，用户常数。用户自定义常数的设置。</li></ul><p>这几个页面的设置涉及FreeRTOS中的一些主要功能的使用，列如任务、信号量、互斥量等。现在，先保持FreeRTOS的所有参数设置为默认值。</p><p><strong>在FreeRTOS中，用户至少需要创建一个任务。CubeMX在启用FreeRTOS时，就定义了一个默认的任务。</strong>任务名称时defaultTask，任务函数名称是StartDefaultTask，这个任务的所有设置暂时保持默认值。</p><p><img src="CubeMX中定义的默认任务.png" alt="CubeMX中定义的默认任务"></p><p>在完成设置之后，若是字节生成项目代码，会弹出弹窗：</p><p><img src="提示在使用FreeRTOS时不要使用SysTick定时器作为HAL基础时钟源.png" alt="提示在使用FreeRTOS时不要使用SysTick定时器作为HAL基础时钟源"></p><p>它提示在<strong>使用FreeRTOS时，应该使用一个独立的定时器HAL基础时钟源，而不是使用SysTick定时器。</strong></p><p>返回<code>SYS</code>组件的模式设置，设置<code>Timebase Source</code>为某个定时器，这个默认定时器是<code>SysTick</code>，<strong>在使用FreeRTOS的时候，FreeRTOS会将SysTick用作基础时钟，所以需要设置一个定时器作为HAL的基础时钟。</strong></p><p><img src="SYS组件的模式设置.png" alt="SYS组件的模式设置"></p><p>再次生成工程文件，就没有弹窗了。</p><h3 id="2-1、程序分析"><a href="#2-1、程序分析" class="headerlink" title="2.1、程序分析"></a>2.1、程序分析</h3><h4 id="2-1-1-主程序"><a href="#2-1-1-主程序" class="headerlink" title="2.1.1. 主程序"></a>2.1.1. 主程序</h4><p>生成的工程主函数代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/*!&lt; 系统时钟配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">/*!&lt; FreeRTOS对象初始化函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line"> </span><br><span class="line">  osKernelInitialize(); <span class="comment">/*!&lt; 初始化FreeRTOS的调度器 */</span></span><br><span class="line">  MX_FREERTOS_Init();   <span class="comment">/*!&lt; FreeRTOS对象初始化函数 */</span></span><br><span class="line">  osKernelStart();      <span class="comment">/*!&lt; 启动FreeRTOS的任务调度器 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*!&lt; 程序无法运行到这里，因为RTOS的任务调度器接管了系统的控制 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的最开始还是调用函数<code>HAL_Init()</code>进行初始化。<code>HAL_Init()</code>内部会调用函数<code>HAL_InitTick()</code>对HAL基础时钟进行初始化。</p><p><strong>默认情况下，HAL基础时钟源使用SysTick定时器</strong>，在使用定时器TIM6作为HAL时钟源后，CubeMX在生成代码是创建了一个文件<code>stm32f1xx_hal_timebase_tim.c</code>，在这个文件中重新实现了函数<code>HAL_InitTick</code>，<strong>对TIM6进行初始化，使用TIM6生成HAL的滴答时钟信号</strong>。</p><p><strong>系统和外设初始化完成之后，调用函数<code>osKernelInitialize()</code>进行FreeRTOS调度器的初始化。</strong></p><p>函数<code>MX_FREERTOS_Init()</code>是FreeRTOS中创建对象的初始化函数，这个函数在<code>freertos.c</code>中实现。<em>注意：文件<code>freertos.c</code>没有对应的头文件<code>freertos.h</code>，所以在文件<code>main.c</code>的私有函数原型定义部分，声明了这个函数的原型。</em> <strong>函数<code>MX_FREERTOS_Init()</code>的主要功能是创建用户定义的任务、信号量、队列等在FreeRTOS中用到的对象。</strong></p><p>之后调用了<code>osKernelStart()</code>，这是<code>CMSIS-RTOS</code>标准接口函数，其内部调用FreeRTOS的函数<code>vTaskStartScheduler()</code>，功能是启动FreeRTOS内核的任务调度器。<em>执行了这个函数之后，FreeRTOS就接管了系统的控制权，处理去循环执行FreeRTOS中各个任务的代码，FreeRTOS进行任务调度与其他功能管理。</em> <strong>处理器不会执行<code>osKernelStart()</code>之后的代码行，也不会执行main()函数最后的while()最后的while()循环里的代码。</strong></p><h4 id="2-1-2-FreeRTOS对象初始化函数和任务创建"><a href="#2-1-2-FreeRTOS对象初始化函数和任务创建" class="headerlink" title="2.1.2. FreeRTOS对象初始化函数和任务创建"></a>2.1.2. FreeRTOS对象初始化函数和任务创建</h4><p><strong>函数<code>MX_FREERTOS_Init()</code>是CubeMX生成的文件<code>freertos.c</code>中的一个函数，用于创建FreeRTOS中的任务、信号量、队列等对象</strong>。FreeRTOS要运行起来，必须创建至少一个任务。应用程序中需要用户编写的涉及FreeRTOS操作的代码，主要写在这个文件里面。</p><p>文件<code>freertos.c</code>没有对应的头文件<code>freertos.h</code>。文件<code>freertos.c</code>初始化代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Definitions for defaultTask */</span></span><br><span class="line">osThreadId_t defaultTaskHandle;<span class="comment">//任务defaultTask的句柄函数</span></span><br><span class="line"><span class="comment">//任务defaultTask的属性</span></span><br><span class="line"><span class="type">const</span> osThreadAttr_t defaultTask_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;defaultTask&quot;</span>,<span class="comment">//任务的注释名称</span></span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,<span class="comment">//栈储存空间大小，即128x4=512字节</span></span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,<span class="comment">//任务优先级</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartDefaultTask</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* (MISRA C 2004 rule 8.1) */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  FreeRTOS initialization</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_MUTEX */</span></span><br><span class="line">  <span class="comment">/* add mutexes(互斥量), ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_MUTEX */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_SEMAPHORES */</span></span><br><span class="line">  <span class="comment">/* add semaphores(信号量), ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_SEMAPHORES */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_TIMERS */</span></span><br><span class="line">  <span class="comment">/* start timers, add new ones, ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_TIMERS */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_QUEUES */</span></span><br><span class="line">  <span class="comment">/* add queues(队列), ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_QUEUES */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create the thread(s) */</span></span><br><span class="line">  <span class="comment">/* creation of defaultTask */</span></span><br><span class="line">  defaultTaskHandle = osThreadNew(StartDefaultTask, <span class="literal">NULL</span>, &amp;defaultTask_attributes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_THREADS */</span></span><br><span class="line">  <span class="comment">/* add threads(任务), ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_THREADS */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_EVENTS */</span></span><br><span class="line">  <span class="comment">/* add events, ... */</span></span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_EVENTS */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务defaultTask的任务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartDefaultTask</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartDefaultTask */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    osDelay(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartDefaultTask */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在程序开头部分定义了一个<code>osThreadId_t</code>类型的变量<code>defaultTaskHandle</code>。<code>osThreadId_t</code>类型实际上是void类型指针，是文件<code>cmsis_0s.h</code>中的一个类型定义。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *osThreadId_t;</span><br></pre></td></tr></table></figure><p>我们把某个对象的指针类型变量称为<strong>句柄变量</strong>，所以，把<code>defaultTaskHandle</code>称为表示任务<code>defaultTask</code>的句柄变量。</p><p>在程序开头部分还定义了一个<code>osThreadAttr_t</code>结构体类型变量<code>defaultTask_attributes</code>，并且为其成员变量赋值。<code>defaultTaskHandle</code>和<code>defaultTask_attributes</code>这两个变量，在函数<code>MX_FREERTOS_Init()</code>里创建任务<code>defaultTask</code>时会用到。</p><p><em>在程序开头部分还声明了两个函数的原型。因为文件<code>freertos.c</code>没有对应的头文件<code>freerots.h</code>所以需要在文件开头部分声明函数原型。</em></p><p><strong>函数<code>MX_FREERTOS_Init()</code>用于创建FreeRTOS中的任务、信号量、互斥量等对象。所以可以称这个函数为FreeRTOS对象初始化函数</strong>。这个函数里面有多个沙箱段，用于创建互斥量、信号量、任务等对象，如果在CubeMX中可视化地设计了这些对象，就会在这里自动生成相应的代码。用户也可以在这些沙箱段内自己添加代码创建对象，因为某些对象不能在CubeMX里可视化设计，如事件组。</p><p><strong>FreeRTOS要运行起来，至少要有一个用户任务</strong>，<code>MX_FREERTOS_Init()</code>调用函数<code>osThreadNew()</code>创建CubeMX中定义的默认任务<code>defaultTask</code>。函数<code>osThreadNew()</code>是在文件<code>cmsis_os2.h</code>中定义的，也就是由<code>CMSIS-RTOS V2</code>标准定义的接口函数。其函数原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, <span class="type">void</span> *argument, <span class="type">const</span> osThreadAttr_t *attr)</span></span><br></pre></td></tr></table></figure><p>其中，<code>func</code>是任务函数名称，<code>argument</code>是向任务函数传递的参数，<code>attr</code>是任务属性结构体指针。</p><p>参数<code>func</code>是<code>osThreadFunc_t</code>类型，这是一个函数指针类型，定义了<strong>任务函数的输入/输出参数形式</strong>，在文件<code>cmsis_os2.h</code>中的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*osThreadFunc_t)</span> <span class="params">(<span class="type">void</span> *argument)</span>;</span><br></pre></td></tr></table></figure><p>函数<code>MX_FREERTOS_Init()</code>中创建任务<code>defaultTask</code>代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">defaultTaskHandle = osThreadNew(StartDefaultTask, <span class="literal">NULL</span>, &amp;defaultTask_attributes);</span><br></pre></td></tr></table></figure><ul><li>第一个参数<code>StartDefaultTask</code>是任务<code>deaultTask</code>的任务函数名称，每一个任务实际上就是一个函数；</li><li>第二个参数值为<code>NULL</code>，是传递给任务函数的参数；</li><li>第三个参数是<code>defaultTask_attributes</code>的指针，是任务的属性定义，在文件<code>freertos.c</code>的私有变量部分定义了任务属性变量<code>defaultTask_attributes</code>；</li><li>函数的返回值是<code>defaultTaskHandle</code>，也就是任务<code>defaultTask</code>的句柄变量；</li></ul><p>任务<code>defaultTask</code>的任务属性<code>defaultTask_attributes</code>在定义时就成为成员变量赋值了，这些赋值与CubeMX中设计的任务属性时对应的。</p><p>表示任务属性的结构体<code>osThreadAttr_t</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>                   *name;<span class="comment">//任务的名称，只用于备注</span></span><br><span class="line">  <span class="type">uint32_t</span>                 attr_bits;<span class="comment">//属性位</span></span><br><span class="line">  <span class="type">void</span>                      *cb_mem;<span class="comment">//用于控制块的存储空间</span></span><br><span class="line">  <span class="type">uint32_t</span>                   cb_size;<span class="comment">//控制块存储空间的大小，单位：字</span></span><br><span class="line">  <span class="type">void</span>                   *stack_mem;<span class="comment">//栈的存储空间</span></span><br><span class="line">  <span class="type">uint32_t</span>                stack_size;<span class="comment">//栈存储空间的大小，单位：字</span></span><br><span class="line">  osPriority_t              priority;<span class="comment">//任务的初始化优先级，默认值：osPriorityNormal</span></span><br><span class="line">  TZ_ModuleId_t            tz_module;<span class="comment">//TrustZone模块标识符</span></span><br><span class="line">  <span class="type">uint32_t</span>                  reserved;<span class="comment">//保留变量，必须是0</span></span><br><span class="line">&#125; osThreadAttr_t;</span><br></pre></td></tr></table></figure><p>CubeMX中对任务属性的配置窗口如下：</p><p><img src="CubeMX中的Edit Task对话框.png" alt="CubeMX中的Edit Task对话框"></p><p>图中显示的任务属性参数作用解释如下：</p><ul><li><code>Task Name</code>：任务名称，仅用于备注；</li><li><code>Priority</code>：优先级。每个任务都需要设置一个优先级，优先级和任务调度有关。优先级个数由文件<code>FreeRTOSConfig.h</code>中的宏定义<code>configMAX_PRIORITIES</code>决定，默认是56个。<strong>任务的优先级数字越小，优先级越低</strong>。枚举类型<code>osPriority_t</code>定义了常用的一些优先级，如<code>osPriorityLow</code>、<code>osPriorityNormal</code>、<code>osPriorityHigh</code>等，<em>一个任务在创建时，其默认优先级是<code>osPriorityNormal</code></em>。</li><li><code>Stack Size</code>：栈空间大小。<strong>每个任务其实就是一个内部有是循环的函数，FreeRTOS在进行任务切换时，要进行场景的保存与恢复，这就需要使用栈(stack)</strong>。栈实际上就是一个内存空间，每个任务都需要分配一个栈空间。<strong>在FreeRTOS中，栈空间存储元素类型是<code>uint32_t</code>，栈空间的大小单位是字(word)</strong>。<em><code>Cortex-M</code>是32位处理器，一个字的长度是4个字节</em>。但是结构体<code>osThreadAttr_t</code>的成员变量<code>stack_size</code>表示栈的存储空间大小，单位是字节，所以在文件<code>freertos.c</code>中为任务<code>defaultTask</code>的任务属性结构体变量<code>defaultTask_arttributes</code>的成员变量赋值时，相当于如下的语句：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">defaultTask_attributes.stack_size = <span class="number">128</span> * <span class="number">4</span>;<span class="comment">//栈存储空间大小，即128x4=512字节</span></span><br></pre></td></tr></table></figure><ul><li><code>Entry Function</code>：入口函数。也就是任务函数。一个任务就是一个内部有是循环的函数，如<code>StartDefaultTask</code>。<strong>任务函数名称不是结构体<code>osThreadAttr_t</code>的成员变量，而是任务创建函数<code>osThreadNew()</code>的参数</strong>。</li><li><code>Code Generation Option</code>：生成代码的选项。有<code>Default</code>和<code>As weak</code>两个选项。<ul><li><strong>如果选择<code>As weak</code>，就是任务函数定义成一个弱函数，也就是函数名前面有修饰符<code>__weak</code>。</strong></li><li><strong>选择<code>Default</code>就是生成正常的函数。</strong></li></ul></li><li><code>Parameter</code>：参数。为任务函数传递的参数，如果不需要传递参数，就设置为<code>NULL</code>。</li><li><code>Allocation</code>：<strong>内存分配方式。是指任务的栈和控制块内存的分配方式</strong>，选项包括<code>Dynamic</code>和<code>Static</code>。<ul><li><strong><code>Dynamic</code>表示由<code>osTreadNew()</code>函数内部为任务动态创建栈存储空间<code>stack_mem</code>和任务控制块存储空间<code>cb_mem</code></strong>。</li><li><strong>如果选择为<code>Static</code>，则需要在调用<code>osThreadNew()</code>之前，为<code>stack_mem</code>和<code>cb_mem</code>赋值，即静态分配内存</strong>。</li></ul></li></ul><p>如果设置<code>Allocation</code>为<code>Static</code>，设置<code>Buffer Name</code>为<code>defaultTaskBuffer</code>，设置<code>Control Block Name</code>为<code>defaultTaskControlBlcok</code>，则在<code>freertos.c</code>的私有变量部分，会定义如下的一些变量，生成如下的任务属性赋值代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osThreadId_t defaultTaskHandle;             <span class="comment">//任务句柄变量</span></span><br><span class="line"><span class="type">uint32_t</span> defaultTaskControlBlock[<span class="number">128</span>];      <span class="comment">//栈空间数组</span></span><br><span class="line">osStaticThreadDef_t defaultTaskControlBlock;<span class="comment">//控制块结构体变量</span></span><br><span class="line"><span class="comment">//任务属性赋值</span></span><br><span class="line"><span class="type">const</span> osThreadAttr_t defaultTask_attributes = &#123;</span><br><span class="line">    .name = <span class="string">&quot;defaultTask&quot;</span>,                      <span class="comment">//任务名称</span></span><br><span class="line">    .stack_mem = &amp;defaultTaskBuffer[<span class="number">0</span>],         <span class="comment">//栈数组地址</span></span><br><span class="line">    .stack_size = <span class="keyword">sizeof</span>(defaultTaskBuffer),    <span class="comment">//栈数组大小</span></span><br><span class="line">    .cb_mem = &amp;defaultTaskControlBlock,         <span class="comment">//控制块地址</span></span><br><span class="line">    .cb_size = <span class="keyword">sizeof</span>(defaultTaskControlBlock), <span class="comment">//控制块大小</span></span><br><span class="line">    .priority = (psPriority_t)osPriorityNormal, <span class="comment">//任务优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用静态分配内存时，稍微麻烦一点。<strong>但是不管时动态分配内存，还是静态分配内存，函数<code>MX_FREERTOS_Init()</code>还是调用<code>osThreadNoew()</code>创建任务</strong>。</p><p><strong>函数<code>osThreadNew()</code>会根据任务属性中的内存分配方式，分别调用FreeRTOS的两个不同的函数创建任务</strong>：</p><ul><li>动态分配任务时，调用函数<code>xTaskCreate()</code>创建任务；</li><li>静态分配内存时，调用函数<code>xTaskCreateStatic()</code>创建任务。</li></ul><h4 id="2-1-3-编写任务功能实现代码"><a href="#2-1-3-编写任务功能实现代码" class="headerlink" title="2.1.3. 编写任务功能实现代码"></a>2.1.3. 编写任务功能实现代码</h4><p>编写示例，使<code>LED0</code>间隔500ms翻转，任务函数<code>StartDefaultTask()</code>，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE END Header_StartDefaultTask */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartDefaultTask</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN StartDefaultTask */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);</span><br><span class="line">    osDelay(<span class="number">500</span>); <span class="comment">/*!&lt; 延时500个tick(时钟节拍) */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END StartDefaultTask */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for循环中，使用的延时函数时<code>osDelay()</code>，这是<code>CMSIS-RTOS</code>标准接口函数，内部调用FreeRTOS的延时函数<code>vTaskDelay()</code>，延时单位时时钟节拍(tick)。<strong>FreeRTOS的基础时钟产生的滴答信号周期是1ms，所以一个节拍就是1ms</strong>。</p><p>在FreeRTOS的任务管理中，延时函数<code>vTaskDelay()</code>是非常重要的。任务函数的主体一般就是一个死循环，<strong>任务函数在执行延时函数<code>vTaskDelay()</code>时，会交出CPU的使用权，由FreeRTOS进行任务调度，使其他任务可以获取CPU的使用权，否则，高优先级任务将总是占用CPU，其他任务无法执行</strong>。</p><h2 id="3、FreeRTOS的文件组成和基本原理"><a href="#3、FreeRTOS的文件组成和基本原理" class="headerlink" title="3、FreeRTOS的文件组成和基本原理"></a>3、FreeRTOS的文件组成和基本原理</h2><h3 id="3-1-FreeRTOS文件组成"><a href="#3-1-FreeRTOS文件组成" class="headerlink" title="3.1 FreeRTOS文件组成"></a>3.1 FreeRTOS文件组成</h3><p>在上面的LED灯示例中，与FreeRTOS相关的程序文件主要分为<strong>可修改的用户程序文件</strong>和<strong>不可修改的FreeRTOS源程序文件</strong>。前面介绍的<code>freertos.c</code>是可修改的用户程序文件，FreeRTOS中任务、信号量等对象的创建，用户任务函数都在这个文件里面实现。</p><p>项目中FreeRTOS的源程序文件都在目录<code>\Middlewares\Third_Party\FreeRTOS\Source</code>下，这些是针对选择的MCU信号做好了移植的文件。<em>使用CubeMX生成代码时，用户无需关心FreeRTOS的移植问题，所需的源程序文件也为用户组织好了</em>。</p><p>FreeRTOS的源程序文件大致可以分为5类，如下所示：</p><p><img src="FreeRTOS的文件组成.png" alt="FreeRTOS的文件组成"></p><p>用户配置和程序文件有两个文件，用于对FreeRTOS进行各种配置和功能裁剪，以及实现用户任务的功能。</p><ul><li>文件<code>FreeRTOSConfig.h</code>，是对FreeRTOS进行各种配置的文件，<strong>FreeRTOS的功能裁剪就是通过这个文件里面的各种宏定义实现的</strong>。</li><li>文件<code>freertos.c</code>包含FreeRTOS对象初始化函数<code>MX_FREERTOS_Init()</code>和任务函数，<strong>是编写用户代码的主要文件</strong>。</li></ul><h4 id="3-1-1-FreeRTOS通用功能文件"><a href="#3-1-1-FreeRTOS通用功能文件" class="headerlink" title="3.1.1 FreeRTOS通用功能文件"></a>3.1.1 FreeRTOS通用功能文件</h4><p>这些是实现FreeRTOS的任务、队列、信号量、软件定时器、事件组等通用功能文件，这些功能与硬件无关。在一个嵌入式操作系统中，任务管理是必须的，某些功能是在用到时才需要加入的，如事件组、软件定时器、信号量、流缓冲区等。CubeMX在生成代码时，将这些文件全部复制到了项目里，但是它不会编译到最终的二进制文件里。用户可以对FreeRTOS的各种参数进行配置，实现功能剪裁，这些参数配置其实就是各种条件编译的条件定义。</p><div class="table-container"><table><thead><tr><th style="text-align:left">文件</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>croutine.h/.c</code></td><td>实现协程(co-routine)功能的程序文件，协程主要用于内存非常小的MCU，现在已经很少使用。</td></tr><tr><td style="text-align:left"><code>event_groups.h/.c</code></td><td>实现事件组功能的程序文件。</td></tr><tr><td style="text-align:left"><code>list.h/.c</code></td><td>实现链表功能的程序文件，FreeRTOS的任务调度器用到链表。</td></tr><tr><td style="text-align:left"><code>queue.h/.c</code></td><td>实现队列功能的程序文件。</td></tr><tr><td style="text-align:left"><code>semphr.h</code></td><td>实现信号量功能的文件，信号量是基于队列的，信号量操作的函数都是宏函数，其实现都是调用队列处理的函数。</td></tr><tr><td style="text-align:left"><code>task.h/tasks.c</code></td><td>实现任务管理功能的程序文件。</td></tr><tr><td style="text-align:left"><code>timers.h/.c</code></td><td>实现软件定时器功能的程序文件。</td></tr><tr><td style="text-align:left"><code>stream_buffer.h/.c</code></td><td>实现流缓冲区功能的程序文件。流缓冲区是一种优化的进程间通信机制，是在V10版本中才引入的功能。</td></tr><tr><td style="text-align:left"><code>message_buffer.h</code></td><td>实现消息缓冲区的文件。实现缓冲区功能的所有函数都是宏函数，因为消息缓冲区是基于流缓冲区实现的，都调用流缓冲区的函数。消息缓冲区是在V10版本中才引入的功能。</td></tr><tr><td style="text-align:left"><code>mpu_prototypes.h</code><br><code>mpu_wrappers.h</code></td><td>MPU(内存保护单元)功能的头文件。该文件定义的函数是在标准函数前面增加前缀”MPU_”，当应用程序使用MPU功能时，FreeRTOS内核会优先执行此文件中的函数。</td></tr></tbody></table></div><h4 id="3-1-2-FreeRTOS通用定义文件"><a href="#3-1-2-FreeRTOS通用定义文件" class="headerlink" title="3.1.2 FreeRTOS通用定义文件"></a>3.1.2 FreeRTOS通用定义文件</h4><p>在工程目录<code>FreeRTOS\Source\include</code>下有几个与硬件不管的通用定义文件。</p><p><strong>文件<code>FreeRTOS.h</code>。这个文件包含FreeRTOS的默认宏定义、数据类型定义、接口函数定义等</strong>。FreeRTOS.h中有些默认的用于FreeRTOS功能裁剪的宏定义，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> configIDLE_SHOULD_YIELD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_vTaskDelete</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>FreeRTOS的功能裁剪就是通过这些宏定义实现的，这些用于配置的宏定义主要分为以下两类</strong>。</p><ul><li>前缀为<code>config</code>的宏表示某种参数设置，一般地，值为1表示开启此功能，值为0表示禁用此功能，如<code>configIDLE_SHOULD_YIELD</code>表示空闲任务是否对同优先级地任务让出处理器使用权。</li><li>前缀为<code>INCLUDE_</code>的宏表示是否编译某个函数的源代码，例如，宏<code>INCLUDE_vTaskDelete</code>的值为1，就表示编译函数<code>vTaskDelete()</code>的源代码，值为0就表示不编译函数<code>vTaskDelete()</code>的源代码。</li></ul><p>在FreeRTOS中，这些宏定义通常称为参数，因为它们决定了系统的一些特性。<strong>文件<code>FreeRTOS.h</code>包含系统默认的一些参数的宏定义，不要直接修改此文件的内容</strong>。用户可以修改的配置文件是<code>FreeRTOSConfig.h</code>，这个文件也包含大量前缀为<code>config</code>和<code>INCLUDE_</code>的宏定义。<strong>如果文件<code>FreeRTOSConfig.h</code>中没有定义某个宏，就使用文件FreeRTOS.h中的默认定义</strong>。</p><p>FreeRTOS的大部分功能配置都可以通过CubeMX可视化设置完成，并生成文件<code>FreeRTOSConfig.h</code>中的宏定义代码。</p><p>文件<code>projdefs.h</code>。这个文件包含FreeRTOS中的一些通用定义，如错误编号宏定义，逻辑值的宏定义等。文件<code>projdefs.h</code>中常用的几个宏定义及其功能如下：</p><div class="table-container"><table><thead><tr><th>宏定义</th><th>值</th><th>功能</th></tr></thead><tbody><tr><td><code>pdFALSE</code></td><td>0</td><td>表示逻辑值<code>false</code></td></tr><tr><td><code>pdTRUE</code></td><td>1</td><td>表示逻辑值<code>true</code></td></tr><tr><td><code>pdFAIL</code></td><td>0</td><td>表示逻辑值<code>false</code></td></tr><tr><td><code>pdPASS</code></td><td>1</td><td>表示逻辑值<code>true</code></td></tr><tr><td><code>pdMS_TO_TICKS(xTimeInMs)</code></td><td>-</td><td>这是个宏函数，其功能是将<code>xTimeInMs</code>表示的毫秒数转换为时钟节拍数，因为延时函数<code>vTaskDelay()</code>的输入参数是节拍数</td></tr></tbody></table></div><p>文件<code>stack_macros.h</code>和<code>StackMacros.h</code>。这两个文件的内容完全一样，只是为了向后兼容，才出现了两个文件。这两个文件定义了进行栈溢出检查的函数，如果要使用栈溢出检查功能，需要设置参数<code>configCHECK_FOR_STACK_OVERFLOW</code>的值为1或2。</p><h4 id="3-1-3-CMSIS-RTOS标准接口文件"><a href="#3-1-3-CMSIS-RTOS标准接口文件" class="headerlink" title="3.1.3 CMSIS-RTOS标准接口文件"></a>3.1.3 CMSIS-RTOS标准接口文件</h4><p>目录<code>\FreeRTOS\Source\CMSIS_RTOS_V2\</code>下是<code>CMSIS-RTOS</code>标准接口文件，如下图所示：</p><p><img src="CMSIS-RTOS标准接口文件.png" alt="CMSIS-RTOS标准接口文件"></p><p>这些文件里的宏定义、数据类型、函数名称等前缀都是<code>os</code>。原理上来说，这些函数和数据类型的名称与具体的RTOS无关，它们是<code>CMSIS-RTOS</code>标准的定义。在具体实现上，这些前缀为<code>os</code>的函数调用具体移植的RTOS的实现函数，<strong>例如，若移植的是FreeRTOS，<code>os</code>函数就调用FreeRTOS的实现函数，若移植的是uC/OS-Ⅱ，<code>os</code>函数就调用uC/OS-Ⅱ的实现函数</strong>。</p><p>我们移植的是FreeRTOS，所以<code>os</code>函数就调用FreeRTOS的实现函数。例如，CMSIS-RTOS的延时函数<code>osDelay()</code>的内部就是调用了FreeRTOS的延时函数<code>vTaskDelay()</code>，其完整源代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osStatus_t <span class="title function_">osDelay</span> <span class="params">(<span class="type">uint32_t</span> ticks)</span> &#123;</span><br><span class="line">  osStatus_t stat;</span><br><span class="line">  <span class="keyword">if</span> (IS_IRQ()) &#123;</span><br><span class="line">    stat = osErrorISR;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    stat = osOK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ticks != <span class="number">0U</span>) &#123;</span><br><span class="line">      vTaskDelay(ticks);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (stat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>在LED翻转的示例中，就有一些类似的<code>os</code>函数：<code>osThreadNew()</code>的内部调用<code>xTaskCreate()</code>或<code>xTaskCreateStatic()</code>创建任务；<code>osKernelStart()</code>的内部调用<code>vTaskStartScheduler()</code>启动FreeRTOS内核运行。</em></p><p>从原理上来说，如果在程序中使用这些<code>CMSIS-RTOS</code>标准接口函数和类型定义，可以减少与具体RTOS的关联。例如，一个应用程序原先是使用FreeRTOS写的，后来要改用其他的实时操作系统，则只需改RTOS移植部分的程序，而无需修改应用程序。但是这种情况可能极少。</p><h4 id="3-1-4-硬件相关的移植文件"><a href="#3-1-4-硬件相关的移植文件" class="headerlink" title="3.1.4 硬件相关的移植文件"></a>3.1.4 硬件相关的移植文件</h4><p>硬件相关的移植文件就是需要根据硬件类型进行改写的文件，一个移植好的版本成为一个端口(port)，这些文件在目录<code>\FreeRTOS\Source\portable</code>下，又分为处理器架构与编译器文件、内存管理文件两个部分，如下所示：</p><p><img src="硬件相关移植文件.png" alt="硬件相关移植文件"></p><p>由于我在工程中生成了<code>Keil</code>和<code>IAR</code>两个工程文件，故架构与编译器的文件夹就有两个。其中：</p><ul><li><code>IAR</code>文件夹中为<code>IAR</code>工程的处理器架构与编译器文件</li><li><code>RVDS</code>文件夹为<code>Keil</code>工程的处理器架构与编译器文件</li><li><code>MemMand</code>文件夹内为内存管理文件</li></ul><ol><li><strong>处理器架构与编译器相关文件</strong></li></ol><p>处理器架构与编译器部分有2个文件，分别为<code>portmacro.h</code>和<code>port.c</code>。<strong>这两个文件里面是一些与硬件相关的基础数据类型、宏定义和函数定义</strong>。因为某些函数的功能实现设计底层操作，其实现代码甚至是用汇编语言写的，所以与硬件密切相关。</p><p>FreeRTOS需要使用一个基础数据类型定义头文件<code>stdint.h</code>，这个头文件定义的是<code>uint8_t</code>、<code>uint16_t</code>、<code>uint32_t</code>等基础数据类型，STM32的HAL库包含这个文件。</p><p>另外，在文件<code>portmacro.h</code>中，FreeRTOS还重新定义了一些基础的数据类型的类型符号，定义的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portCHARchar</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portFLOATfloat</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portDOUBLEdouble</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portLONGlong</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSHORTshort</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portSTACK_TYPEuint32_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portBASE_TYPElong</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> portSTACK_TYPE StackType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> BaseType_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> UBaseType_t;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>( configUSE_16_BIT_TICKS == 1 )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> TickType_t;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> TickType_t;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portMAX_DELAY ( TickType_t ) 0xffffffffUL</span></span><br></pre></td></tr></table></figure><p>其中，因为<code>Cortex-M3</code>是32位处理器，所以<code>configUSE_16_BIT_TICKS == 0</code></p><ol><li><strong>内存管理相关文件</strong></li></ol><p>内存管理涉及内存动态分配和释放等操作，与具体的处理器密切相关。FreeRTOS提供5种内存管理方案，即<code>heap1~heap5</code>，在CubeMX中设置FreeRTOS参数时选择一种即可。CubeMX生成的默认的内存管理方案。</p><p>文件<code>heap_4.c</code>实现了动态分配内存的函数<code>pvPortMalloc()</code>，释放内存的函数<code>vPortFree()</code>，以及其他几个函数。</p><h3 id="3-2-FreeRTOS的编码规则"><a href="#3-2-FreeRTOS的编码规则" class="headerlink" title="3.2 FreeRTOS的编码规则"></a>3.2 FreeRTOS的编码规则</h3><p>FreeRTOS的核心源程序文件遵循一套编码规则，其变量命名、函数命名、宏定义命名等都有规律，知道这些规律有助于理解函数名、宏定义的意义。</p><h4 id="3-2-1-变量名"><a href="#3-2-1-变量名" class="headerlink" title="3.2.1 变量名"></a>3.2.1 变量名</h4><p>变量名适用类型前缀。通过变量名的前缀，用户可以知道变量的类型。</p><ul><li><p>对于<code>stdint.h</code>中定义的各种标准类型整数</p><ul><li>前缀<code>c</code>表示<code>char</code>类型变量，前缀<code>s</code>表示<code>int16_t(short)</code>类型变量</li><li>前缀<code>l</code>表示<code>int32_t</code>类型变量。对于无符号<code>uinsigned</code>整数</li><li>再在前面增加前缀<code>u</code>，如<code>uc</code>表示<code>uint8_t</code>类型</li><li><code>us</code>表示<code>uint16_t</code>，<code>ul</code>表示<code>uint32_t</code>类型。</li></ul></li><li><p><code>BaseType_t</code>和所有其他非标准类型的变量名，如结构体变量、任务句柄、队列句柄等都用前缀<code>x</code>。</p></li><li><code>UBaseType_t</code>类型的变量使用前缀<code>ux</code>。</li><li>指针类型变量在前面再增加一个<code>p</code>，例如<code>pc</code>表示<code>char*</code>类型。</li></ul><h4 id="3-2-2-函数名"><a href="#3-2-2-函数名" class="headerlink" title="3.2.2 函数名"></a>3.2.2 函数名</h4><p>函数名的前缀由<strong>返回值类型</strong>和<strong>函数所在文件</strong>组成，若返回值位<code>void</code>类型，则类型前缀时<code>v</code>。举例如下：</p><ul><li>函数<code>xTaskCreate()</code>，其返回值位BaseType_t类型，在文件<code>task.h</code>中定义。</li><li>函数<code>vQueueDelete()</code>，其返回值位<code>void</code>，在文件<code>queue.h</code>中定义。</li><li>函数<code>pcTimerGetName()</code>，其返回值位<code>char*</code>，在文件<code>timer.h</code>中定义。</li><li>函数<code>pvPortMalloc()</code>，其返回值位<code>void*</code>，在文件<code>portable.h</code>中定义。</li></ul><p>​        如果函数是用<code>static</code>声明的文件内使用的私有函数，则其前缀位<code>prv</code>，例如：<code>tasks.c</code>文件中函数<code>prvAddNewTaskToReadyList()</code>，因为私有函数不会被外部调用，所以函数名中就不用包括返回值类型和所在文件的前缀了。</p><p>​        <code>CMSIS-RTOS</code>相关文件中定义的函数前缀都是<code>os</code>，不包括返回值类型和所在文件的前缀。例如，<code>cmsis_os2.h</code>中的函数<code>osThreadNew()</code>、<code>osDelay()</code>等。</p><h4 id="3-2-3-宏名称"><a href="#3-2-3-宏名称" class="headerlink" title="3.2.3 宏名称"></a>3.2.3 宏名称</h4><p>宏定义和宏函数的名称一般用大写字母，并使用小写字母前缀表示红的功能分组。FreeRTOS中常用的宏名称如下：</p><div class="table-container"><table><thead><tr><th>前缀</th><th>意义</th><th>所在文件</th><th>实例</th></tr></thead><tbody><tr><td><code>config</code></td><td>用于系统功能配置的宏</td><td><code>FreeRTOSConfig.h</code><br><code>FreeRTOS.h</code></td><td><code>configUSE_MUTEXES</code><br><code>configTICK_RATE_HZ</code></td></tr><tr><td><code>INCLUDE_</code></td><td>条件编译某个函数的就宏</td><td><code>FreeRTOSConfig.h</code><br><code>FreeRTOS.h</code></td><td><code>INCLUDE_vTaskDelay</code><br><code>INCLUDE_vTaskDelete</code></td></tr><tr><td><code>task</code></td><td>任务相关的宏</td><td><code>task.h</code><br><code>task.c</code></td><td><code>taskENTER_CRITICAL()</code><br><code>taskIDLE_PRIORITY</code></td></tr><tr><td><code>queue</code></td><td>队列相关的宏</td><td><code>queue.h</code></td><td><code>queueQUEUE_TYPE_MUTEX</code></td></tr><tr><td><code>pd</code></td><td>项目通用宏定义</td><td><code>projdefs.h</code></td><td><code>pdTRUE, pdFALSE</code></td></tr><tr><td><code>port</code></td><td>移植接口文件定义的宏</td><td><code>portable.h</code><br><code>portmacro.h</code><br><code>port.c</code></td><td><code>portBYTE_ALIGNMENT_MASK</code><br><code>portCHAR</code><br><code>portMAX_24_BIT_NUMBER</code></td></tr><tr><td><code>tmr</code></td><td>软件定时器相关的宏</td><td><code>timer.h</code></td><td><code>tmrCOMMAND_START</code></td></tr><tr><td><code>os</code></td><td>CMSIS-RTOS接口相关的宏</td><td><code>cmsis_os.h</code><br><code>cmsis_os2.h</code></td><td><code>osFeature_SysTick</code><br><code>osFlagsWaitAll</code></td></tr></tbody></table></div><h3 id="3-3-FreeRTOS的配置和功能裁剪"><a href="#3-3-FreeRTOS的配置和功能裁剪" class="headerlink" title="3.3 FreeRTOS的配置和功能裁剪"></a>3.3 FreeRTOS的配置和功能裁剪</h3><p>FreeRTOS的配置和功能裁剪主要是通过文件<code>FreeRTOSConfig.h</code>和<code>FreeRTOS.h</code>中的宏定义实现的</p><ul><li><strong>前缀为<code>config</code>的宏用于配置FreeRTOS的一些参数</strong></li><li><strong>前缀为<code>INCLUDE_</code>的宏用于控制是否编译某些函数的源代码</strong>。</li></ul><p><em>文件<code>FreeRTOS.h</code>中的宏定义是系统默认的宏定义，请勿直接修改。</em><code>FreeRTOSConfig.h</code>是用户可修改的配置文件，如果一个宏没有在文件<code>FreeRTOSConfig.h</code>中重定义，就是用文件<code>FreeRTOS.h</code>中的默认定义。</p><p>在CubeMX中，FreeRTOS的配置界面中有<code>Config parameters</code>和<code>Include parameters</code>两个页面，用于对这两类宏进行设置。</p><h4 id="3-3-1-config类的宏"><a href="#3-3-1-config类的宏" class="headerlink" title="3.3.1 config类的宏"></a>3.3.1 <code>config</code>类的宏</h4><p><strong>前缀为<code>config</code>的宏用于配置FreeRTOS的一些参数</strong>。LED翻转示例中，完全使用了FreeRTOS的默认配置，其宏定义代码定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION                     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_STATIC_ALLOCATION          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION         1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_IDLE_HOOK                      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICK_HOOK                      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ                       ( SystemCoreClock )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ                       ((TickType_t)1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES                     ( 56 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE                 ((uint16_t)128)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE                    ((size_t)3072)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN                  ( 16 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY                 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS                   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES                        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configQUEUE_REGISTRY_SIZE                8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_RECURSIVE_MUTEXES              1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_COUNTING_SEMAPHORES            1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION  0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Co-routine definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_CO_ROUTINES                    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES          ( 2 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Software timer definitions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIMERS                         1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_PRIORITY                ( 2 )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_QUEUE_LENGTH                 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_STACK_DEPTH             256</span></span><br></pre></td></tr></table></figure><p>在CubeMX中修改了值的参数都会在文件<code>FreeRTOConfig.h</code>中生成语句。有默认值的宏定义在文件<code>FreeRTOS.h</code>中，例如，文件<code>FreeRTOS.h</code>中有如下的定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> configIDLE_SHOULD_YIELD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>默认情况下，文件<code>FreeRTOSConfig.h</code>中没有宏定义<code>configIDLE_SHOULD_YIELD</code>，就使用文件<code>FreeRTOS.h</code>中的默认定义。如果通过CubeMX修改了这个参数，在<code>FreeRTOSConfig.h</code>中生成了如下的宏定义，那么就使用<code>FreeRTOSConfig.h</code>中的定义</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD 0</span></span><br></pre></td></tr></table></figure><p>在CubeMX中，FreeRTOS参数配置的<code>Config Parameters</code>页面的参数，分为好几组。这些参数对应于文件<code>FreeRTOSConfig.h</code>和<code>FreeRTOS.h</code>中相应的宏，下面，我们分别介绍这几组参数设置的内容。</p><ol><li><code>Kernel settings</code>：内核设置，是FreeRTOS内核的一些参数，设置的具体参数及其默认值如下：</li></ol><p><img src="FreeRTOS内核设置.png" alt="FreeRTOS内核设置"></p><p>其中一些参数是不允许修改的，就显示为灰色字体。一些参数只能选择一个参数值，例如，<code>USE_MUTEXES</code>只能选择<code>Enable</code>。</p><p>CubeMX中<code>Kernel settings</code>页面的参数与<code>FreeRTOSConfig.h</code>或<code>FreeRTOS.h</code>中的宏是对应的，只是去掉了前缀<code>config</code>，如<code>USE_PREEMPTION</code>对应的宏是<code>configUSE_PREEMPTION</code>。界面中逻辑型参数的可选值是<code>Enable</code>和<code>Disable</code>，对应宏定义的值是1和0，这些宏一般是条件编译的条件，用于条件编译某一段代码。</p><p><code>Kernel settings</code>页面中的参数的意义和默认值如下表所示：</p><div class="table-container"><table><thead><tr><th>配置参数</th><th>默认值</th><th>意义</th></tr></thead><tbody><tr><td><code>USE_PREEMPTION</code></td><td><code>Enabled</code></td><td><code>Enabled</code>表示使用<strong>抢占式任务调度器</strong>；<br><code>Disabled</code>表示使用<strong>合作式任务调度器</strong>；</td></tr><tr><td><code>CPU_CLOCK_HZ</code></td><td><code>SystemCoreClock</code></td><td>系统核心时钟，即MCU的HCLK时钟</td></tr><tr><td><code>TICK_RATE_HZ</code></td><td>1000</td><td>系统滴答时钟频率，设置范围为1至1000，默认为1000Hz，所以周期是1ms</td></tr><tr><td><code>MAX_PRIORITES</code></td><td>56</td><td>任务的最多优先级个数，这里固定为56，<strong>不可修改</strong></td></tr><tr><td><code>MINIAL_STACK_SIZE</code></td><td>128 Words</td><td>系统空闲任务的栈空间的最小值，设置范围为64至3840.在FreeRTOS中，栈空间的大小单位是字，在Cortex-M架构中，一个字是4字节</td></tr><tr><td><code>MAX_TASK_NAME_LEN</code></td><td>16</td><td>任务名称字符串的最大长度，设置范围为12至255</td></tr><tr><td><code>USE_16_BIT_TICKS</code></td><td><code>Disabled</code></td><td>决定文件<code>potymacro.h</code>中定义的节拍数据类型<code>TickType_t</code>的具体类型。若这个值是<code>Disabled</code>，则<code>TickType_t</code>是<code>uint32_t</code>类型，否则，是<code>uint16_t</code>类型。Contex-M架构上<code>TickType_t</code>是<code>uint32_t</code>类型</td></tr><tr><td><code>IDLE_SHOULD_YIELD</code></td><td><code>Enabled</code></td><td>空闲任务是否对同优先级的任务主动让出CPU使用权</td></tr><tr><td><code>USE_MUTEXES</code></td><td><code>Enabled</code></td><td>是否使用互斥量，<strong>只能选择<code>Enabled</code></strong></td></tr><tr><td><code>USE_RECURSIVE_MUTEXES</code></td><td><code>Enabled</code></td><td>是否使用递归互斥量，<strong>只能选择<code>Enabled</code></strong></td></tr><tr><td><code>USE_COUNTING_SEMAPHORES</code></td><td><code>Enabled</code></td><td>是否使用计数信号量，<strong>只能选择<code>Enabled</code></strong></td></tr><tr><td><code>QUEUE_REGISTRY_SIZE</code></td><td>8</td><td>可注册的队列和信号量的最大数量，设置范围为0至255，<strong>使用内核调试器查看信号量和队列时，需要先注册队列和信号量</strong></td></tr><tr><td><code>USE_APPLICATION_TASK_TAG</code></td><td><code>Disabled</code></td><td>是否使用应用程序的任务标签，若对应的宏是1，则会编译一些代码段，特别是文件<code>tasks.c</code>中的3个相关函数：<br><code>vTaskSetApplicationTaskTag()</code><br><code>xTaskGetApplicationTaskTag()</code><br><code>xTaskGetApplicationTaskHook()</code></td></tr><tr><td><code>ENABLE_BACKWARD_COMPATIBILITY</code></td><td><code>Enabled</code></td><td>是否向后兼容旧的版本</td></tr><tr><td><code>USB_PORT_OPTIMISED_TASK_SELECTION</code></td><td><code>Disabled</code></td><td>任务调度时，选择下一个运行任务的方法，Disbaled表示通用的方法，不依赖于具体的硬件，在使用Cortex-M0或CMSIS-RTOSV2，只能是Disbaled</td></tr><tr><td><code>USE_TICKLESS_IDLE</code></td><td><code>Disbaled</code></td><td>是否使用无节拍的低功耗模式。若是设置为<code>Enabled</code>，可自动进入低功耗模式，降低系统功耗。</td></tr><tr><td><code>USE_TASK_NOTIFICATIONS</code></td><td><code>Enabled</code></td><td>是否使用任务通知功能。若设置为<code>Enabled</code>，则编译相关的函数，每个人物的栈多消耗8字节空间</td></tr><tr><td><code>RECORE_STACK_HIGH_ADDRESS</code></td><td><code>Disabled</code></td><td>是否将栈的起始地址保存到每个任务的控制模块中(假设栈是向下生长的)</td></tr></tbody></table></div><ol><li><p><code>Memory management settings</code>：内存管理设置。内存管理的参数设置界面如下图所示，只有三个参数。</p><p> <img src="内存管理的参数设置界面.png" alt="内存管理的参数设置界面"></p></li></ol><ul><li><p><code>Memory Allocation</code>：内存分配方式，固定为<code>Dynamic/Static</code>，也就是同时支持动态分配和静态分配。这个参数对应于文件<code>FreeRTOSConfig.h</code>中的两个宏。</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_STATIC_ALLOCATION          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION         1</span></span><br></pre></td></tr></table></figure></li></ul><p>这个参数不能在CubeMX里面修改，但是可以在文件<code>FreeRTOSConfig.h</code>里面修改宏定义。</p><ul><li><code>TOTAL_HEAP_SIZE</code>：FreeRTOS总的堆空间大小，设置范围为<code>512B~128KB</code>.FreeRTOS中创建的所有对象，如任务、队列、软件定时器、信号量、互斥量等，都需要从FreeRTOS的堆空间分配内存。在CubeMX中，<code>FreeRTOS Heap Usage</code>页面显示了当前配置下，FreeRTOS的堆空间使用情况，如下图所示。界面中显示了剩余的可用内存，以及各个任务、各种对象使用的内存量。</li></ul><p><img src="FreeRTOS_Heap_Usage页面显示堆空间使用信息.png" alt="FreeRTOS Heap Usage页面显示堆空间使用信息"></p><ul><li><p><code>Memory Management scheme</code>：内存管理方案。有5种可选的内存管理方案，从<code>heap_1</code>到<code>heap_5</code>，使用哪种方案，就在文件<code>FreeRTOSConfig.h</code>中生成对应那种方案的宏定义。例如，使用方案<code>heap_4</code>，生成的宏定义如下：</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USE_FreeRTOS_HEAP_4</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><p><code>Hook function related definitions</code>：钩子函数相关定义，钩子函数类似回调函数，就是在某个功能或函数执行时要调用的一个函数。钩子函数的代码由用户编写，用于实现一些自定义的处理。钩子函数的数字界面如下图所示：</p><p> <img src="钩子函数的设置界面.png" alt="钩子函数的设置界面"></p><p> 默认情况下，这些参数值都是<code>Disable</code>，也就是不实现相应的钩子函数。如果设置<code>Enabled</code>，CubeMX会在文件<code>freertos.c</code>中自动生成相应钩子函数的函数框架。</p><p> <code>Hook function related definitions</code>各个参数意义以及设置为<code>Enabled</code>时对应的钩子函数名称如下：</p><p> | 钩子函数配置参数               | 调用场合                               | 对应的钩子函数名称                    |<br> | ——————————————— | ——————————————————— | ——————————————————- |<br> | <code>USE_IDLE_HOOK</code>                | 空闲任务里调用                         | <code>vApplicationIdleHook()</code>              |<br> | <code>USE_TICK_HOOK</code>                | 滴答定时器中断服务函数里调用           | <code>vApplicationTickHook()</code>              |<br> | <code>USE_MALLOC_FAILED_HOOK</code>       | 使用<code>pvPortMalloc()</code>分配内存失败时调用 | <code>vApplicationMallocFaileHook()</code>       |<br> | <code>USE_DAEMON_TASK_STARTUP_HOOK</code> | 守护(Daemon)任务启动时调用             | <code>vApplicationDaemonTaskStartupHook()</code> |<br> | <code>CHECK_FOR_STACK_OVERFLOW</code>     | 栈溢出时调用                           | <code>vApplicationStackOverflowHook()</code>     |</p><p> 其中<code>CHECK_FOR_STACK_OVERFLOW</code>的选项比较特殊，它提供<code>Option1</code>和<code>Option2</code>两个选项，对应与FreeRTOS内部两种不同的栈溢出处理方法，但是对应的钩子函数名称是相同的。 </p></li><li><p><code>Run time and task stats gathering related definitions</code>：运行时间和任务状态收集相关定义。FreeRTOS可以收集任务运行时间和任务状态信息，相关参数如下图所示：</p><p> <img src="运行时间和任务状态收集相关定义.png" alt="运行时间和任务状态收集相关定义"></p></li></ol><ul><li><code>GENERATE_RUN_TIME_STATS</code>：若设置为<code>Enabled</code>，则会启动任务运行时间统计功能，并可以通过函数<code>vTaskGetRunTimeStats()</code>读取这些信息。</li><li><code>USE_TRACE_FACILITY</code>：若设置为<code>Enabled</code>，则会增加一些结构体成员和函数，用于可视化和跟踪调试。</li><li><code>USE_STATS_FORMATTING_FUNCTIONS</code>：若<code>USE_TRACE_FACILITY</code>和这个参数都设置为<code>Enabled</code>，则会编译函数<code>vTaskList()</code>和<code>vTaskGetRunTimeStats()</code>。这两个参数中只要有一个设置为<code>Disabled</code>，就不会编译这个函数。</li></ul><ol><li><p><code>Co-routine related definitions</code>：协程相关定义。使用协程可以节省内存，主要用于功能有限、内存很小的MCU。现在的MCU内存一般比较充足，就很少使用协程了，所以禁用此功能即可。</p><p> <img src="协程相关定义.png" alt="协程相关定义"></p></li><li><p><code>Software timer definitions</code>：软件定时器定义。FreeRTOS可以创建软件定时器，其功能类似于高级语言(如C++)中的软件定时器。软件定时器相关参数的设置界面如下图所示：</p><p> <img src="软件定时器相关参数的设置界面.png" alt="软件定时器相关参数的设置界面"></p></li></ol><ul><li><code>USE_TIMERS</code>：是否使用软件定时器，默认设置为<code>Enabled</code>，且不可修改。</li><li><code>TIMER_TASK_PRIORITY</code>：定时器服务任务的优先级，默认值是2，属于比较低的优先级。设置范围是0到55，因为总的优先级个数是56。</li><li><code>TIMER_QUEUE_LENGTH</code>：定时器指令队列的长度，设置范围是1到255。</li><li><code>TIMER-TASK_STACK_DEPTH</code>：定时器服务任务的栈空间大小，默认值256个字，设置范围是128到32768个字。<strong>注意，栈空间的单位是字，而不是字节</strong>。</li></ul><ol><li><p><code>Interrupt nesting behaviour configuration</code>：中断嵌套行为配置。如下图所示：</p><p> <img src="中断嵌套行为配置.png" alt="中断嵌套行为配置"></p></li></ol><h4 id="3-3-2-INCLUDE-类的宏"><a href="#3-3-2-INCLUDE-类的宏" class="headerlink" title="3.3.2 INCLUDE_类的宏"></a>3.3.2 INCLUDE_类的宏</h4><p>前缀为<code>INCLUDE_</code>的宏，用作一些函数的条件编译的条件，控制是否编译这些函数的源代码，从而实现对FreeRTOS的功能裁剪。不编译应用程序中用不到的FreeRTOS API函数，可以使最终编译出的程序尽量小。</p><p>在文件<code>FreeRTOSConfig</code>和<code>FreeRTOS.h</code>中，都有<code>INCLUDE_</code>类的宏定义。与<code>config_</code>类的宏定义一样，文件<code>FreeRTOS.h</code>中的是默认的宏定义，例如，文件<code>FreeRTOS.h</code>中有如下的定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INCLUDE_vTaskDelete</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这表示如果没有宏定义<code>INCLUDE_vTaskDelete</code>，就将这个宏定义为0。文件<code>FreeRTOS.h</code>中的定义是默认定义，<strong>请勿直接修改文件<code>FreeRTOS.h</code>里的内容</strong>。</p><p>文件<code>FreeRTOSConfig.h</code>是用户可修改的配置文件，在CubeMX里设置的<code>INCLUDE_</code>参数会在这个文件里生成宏定义。例如，文件<code>FreeRTOSConfig.h</code>中部分<code>INCLUDE_</code>类的宏定义如下，其中就有宏定义<code>INCLUDE_vTaskDelete</code>，其值定义为1。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskPrioritySet            1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskPriorityGet           1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete                 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskCleanUpResources       0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskSuspend                1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelayUntil             1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelay                  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetSchedulerState      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTimerPendFunctionCall      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xQueueGetMutexHolder        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskGetStackHighWaterMark 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_eTaskGetState               1</span></span><br></pre></td></tr></table></figure><p>前缀为<code>INCLUDE_</code>的宏一般用于函数代码的条件编译，例如，函数<code>vTaskDelete()</code>的源代码就有如下的条件编译，这表示当参数<code>INCLUDE_vTaskDelete</code>值为1时，才编译函数<code>vTaskDelete()</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( INCLUDE_vTaskDelete == 1 )</span></span><br><span class="line"></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xTasksWaitingTermination = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>有些函数代码的编译条件还是多个参数的组合，例如，函数<code>eTaskGetState()</code>的编译条件如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )</span></span><br><span class="line">eTaskState <span class="title function_">eTaskGetState</span><span class="params">( TaskHandle_t xTask )</span></span><br><span class="line">&#123;</span><br><span class="line">        .......</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_eTaskGetState */</span></span></span><br></pre></td></tr></table></figure><p>在CubeMX的FreeRTOS配置部分，<code>Include parameters</code>页面用于设置<code>INCLUDE_</code>类宏的值，如下图所示：</p><p><img src="Include_parameters设置界面.png" alt="Include parameters设置界面"></p><h2 id="4、FreeRTOS的任务管理"><a href="#4、FreeRTOS的任务管理" class="headerlink" title="4、FreeRTOS的任务管理"></a>4、FreeRTOS的任务管理</h2><p> 一个嵌入式操作系统的核心功能就是多任务管理系统，<strong>FreeRTOS的任务调度器具有基于优先级的抢占式任务调度方式</strong>，能满足实时性的要求。下面，将简单介绍FreeRTOS的多任务运行原理，各种任务调度方法的特点与应用。</p><h3 id="4-1-任务相关的一些概念"><a href="#4-1-任务相关的一些概念" class="headerlink" title="4.1 任务相关的一些概念"></a>4.1 任务相关的一些概念</h3><h4 id="4-1-1-多任务运行基本机制"><a href="#4-1-1-多任务运行基本机制" class="headerlink" title="4.1.1 多任务运行基本机制"></a>4.1.1 多任务运行基本机制</h4><p><strong>在FreeRTOS中，一个任务就是实现某种功能的一个函数</strong>，任务函数的内部一般有一个死循环结构。在<strong>任何时候都不允许从任务函数退出，也就是不能出现<code>return</code>语句</strong>。<u>如果需要结束任务，在任务函数里，可以跳出死循环，然后使用函数<code>vTaskDelete()</code>删除任务自己，也可以在其他任务里调用函数<code>vTaskDelete()</code>删除这个任务。</u></p><p>在FreeRTOS里，用户可以创建多个任务。每个任务需要分配一个栈(stack)空间和一个任务控制块(Task Control Block,TCB)空间。每个任务还需要设定一个优先级，优先级的数字越小，表示优先级越低。</p><p>在单核处理器上，任何时刻只能有一个任务占用CPU并运行。但是在FreeRTOS系统上，运行多个任务时，运行起来却好像多个任务在同时运行，这是由于RTOS的任务调度使得多个任务对CPU实现了<strong>分时复用功能。</strong></p><p><img src="最简单的基于时间片的多任务运行原理.png" alt="最简单的基于时间片的多任务运行原理"></p><p>上图所示是最简单的基于时间片的多任务运行原理。假设只有两个任务，并且任务Task1和Task2具有相同的优先级。圆周表示CPU时间，如同钟表的一周，RTOS将CPU时间分成基本的时间片(time slice)，例如，<strong>FreeRTOS默认的时间片长度是1ms，也就是SysTick定时器的定时周期</strong>。在一个时间片内，会有一个任务占用CPU并执行，假设当前运行的任务是Task1。在一个时间片结束时(实际就是SysTick定时器发生中断时)进行任务调度，由于Task1和Task2具有相同的优先级，RTOS会将CPU使用权交给Task2。<strong>Task1交出CPU使用权时，会将CPU的当前场景(CPU各个核心寄存器的值)压入自己的栈空间，而Task2获取CPU使用权时，会用自己栈空间保存的数据恢复CPU场景，因而Task2可以从上次运行的状态继续运行</strong>。</p><p>基于时间片的多任务调度就是这样控制多个同等优先级任务实现CPU的分时复用，从而实现多任务运行的。因为时间片的长度很短(默认是1ms)，任务切换速度很快，所以程序运行时，给用户的感觉就像是同时在运行。</p><p>当多个任务的优先级不同时，FreeRTOS还会使用基于优先级的抢占式任务调度方法，每个人物获得的CPU使用时间长度是不同的。</p><h4 id="4-1-2-任务的状态"><a href="#4-1-2-任务的状态" class="headerlink" title="4.1.2 任务的状态"></a>4.1.2 任务的状态</h4><p>由单核CPU的多任务运行机制可知，任何时刻，只能由一个任务占用CPU并运行，这个任务的状态成为运行(running)状态，其它未占用CPU的任务的状态都可称为非运行(not running)状态。非运行状态又可以细分为3个状态（挂起状态、就绪状态、阻塞状态），任务的各个状态的切换如下所示：</p><p><img src="任务的状态以及状态之间的转换.png" alt="任务的状态以及状态之间的转换"></p><p>FreeRTOS任务调度有抢占式(pre-emptive)和合作式(co-operative)两种方式，一般使用<strong>基于任务优先级的抢占式任务调度方法</strong>。下面使用抢占式任务调度方法为例。</p><ol><li><strong>就绪状态</strong></li></ol><p>任务被创建之后就处于就绪(ready)状态。FreeRTOS的任务调度器在基础时钟每次中断时进行一次任务调度申请，根据抢占式任务调度的特点，任务调度的结果有以下几种情况。</p><ul><li>如果当前没有其他处于运行状态的任务，处于就绪状态的任务进入运行状态。</li><li>如果就绪任务的优先级高于或等于当前任务的优先级，处于就绪状态的任务进入运行状态。</li><li>如果就绪任务的优先级低于当前任务的优先级，处于就绪状态的任务无法获得CPU使用权，继续处于就绪状态。</li></ul><p>就绪的任务获取CPU的使用权，进入运行状态，这个过程称为切入(switch in)。相应的，处于运行状态的任务被调度器调度为就绪状态，这个过程称为切出(switch out)。</p><ol><li><strong>运行状态</strong></li></ol><p>在单核处理器上，占有CPU运行的任务就处于运行状态。处于运行状态的高优先级任务如果一直运行，将一直占用CPU，在任务调度时，低优先级的就绪任务就无法获得CPU的使用权，无法实现多任务的运行。因此，<strong>处于运行状态的任务，应该在空闲时让出CPU的使用权。</strong></p><p>处于就绪状态的任务，有两种方式可以让出CPU使用权的方法，<strong>一种是执行函数<code>vTaskSuspend()</code>进入挂起状态，另一种是执行阻塞式函数进入阻塞状态</strong>。这两种状态都是非运行状态，运行的状态就交出了CPU的使用权，任务调度器可以使其他就绪状态的任务进入运行状态。</p><ol><li><strong>阻塞状态</strong></li></ol><p><strong>阻塞(blocked)状态就是任务暂时让出CPU的使用权，处于等待的状态</strong>。运行状态的任务可以调用两类函数进入阻塞状态。</p><p>一类是时间延迟函数，如<code>vTaskDelay()</code>或<code>vTaskDelayUntil()</code>。处于运行状态的任务调用这类函数之后，就进入阻塞状态，并延迟指定时间。<strong>延迟时间到了之后，就又进入就绪状态，参与任务调度之后，又可以进入运行状态。</strong></p><p>另一类是用于进程间通信的事件请求函数，例如，请求信号量的函数<code>xSemaphoreTake()</code>。处于运行状态的任务执行函数<code>xSemaphoreTake()</code>后，就进入阻塞状态，如果其他任务释放了信号量，或等待的超时时间到了，任务就从阻塞状态进入就绪状态。</p><p>在运行状态的任务中调用函数<code>vTaskSuspend()</code>，可以间一个处于阻塞状态的任务转入挂起状态。</p><ol><li><strong>挂起状态</strong></li></ol><p><strong>挂起(suspended)状态的任务就是暂停的任务，不参与调度器的调度</strong>。其他3种状态的任务都可以通过<code>vTaskSuspend()</code>进入挂起状态。<strong>处于挂起状态的任务不能自动退出挂起状态，需要在其他任务里调用函数<code>vTaskResume()</code>，才能使一个挂起的任务变为就绪状态。</strong></p><h4 id="4-1-3-任务的优先级"><a href="#4-1-3-任务的优先级" class="headerlink" title="4.1.3 任务的优先级"></a>4.1.3 任务的优先级</h4><p>在FreeRTOS中，每个任务都必须设置一个优先级。总的优先级个数由文件<code>FreeRTOSConfig.h</code>中的宏<code>configAX_PRIORITIES</code>定义，默认值是56。<strong>优先级数字越小，优先级越低，所以最低优先级是0</strong>，在任务运行起来后，还可以修改优先级。多个任务可以具有相同的优先级。</p><p>另外，参数<code>configMAX_PRIORITIES</code>可设置的最大值，以及调度器决定那个就绪任务进入运行状态，还与参<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>的取值有关。根据这个参数的取值，任务调度器有两种方法。</p><p>(1) 通用方法。<strong>若<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>设置为0，则为通用方法</strong>。通用方法是使用C语言实现的，可以在所有的FreeRTOS移植版本上使用，<code>configMAX_PRIORITIES</code>的最大值页不受限制。</p><p>(2) 架构优化的方法。<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>设置为1，则为架构优化方法，部分代码是用汇编语言写的，运行速度比通用方法快。使用架构优化方法时，<code>configMAX_PRIORITIES</code>的最大值不能超过32。<strong>在使用Cortex-M0架构或CMSIS-RTOS V2接口时，不能使用架构优化方法。</strong></p><h4 id="4-1-4-空闲任务"><a href="#4-1-4-空闲任务" class="headerlink" title="4.1.4 空闲任务"></a>4.1.4 空闲任务</h4><p>在main()函数中，调用<code>osKernelStart()</code>启动FreeRTOS的任务调度器时，FreeRTOS会自动创建一个空闲任务(idle task)，空闲任务的优先级为0，也就是最低优先级。</p><p><strong>在FreeRTOS中，任何时候都需要有一个任务占用CPU，处于运行状态</strong>。如果用户创建的任务都不处于运行状态，空闲任务就占用CPU处于运行状态。</p><p>空闲任务是比较重要的。与空闲任务相关的配置函数有如下几个：</p><ul><li><code>configUSE_TICK_HOOK</code>：是否使用空闲任务的钩子函数，若配置为1，则可以利用空闲任务的钩子函数，在系统空闲时做一些处理。例如，利用空闲任务钩子函数使系统进入低功耗状态。</li><li><code>configIDLE_SHOULD_YIELD</code>：空闲任务是否对同等优先级的用户任务主动让出CPU使用权。</li><li><code>configUSE_TICKLESS_IDLE</code>：是否使用tickless低功耗模式，若设置为1，可以实现系统的低功耗。</li></ul><h4 id="4-1-5-基础时钟与滴答信号"><a href="#4-1-5-基础时钟与滴答信号" class="headerlink" title="4.1.5 基础时钟与滴答信号"></a>4.1.5 基础时钟与滴答信号</h4><p>FreeRTOS自动采用SysTick定时器作为FreeRTOS的基础时钟。<strong>SysTick定时器只有定时器中断功能，其定时频率由参数<code>configTICK_RATE_HZ</code>指定，默认值为1000，也就是1ms中断一次</strong>。</p><p>在FreeRTOS中有一个全局变量<code>xTickCount</code>，在SysTick每次中断时，这个变量加1，也就是1ms变化一次。所谓的FreeRTOS滴答信号，就是指全局变量<code>xTickCount</code>的值发生变化的值，延时函数<code>vTaskDelay()</code>和<code>vTaskDelayUntil()</code>就是通过滴答信号实现毫秒延时的。</p><p><strong>SysTick定时器中断不仅用于产生滴答信号，还用于产生任务切换申请</strong>。</p><h3 id="4-2-FreeRTOS任务调度"><a href="#4-2-FreeRTOS任务调度" class="headerlink" title="4.2 FreeRTOS任务调度"></a>4.2 FreeRTOS任务调度</h3><h4 id="4-2-1-任务调度方法概述"><a href="#4-2-1-任务调度方法概述" class="headerlink" title="4.2.1 任务调度方法概述"></a>4.2.1 任务调度方法概述</h4><p>FreeRTOS有两种调度算法，<strong>基于优先级的抢占式调度算法</strong>与<strong>合作式调度算法</strong>。其中抢占式调度算法可以使用时间片，也可以不使用时间片。通过参数的设置，用户可以选择具体的调度算法。FreeRTOS的任务调度方法有三种。其对应的参数名称、取值及特点如下：</p><p><img src="FreeRTOS的任务调度方法.png" alt="FreeRTOS的任务调度方法"></p><p>在FreeRTOS中，默认的是<strong>使用带有时间片的抢占式任务调度方法</strong>。在CubeMX中用户不能设置参数<code>configUSE_TIME_CLICING</code>，其值默认为1。</p><h4 id="4-2-2-使用时间片的抢占式调度方式"><a href="#4-2-2-使用时间片的抢占式调度方式" class="headerlink" title="4.2.2 使用时间片的抢占式调度方式"></a>4.2.2 使用时间片的抢占式调度方式</h4><p>抢占式任务调度方式，是FreeRTOS主动进行任务调度，分为使用时间片贺不适用时间片两种情况。<strong>FreeRTOS基础时钟的一个定时周期称为一个时间片，FreeRTOS的基础时钟是SysTick定时器。基础时钟的定时周期由参数<code>configTICK_RATE_HZ</code>决定，默认值为1000Hz，所以时间片时长为1ms。</strong>当使用时间片时， 在基础时钟的每次中断里，系统会要求进行一次<strong>上下文切换</strong>。文件<code>port.c</code>中的函数<code>xPortSysTickHandler()</code>就是SysTick定时中断的处理函数，其代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xPortSysTickHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*!&lt; SysTick中断的抢占优先级时15，优先级最低，所以使用这个中断时需要禁用所有中断 */</span></span><br><span class="line">portDISABLE_INTERRUPTS(); <span class="comment">/*!&lt; 禁用所有中断 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Increment the RTOS tick. */</span></span><br><span class="line"><span class="keyword">if</span>( xTaskIncrementTick() != pdFALSE ) <span class="comment">/*!&lt; 增加RTOS滴答计数器的值 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*!&lt;将PendSV中断的挂起标志位置位，申请进行上下文切换，在PenSV中断里处理上下文切换*/</span></span><br><span class="line">portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">portENABLE_INTERRUPTS(); <span class="comment">/*!&lt; 使能中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的功能是将PendSV(Pendable request for system serivce，可挂起的系统服务请求)中断的挂起标志位置位，也就是发起上下文切换的请求，<strong>而进行上下文切换是在PendSV的中断服务函数里面完成的</strong>。文件<code>port.c</code>中的函数<code>xPortPendSVHandler()</code>是FreeRTOS的PendSV中断服务函数，其功能就是<strong>根据任务调度计算的结果，选择下一个任务进入运行状态</strong>。</p><p>在CubeMX中，一个项目使用了FreeRTOS之后，会自动对NVIC做一些设置。<strong>系统自动将优先级分组方案设置为4位全部用于抢占式优先级</strong>，SysTick和PendSV中断的抢占式优先级都是15，也就是最低优先级。<strong>FreeRTOS在最低优先级的PendSV的中断服务函数里进行上下文切换，所以，FreeRTOS的任务切换的优先级总是低于系统中断的优先级。</strong></p><p>使用时间片的抢占式调度方法特点如下：</p><ul><li>在基础时钟每个中断里发起一次任务调度请求。</li><li>在PendSV中断服务函数里进行上下文切换。</li><li>在上下文切换时，高优先级的就绪任务获得CPU的使用权。</li><li>若多个就绪状态的任务的优先级相同，则将轮流获得CPU的使用权。</li></ul><p>如下图所示是使用带时间片的抢占式任务调度方法时，3个任务运行的时序图，其中Task2具有高优先级，Task1具有正常优先级，且这两个任务的优先级都高于空闲任务的优先级。</p><p><img src="带时间片的抢占式任务调度方法任务运行时序图.png" alt="带时间片的抢占式任务调度方法任务运行时序图"></p><p>可以从图上看到具体的任务运行和切换过程如下：</p><ul><li><em>t</em>1时刻开始是空闲任务在运行，这时候系统里面没有其他任务处于就绪状态。</li><li>在<em>t</em>2时刻进行调度时，Task1抢占CPU开始运行。</li><li>在<em>t</em>3时刻，Task1进入阻塞状态，暂时让出CPU使用权，空闲任务又进入运行状态。</li><li>在<em>t</em>4时刻，Task1又进入运行状态。</li><li>在<em>t</em>5时刻，更高优先级的Task2抢占了CPU开始运行，Task1进入就绪状态。</li><li>在<em>t</em>6时刻，Task2运行后进入阻塞状态，让出CPU使用权，Task1从就绪状态变为运行状态。</li><li>在<em>t</em>7时刻，Task1进入阻塞状态，空闲任务又进入运行状态。</li></ul><p>可以看出，<strong>在低优先级任务运行时，高优先级的任务能抢占获得CPU的使用权。在没有其他任务运行时，空闲任务处于运行状态，否则，空闲状态处于就绪状态</strong>。</p><p><strong>当多个就绪状态的任务优先级相同时，它们将轮流获得CPU的使用，每个任务占用CPU运行1个时间片的时间</strong>。</p><p><strong>如果就绪任务的优先级与空闲任务的优先级都相同时，参数<code>configIDLE_SHOULD_YIELD</code>就会影响任务调度的结果</strong>。</p><ul><li>如果<code>configIDLE_SHOULD_YIELD</code>设置为0，表示<strong>空闲任务不会主动让出CPU的使用权，空闲任务与其他优先级为0的就绪任务轮流使用CPU</strong>。</li><li>如果<code>configIDLE_SHOULD_YIELD</code>设置为1，表示<strong>空闲任务会主动让出CPU的使用权，空闲任务不会占用CPU</strong>。</li></ul><p>参数<code>configIDLE_SHOULD_YIELD</code>的默认值为1。设计用户任务时，用户任务的优先级一般要高于空闲任务。</p><h4 id="4-2-3-不使用时间片的抢占式调度方法"><a href="#4-2-3-不使用时间片的抢占式调度方法" class="headerlink" title="4.2.3 不使用时间片的抢占式调度方法"></a>4.2.3 不使用时间片的抢占式调度方法</h4><p>当配置为不使用时间片的抢占式调度方法时，任务选择和抢占式的算法是错误的，只是<strong>对于相同优先级的任务，不再使用时间片平均分配CPU使用时间</strong>。</p><p>使用时间片的抢占式调度算法，在基础时钟每次中断时进行一次上下文切换请求，从而进行任务调度；而不使用时间片的抢占式调度算法，只在以下情况下才进行任务调度。</p><ul><li>有更高优先级的任务进入就绪状态时。</li><li>运行状态的任务进入阻塞状态或挂起状态时。</li></ul><p>所以，<strong>不使用时间片时，进行上下文切换的频率比使用时间片时低</strong>，从而可降低CPU的负担。但是，<strong>对于同等优先级的任务，可能会出现占用CPU时间相差很大的情况</strong>。</p><p>如下图所示的是不适用时间片的抢占式任务调度方式，存在同等优先级任务时的任务运行时序图。</p><p><img src="不使用时间片的抢占式任务调度方法，存在同等优先级任务运行时序图.png" alt="不使用时间片的抢占式任务调度方法，存在同等优先级任务运行时序图"></p><p>其中，Task0与空闲任务优先级相同，且是连续运行的。具体任务运行和切换过程如下：</p><ul><li>在<em>t</em>1时刻，空闲任务占用CPU，因为系统里没有其他处于就绪状态的任务。</li><li>在<em>t</em>2时刻，Task0进入就绪状态，但是Task0与空闲任务优先级相同，且调度算法不使用时间片，不会让Task0和空闲任务轮流使用CPU，所以Task0就保持就绪状态。</li><li>在<em>t</em>4时刻，高优先级的Task1抢占CPU。</li><li>在<em>t</em>5时刻，Task1进入阻塞状态，系统进行一次任务调度，Task0获得CPU的使用权。</li><li>在<em>t</em>6时刻，Task1再次抢占Task0又进入就绪状态。</li><li>在<em>t</em>7时刻，Task1进入阻塞状态，系统进行一次任务调度，空闲任务获得CPU使用权。之后没有发生任务调度的机会，所以Task0就一直处于就绪状态。</li></ul><h4 id="4-2-4-合作式任务调度方法"><a href="#4-2-4-合作式任务调度方法" class="headerlink" title="4.2.4 合作式任务调度方法"></a>4.2.4 合作式任务调度方法</h4><p>使用合作式任务调度方法时，FreeRTOS不主动进行上下文切换，而是<strong>当运行状态的任务进入阻塞状态时，或运行状态的任务调用函数<code>taskYIELD()</code>时，才会进行一次上下文切换</strong>。任务不会发生抢占，所以也不使用时间片。函数<code>taskYIELD()</code>的作用就是主动申请进行一次上下文切换。</p><p>如下图时使用合作式任务调度方法时，3个不同优先级的任务时序图，可以体现合作式任务调度方法的特点。</p><p><img src="使用合作式任务调度方法的任务运行时序图.png" alt="使用合作式任务调度方法的任务运行时序图"></p><ul><li>在<em>t</em>1时刻，低优先级的Task1处于运行状态。</li><li>在<em>t</em>2时刻，中等优先级的Task2进入就绪状态，但不能抢占CPU。</li><li>在<em>t</em>3时刻，高优先级的Task3进入就绪状态，但是也不能抢占CPU。</li><li>在<em>t</em>4时刻，Task1调用函数<code>taskYIELD()</code>，主动申请进行一次上下文切换，高优先级的Task3获得CPU使用权。</li><li>在<em>t</em>5时刻，Task3进入阻塞状态，就绪的Task2获得CPU的使用权。</li><li>在<em>t</em>6时刻，Task2进入阻塞状态，Task1又获得CPU使用权。</li></ul><h3 id="4-3-任务管理相关函数"><a href="#4-3-任务管理相关函数" class="headerlink" title="4.3 任务管理相关函数"></a>4.3 任务管理相关函数</h3><h4 id="4-3-1-相关函数概述"><a href="#4-3-1-相关函数概述" class="headerlink" title="4.3.1 相关函数概述"></a>4.3.1 相关函数概述</h4><p>在FreeRTOS中，任务的管理主要包括<strong>任务的创建、删除、挂起、恢复</strong>等操作，还包含<strong>任务调度器的启动、挂起与恢复，以及使任务进入阻塞状态的延迟函数等</strong>。</p><p>FreeRTOS中任务管理相关的函数都在文件<code>task.h</code>中定义，在文件<code>tasks.c</code>中实现。在CMSIS-RTOS中还有一些函数，对FreeRTOS的函数进行了封装，也就是调用相应的FreeRTOS函数实现相同的功能，这些标准接口函数的定义在文件<code>cmsis_os.h</code>和<code>cmsis_os2.h</code>中。<strong>CubeMX生成的代码一般使用CMSIS-RTOS标准接口函数，在用户自己编写的程序中，一般直接使用FreeRTOS的函数</strong>。</p><p>任务管理常用的一些函数及其功能如下：</p><p><img src="任务管理常用的一些函数及其功能描述.png" alt="任务管理常用的一些函数及其功能描述"></p><p>上表中的FreeRTOS函数基本都有对应的CMSIS-RTOS标准函数，只有以下几个比较特殊。</p><ul><li>FreeRTOS创建任务的函数有两个，<strong><code>xTaskCreate()</code>用于创建动态分配内存的任务</strong>，<strong><code>xTaskCreateStatic()</code>用于创建静态分配内存的任务</strong>。对应的CMSIS-RTOS标准函数<code>osThreadNew()</code>会根据任务的参数自动调用其中的某个函数。</li><li><p>函数<code>vTaskDelete()</code>可以根据传递传递的参数不同，删除另一个任务或当前任务，对应的CMSIS-RTOS标准函数有两个，<strong><code>osThreadTerminate()</code>用于删除另一个任务，<code>osThreadExit()</code>用于删除当前任务</strong>。</p></li><li><p>函数<code>xTaskAbortDelay()</code><strong>用于终止另一个任务的延时，使其退出阻塞状态</strong>，这个函数没有对应的CMSIS-RTOS的函数。</p></li></ul><p>除了上述这些函数，文件<code>task.h</code>中还有几个常用的宏函数，其定义代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskDISABLE_INTERRUPTS() portDISABLE_INTERRUPTS() <span class="comment">//关闭MCU所有可屏蔽中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENABLE_INTERRUPTS() portENABLE_INTERRUPTS()   <span class="comment">//使能MCU的中断</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL() portENTER_CRITICAL()         <span class="comment">//开始临界代码段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL()portEXIT_CRITICAL()      <span class="comment">//结束临界代码段</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL_FROM_ISR(x) portCLEAR_INTERRUPT_MASK_FROM_ISR(x)</span></span><br></pre></td></tr></table></figure><ul><li>宏函数<code>taskDISABLE_INTERRUPTS()</code>和<code>taskENABLE_INTERRUPTS()</code>用于关闭和开启MCU的可屏蔽中断，<strong>用于界定不受其他中断干扰的代码段</strong>。<strong>只能关闭FreeRTOS可管理的中断优先级</strong>，即参数<code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>定义的最高优先级。<strong>这两个函数必须成对使用，且不能嵌套使用</strong>。</li><li>函数<code>taskENTER_CRITICAL()</code>和<code>taskEXIT_CRITICAL()</code>用于界定临界代码段。<strong>在临界代码段内，任务不会被更高优先级的任务抢占</strong>，可以保证代码执行的连续性。<em>例如，一段代码需要通过串口上传一批数据，如果被更高优先级的任务抢占了PCU的使用权，上传的过程被打断，上传数据就可能出现问题，这时就可以将这段代码界定为临界代码段</em>。函数<code>taskENTER_CRITICAL()</code>内部会调用关闭可屏蔽中断的函数<code>portDISABLE_INTERRUPTS()</code>，与宏函数<code>taskDISABLE_INTERRUPTS()</code>实现的功能相似。<strong>函数<code>taskENTER_CRITICAL()</code>和<code>taskEXIT_CRITICAL()</code>必须成对使用，但可以嵌套使用</strong>。</li><li><code>taskENTER_CRITICAL_FROM_ISR()</code>是<code>taskENTER_CRITICAL()</code>的ISR版本，用于在终端服务例程中调用。<em>注意，FreeRTOS的所有API函数分为普通版本和ISR版本，<strong>如果要在ISR里面调用FreeRTOS的API函数，必须使用其ISR版本</strong></em>。</li></ul><h4 id="4-3-2-主要函数功能说明"><a href="#4-3-2-主要函数功能说明" class="headerlink" title="4.3.2 主要函数功能说明"></a>4.3.2 主要函数功能说明</h4><ol><li><strong>创建任务</strong></li></ol><p>在之前的LED翻转实验中可以看到，CubeMX生成的代码中，在<code>MX_FREERTOS_Init()</code>中使用函数<code>osThreadNew()</code>创建任务，根据任务的属性设置，<code>osThreadNew()</code>内部会自动调用<code>xTaskCreate()</code>以动态分配内存的方式创建任务，或者调用<code>xTaskCreateStatic()</code>以静态分配内存方式创建任务。函数<code>osThreadNew()</code>的原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, <span class="type">void</span> *argument, <span class="type">const</span> osThreadAttr_t *attr)</span></span><br></pre></td></tr></table></figure><p>返回的数据是所创建任务的句柄，数据类型<code>osThreadID_t</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *osThreadId_t;</span><br></pre></td></tr></table></figure><p>使用动态分配内存方式创建任务的函数为<code>xTaskCreate()</code>，其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(TaskFunction_t pxTaskCode,       <span class="comment">//任务函数名称</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,                  <span class="comment">//任务的备注名称</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,  <span class="comment">//栈空间大小，单位：字</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvParameters,                  <span class="comment">//传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,                     <span class="comment">//任务优先级</span></span></span><br><span class="line"><span class="params">TaskHandle_t * <span class="type">const</span> pxCreatedTask)</span>         <span class="comment">//任务的句柄</span></span><br></pre></td></tr></table></figure><p>函数<code>xTaskCreate()</code>返回值的类型为<code>BaseType_t</code>，若其值为<code>pdPASS</code>表示任务创建成功。创建的任务的句柄是函数中的参数<code>pxCreateTask</code>，其类型是<code>TaskHandle_t</code>。这个类型的定义与<code>osThreadID_t</code>是相同的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *TaskHandle_t;</span><br></pre></td></tr></table></figure><p>使用静态分配内存方式创建任务的函数为<code>xTasskCreateStatic()</code>，其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">(TaskFunction_t pxTaskCode,<span class="comment">//任务函数名称</span></span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,                   <span class="comment">//任务的备注名称</span></span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,                 <span class="comment">//栈空间大小，单位：字</span></span></span><br><span class="line"><span class="params">            <span class="type">void</span> * <span class="type">const</span> pvParameters,                   <span class="comment">//传递给任务函数的参数</span></span></span><br><span class="line"><span class="params">            UBaseType_t uxPriority,                      <span class="comment">//任务优先级</span></span></span><br><span class="line"><span class="params">            StackType_t * <span class="type">const</span> puxStackBuffer,          <span class="comment">//任务的栈空间数组</span></span></span><br><span class="line"><span class="params">            StaticTask_t * <span class="type">const</span> pxTaskBuffer)</span>           <span class="comment">//任务控制块存储空间</span></span><br></pre></td></tr></table></figure><p>函数<code>xTaskCreateStatic()</code>返回的数据类型为<code>TaskHandle_t</code>，返回的数据就是所创建任务的句柄。</p><p><strong>用户可以在启动任务调度器之前创建所有的任务，也可以在启动任务调度器之后，在一个任务的任务函数里创建其他任务</strong>。</p><ol><li><strong>删除任务</strong></li></ol><p>删除任务的函数时<code>vTaskDelete()</code>，其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span></span><br></pre></td></tr></table></figure><p><code>TaskHandle_t</code>类型的参数<code>xTaskToDelete</code>是需要删除的任务的句柄。<strong>如果要删除任务自己，则传递参数<code>NULL</code>即可。</strong> <em>注意，如果要删除任务自己，<strong>必须在跳出任务死循环之后，在退出任务函数之前执行<code>vTaskDelete(NULL)</code></strong></em>。</p><p>删除任务时，FreeRTOS会自动释放系统自动分配的内存，如动态分配的占空间和任务控制块，但是<strong>在任务内由用户自己分配的内存，需要在删除任务之前手工释放</strong>。</p><ol><li><strong>挂起任务</strong></li></ol><p>挂起一个任务的函数为<code>vTaskSuspend()</code>，其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspend</span><span class="params">(TaskHandle_t xTaskToSuspend)</span>;</span><br></pre></td></tr></table></figure><p>参数<code>xTaskToSuspend</code>是需要挂起的任务的句柄，如果是要挂起任务自己，则传递参数<code>NULL</code>。被挂起的任务将不再参与任务调度，但是还存在于系统中，可以被恢复。</p><ol><li><strong>恢复任务</strong></li></ol><p>恢复一个挂起的任务的函数为<code>vTaskResume()</code>，其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">(TaskHandle_t xTaskToResume)</span>;</span><br></pre></td></tr></table></figure><p>参数<code>xTaskToResume</code>为需要恢复的任务的句柄，<strong>一个挂起的任务不能在任务函数里面恢复自己，只能在其他任务的函数里面恢复，所以参数不能是<code>NULL</code></strong>。</p><ol><li><strong>启动任务调度器</strong></li></ol><p>函数<code>vTaskStartScheduler()</code>可以用于启动任务调度器，开始FreeRTOS的运行，其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskStartScheduler</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure><p>函数<code>vTaskStartScheduler()</code>会自动创建一个空闲任务，空闲任务的优先级为0。如果设置参数<code>configUSE_TIMERS</code>的值为1，也就是需要软件定时器，还会自动创建一个<strong>时间守护任务</strong>。</p><ol><li><strong>延时函数</strong></li></ol><p>延时函数<code>vTaskDelay()</code>用于延时一定节拍数，它会使当前任务进入阻塞状态。<strong>任何任务都需要在空闲的时候进入阻塞状态</strong>，以让出CPU的使用权，是其他低优先级的任务可以获得CPU使用权，否则，一个高优先级的任务将总是占据CPU，导致其他低优先级的任务无法运行。函数<code>vTaskDelay()</code>的原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">(<span class="type">const</span> TickType_t xTicksToDelay)</span></span><br></pre></td></tr></table></figure><p>其中<code>xTicksToDelay</code>是需要延时的节拍数，是基础时钟的节拍数。<strong>一般，我们会结合宏函数<code>pdMS_TO_TICKS()</code>，将一个以毫秒为单位的时间转换为节拍数，然后调用<code>vTaskDelay()</code>，这样可以使延时时间不受FreeRTOS基础时钟频率变化的影响</strong>。</p><p>一般的，使用延时函数进入阻塞状态的任务函数的基本代码结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_Function</span><span class="params">(<span class="type">void</span> *argument)</span>&#123;</span><br><span class="line"><span class="comment">/*!&lt; 任务初始化 */</span></span><br><span class="line">TickType_t ticks2 = pdMS_TO_TICKS(<span class="number">500</span>); <span class="comment">//延时时间500ms转换为节拍数</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="comment">/*!&lt; 死循环内的功能代码 */</span></span><br><span class="line">vTaskDelay(ticks2); <span class="comment">//空闲时进行延时，进入阻塞状态</span></span><br><span class="line">&#125;</span><br><span class="line">vTaskDelete(<span class="literal">NULL</span>); <span class="comment">//如果跳出死循环，需要在函数退出前删除任务自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>绝对延时函数</strong></li></ol><p>绝对延时函数<code>vTaskDelayUntil()</code>的功能与延时函数<code>vTaskDelay()</code>的相似，也用于延时，并且使得任务进入阻塞状态。不同的是，<strong>函数<code>vTaskDelay()</code>的延时时间长度是相对于进入阻塞状态的时刻的</strong>，但是对于任务的死循环，一个循环的周期时间是不确定的，因为循环内执行的代码的时间长度是未知的，可能被其他任务抢占。</p><p>如果需要在任务函数内实现严格的周期性的循环，那么可以使用绝对延时函数<code>vTaskDelayUntil()</code>，其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">(TickType_t * <span class="type">const</span> pxPreviousWakeTime, <span class="type">const</span> TickType_t xTimeIncrement)</span></span><br></pre></td></tr></table></figure><p>其中<code>pxPreviousWakeTime</code>为上次任务唤醒时基础计数器的值，参数<code>xTimeIncrement</code>表示相当于上次唤醒时刻延时的节拍数。函数<code>vTaskDelayUntil()</code>每次会自动更新<code>pxPreviousWakeTime</code>的值，但是在第一次调用时，需要给一个初值。</p><p>函数<code>vTaskDelay()</code>和<code>vTaskDelayUntil()</code>的意义和区别如下图所示：</p><p><img src="函数vTaskDelay和vTaskDelayUntil的意义和区别.png" alt="函数vTaskDelay和vTaskDelayUntil的意义和区别"></p><p><strong>其中高电平为任务运行时间，低电平为阻塞时间</strong>。</p><p>用户可以通过函数<code>xTaskGetTickCount()</code>返回滴答信号当前计数值，作为<code>pxPreviousWakeTime</code>的初始值。使用<code>vTaskDelayUntil</code>的任务函数的一般代码结构如下，可以实现任务的循环周期为比较精确的1000ms。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_Function</span><span class="params">(<span class="type">void</span> *argument)</span>&#123;</span><br><span class="line"><span class="comment">/*!&lt; 任务初始化 */</span></span><br><span class="line">TickType_t previousWakeTime = xTaskGetTickCount();<span class="comment">//获得滴答信号当前计数值</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="comment">/*!&lt; 死循环内的功能代码 */</span></span><br><span class="line">vTaskDelayUntil(&amp;previousWakeTime, pdMS_TO_TICKS(<span class="number">1000</span>)); <span class="comment">//循环周期1000ms</span></span><br><span class="line">&#125;</span><br><span class="line">vTaskDelte(<span class="literal">NULL</span>);<span class="comment">//如果跳出死循环，需要在函数退出前删除任务自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-多任务编程示例（一）"><a href="#4-4-多任务编程示例（一）" class="headerlink" title="4.4 多任务编程示例（一）"></a>4.4 多任务编程示例（一）</h3><h4 id="4-4-1-示例功能与CubeMX项目设置"><a href="#4-4-1-示例功能与CubeMX项目设置" class="headerlink" title="4.4.1 示例功能与CubeMX项目设置"></a>4.4.1 示例功能与CubeMX项目设置</h4><p>设计一个示例，以测试FreeRTOS的多任务功能。使用战舰开发板作为开发平台，使用开发板上的两个LED灯，任务1里使LED1闪烁，任务2里使LED2闪烁。</p><p>在CubeMX中配置时钟与GPIO，与之前LED闪烁的配置类似，这里不再赘述，在FreeRTOS配置界面的<code>Tasks and Queues</code>中新建一个任务，并且将默认任务进行修改。</p><p><img src="两个任务的基本参数.png" alt="两个任务的基本参数"></p><p>本次示例的两个任务的设置有如下要点：</p><ul><li>两个任务的优先级都设置为<code>osPriorityNormal</code>，也就是具有相同的优先级。</li><li>两个任务采用了不同的内存分配方式，Task_LED0使用动态分配内存，Task_LED1使用静态分配内存。使用静态分配内存时，需要在设置作为占空间的数组名称以及控制块名称。</li></ul><h4 id="4-4-2-初始程序分析"><a href="#4-4-2-初始程序分析" class="headerlink" title="4.4.2 初始程序分析"></a>4.4.2 初始程序分析</h4><ol><li><strong>主程序</strong></li></ol><p>本示例中使用CubeMX生成的代码的主程序<code>main.c</code>代码和之前的LED闪烁示例中一样，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/*!&lt; 系统时钟配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">/*!&lt; FreeRTOS对象初始化函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line"> </span><br><span class="line">  osKernelInitialize(); <span class="comment">/*!&lt; 初始化FreeRTOS的调度器 */</span></span><br><span class="line">  MX_FREERTOS_Init();   <span class="comment">/*!&lt; FreeRTOS对象初始化函数 */</span></span><br><span class="line">  osKernelStart();      <span class="comment">/*!&lt; 启动FreeRTOS的任务调度器 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*!&lt; 程序无法运行到这里，因为RTOS的任务调度器接管了系统的控制 */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>任务的创建</strong></li></ol><p>使用CubeMX生成的<code>freertos.c</code>文件代码，基本上和之前的LED闪烁示例一样，只是多了一个<code>AppTask_LED1</code>任务。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> StaticTask_t osStaticThreadDef_t;</span><br><span class="line"><span class="comment">/* Definitions for Task_LED0 */</span></span><br><span class="line">osThreadId_t Task_LED0Handle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t Task_LED0_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;Task_LED0&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Definitions for Task_LED1 */</span></span><br><span class="line">osThreadId_t Task_LED1Handle;</span><br><span class="line"><span class="type">uint32_t</span> Task_LED1Buffer[ <span class="number">128</span> ];</span><br><span class="line">osStaticThreadDef_t Task_LED1ControlBlock;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t Task_LED1_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;Task_LED1&quot;</span>,</span><br><span class="line">  .cb_mem = &amp;Task_LED1ControlBlock,</span><br><span class="line">  .cb_size = <span class="keyword">sizeof</span>(Task_LED1ControlBlock),</span><br><span class="line">  .stack_mem = &amp;Task_LED1Buffer[<span class="number">0</span>],</span><br><span class="line">  .stack_size = <span class="keyword">sizeof</span>(Task_LED1Buffer),</span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN FunctionPrototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END FunctionPrototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* (MISRA C 2004 rule 8.1) */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  FreeRTOS initialization</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 创建任务Task_LED0 */</span></span><br><span class="line">  Task_LED0Handle = osThreadNew(AppTask_LED0, <span class="literal">NULL</span>, &amp;Task_LED0_attributes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建任务ask_LED1 */</span></span><br><span class="line">  Task_LED1Handle = osThreadNew(AppTask_LED1, <span class="literal">NULL</span>, &amp;Task_LED1_attributes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    osDelay(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    osDelay(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-编写用户功能代码"><a href="#4-4-3-编写用户功能代码" class="headerlink" title="4.4.3 编写用户功能代码"></a>4.4.3 编写用户功能代码</h4><p> 下面开始为两个任务函数编写代码，并且对任务的属性稍微做些修改，这样可以观察带时间片的抢占式任务调度方法的特点，以及<code>vTaskDelay()</code>和<code>vTaskDelayUntil()</code>等函数的使用方法。</p><ol><li><strong>相同优先级的任务的执行</strong></li></ol><p>在CubeMX的项目设置中，<strong>FreeRTOS使用默认的带时间片的抢占式任务调度方法</strong>，并且将两个任务的优先级都设置为<code>osPriorityNormal</code>，在文件<code>freertos.c</code>中，我们为两个任务的任务函数编写代码，使两个LED分别以不同的周期闪烁。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_LED0 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin);</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED0 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END Header_AppTask_LED1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_LED1 */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个任务函数的功能很简单，就是分别使LED0和LED1以不同的周期闪烁。注意，任务的延时函数使用<code>HAL_Delay()</code>而不是<code>osDelay()</code>，这样任务就不会进入阻塞状态，而是一直处于连续运行状态。</p><p>编译项目后，下载到战舰开发板运行，发现LED0和LED1都能闪烁，两个任务都可以执行。程序中两个任务与空闲任务的运行时序图如下所示：</p><p><img src="两个相同优先级的连续任务运行任务时序.png" alt="两个相同优先级的连续任务运行任务时序"></p><p><strong>带时间片的抢占式任务调度器会在基础是中每次中断时，进行一次任务调度申请，在没有其他中断处理时，就会进行任务调度</strong>。</p><p>两个任务具有相同的优先级，所以调度器使两个任务轮流占用CPU。<strong>两个任务都是连续运行的，所以每个任务每次占用CPU的时间都是一个滴答信号周期，不占用CPU时，就处于就绪状态</strong>。系统中还有一个空闲任务，但是因为用户的两个任务时连续执行的，且优先级高于空闲任务，所以空闲任务总是无法获得CPU的使用权，总是处于就绪状态。</p><ol><li><strong>低优先级任务被饿死的情况</strong></li></ol><p>修改<code>Task_LED1</code>任务优先级为<code>osPriorityBelowNormal</code>，<code>Task_LED0</code>仍然为<code>osPriorityNormal</code>，编译后，烧录到战舰开发板发现，只有LED0闪烁，LED1不闪烁。</p><p>这个程序中3个任务的运行时序图如下：</p><p><img src="两个连续执行的任务，高优先级任务总是占用CPU.png" alt="两个连续执行的任务，高优先级任务总是占用CPU"></p><p><code>Task_LED0</code>具有高优先级，而且是连续运行的，它会一直占用CPU，不会进入阻塞状态，所以低优先级的任务<code>Task_LED1</code>和空闲任务都无法使用CPU的使用权，只能一直处于就绪状态，它们被饿死了。</p><ol><li><strong>高优先级任务主动进入阻塞状态</strong></li></ol><p>再在2的程序上稍作修改，保持<code>Task_LED1</code>的优先级为<code>osPriorityBelowNormal</code>，<code>Task_LED0</code>仍然为<code>osPriorityNormal</code>。但是在任务中，进行一些改动如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_LED0 */</span></span><br><span class="line">  TickType_t ticks1 = pdMS_TO_TICKS(<span class="number">1000</span>); <span class="comment">//时间(ms)转换为节拍数(Ticks)</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin);</span><br><span class="line">    vTaskDelay(ticks1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED0 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE BEGIN Header_AppTask_LED1 */</span></span><br><span class="line"><span class="comment">/* USER CODE END Header_AppTask_LED1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_LED1 */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_LED1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对<code>Task_LED0</code>的任务函数代码进行了修改。<strong><code>pdMS_TO_TICKS()</code>宏函数的功能是将ms时间转换为基础时钟节拍数</strong>。将延时函数由<code>HAL_Delay()</code>替代为<strong><code>vTaskDelay()</code>，这个函数的作用不但包括延时，而且使当前任务进入阻塞状态，以便低优先级任务可以在任务调度时获得CPU的使用权。</strong></p><p>在这次改动中，并没有修改任务<code>Task_LED1</code>的任务函数代码，在for循环中，还是使用延时函数<code>HAL_Delay()</code>，所以任务<code>Task_LED1</code>还是连续运行的。</p><p>编译后，烧录到开发板运行，发现LED0和LED1都能闪烁，两个任务都能执行。以上程序中的3个任务运行时序如下所示：</p><p><img src="任务Task_LED0周期性进入阻塞状态，Task_LED1连续运行.png" alt="任务Task_LED0周期性进入阻塞状态，Task_LED1连续运行"></p><ul><li>在for循环里，任务<code>Task_LED0</code>每次执行完功能代码后，就调用<code>vTaskDelay()</code>函数延时1000ms，并且进入阻塞状态，所以任务<code>Task_LED0</code>大部分时间处于阻塞状态。</li><li>虽然任务<code>Task_LED1</code>的优先级比任务<code>Task_LED0</code>的低，但是在任务<code>Task_LED0</code>处于阻塞状态时，任务<code>Task_LED1</code>可以会的CPU的使用权。此外，因为<code>Task_LED1</code>是连续运行的，所以它占用了CPU的大部分时间。</li><li>任务<code>Task_LED0</code>在延时结束后，因为其优先级高，可以重新抢占CPU的使用权。</li><li>因为任务<code>Task_LED1</code>是连续运行的，不会进入阻塞状态，空闲任务还是无法获得CPU的使用权。</li></ul><ol><li><strong>任务函数设计的一般原则</strong></li></ol><p><u>在使用抢占式任务调度方法时，一般要根据任务的重要性分配不同的优先级，然后在任务函数里，在任务函数里，在任务空闲时让出CPU的使用权，进入阻塞状态，以便系统进行任务调度，使其他就绪状态的任务能获得CPU的使用权。</u>任务进入阻塞状态主要 有两种方式：<strong>一种是调用延时函数，如<code>vTaskDelay()</code></strong>；<strong>另一种是在进程间通信时，请求信号量、队列等事件</strong>。</p><p>再在3的程序上稍作修改，保持<code>Task_LED1</code>的优先级为<code>osPriorityBelowNormal</code>，<code>Task_LED0</code>仍然为<code>osPriorityNormal</code>。但是在任务中，进行一些改动如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TickType_t ticks0 = pdMS_TO_TICKS(<span class="number">1000</span>); <span class="comment">//时间(ms)转换为节拍数(Ticks)</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin);</span><br><span class="line">    vTaskDelay(ticks0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TickType_t ticks1 = pdMS_TO_TICKS(<span class="number">500</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);</span><br><span class="line">    vTaskDelay(ticks1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，烧录到开发板，发现LED0和LED1都能闪烁，两个任务都可以执行。以上程序中的3个任务运行时序如下所示：</p><p><img src="优化的任务运行模式.png" alt="优化的任务运行模式"></p><p>用户的两个任务<code>Task_LED0</code>和<code>Task_LED1</code>大部分时间处于阻塞状态，由系统的空闲任务获得CPU的使用权。这样可以降低CPU的负荷，使任务的调度更及时。<strong>一般的FreeRTOS嵌入式系统种，CPU的大部分时间就是处于空闲任务占据</strong>，如果将参数<code>configUSE_TICKLESS_IDLE</code>配置为1，还可以实现系统的低功耗。</p><ol><li><strong>使用<code>vTaskDelayUntil()</code>函数</strong></li></ol><p>在前文我们介绍过了<code>vTaskDelayUntil()</code>和<code>vTaskDelay()</code>的区别，如果要在任务函数的循环中实现严格的周期性，就应该使用<code>vTaskDelayUntil()</code>。我们对4中的程序稍作修改，在两个任务函数中使用<code>vTaskDelayUntil()</code>。修改后的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED0</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TickType_t ticks0 = pdMS_TO_TICKS(<span class="number">1000</span>); <span class="comment">//时间(ms)转换为节拍数(Ticks)</span></span><br><span class="line">  TickType_t previousWakeTime = xTaskGetTickCount();</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin);</span><br><span class="line">    vTaskDelayUntil(&amp;previousWakeTime, ticks0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_LED1</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  TickType_t ticks1 = pdMS_TO_TICKS(<span class="number">500</span>);</span><br><span class="line">  TickType_t previousWakeTime = xTaskGetTickCount();</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);</span><br><span class="line">    vTaskDelayUntil(&amp;previousWakeTime, ticks1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数<code>vTaskDelayUntil()</code>延时的时间是从任务上次转入运行时间开始的绝对时间，例如，在任务<code>Task_LED0</code>中执行的延时语句如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vTaskDelayUntil(&amp;previousWakeTime, ticks0);</span><br></pre></td></tr></table></figure><p>第一次执行时，需要通过函数<code>xTaskGetTickCount()</code>获取滴答信号的当前计数值，作为<code>previousWakeTime</code>的初始值。<strong>执行上面的语句，表示从<code>previousWakeTime</code>值开始延时<code>ticks0</code>个节拍，函数内会自动更新变量<code>previousWakeTime</code>的值，也会自动处理滴答信号计数值溢出的情况。</strong></p><p>编译后，烧录到开发板，发现LED0和LED1都能闪烁，两个任务都可以执行。以上程序中的3个任务运行时序如下所示：</p><p><img src="优化的任务运行模式.png" alt="优化的任务运行模式"></p><h3 id="4-5-任务管理工具函数"><a href="#4-5-任务管理工具函数" class="headerlink" title="4.5 任务管理工具函数"></a>4.5 任务管理工具函数</h3><h4 id="2-5-1-相关函数概述"><a href="#2-5-1-相关函数概述" class="headerlink" title="2.5.1 相关函数概述"></a>2.5.1 相关函数概述</h4><p>FreeRTOS中还有一些API函数，用于操作任务或者获取任务信息，这些函数及其基本功能如下：</p><p><img src="任务管理工具函数.png" alt="任务管理工具函数"></p><h4 id="2-5-2-获取任务句柄"><a href="#2-5-2-获取任务句柄" class="headerlink" title="2.5.2 获取任务句柄"></a>2.5.2 获取任务句柄</h4><p><strong>在单个任务进行操作的函数，一般需要一个<code>TaskHandle_t</code>类型的表示任务句柄的变量作为参数</strong>。在使用函数<code>osThreadNew()</code>创建任务时，会返回一个<code>osThreadId_t</code>类型的变量作为任务句柄。这两个类型的定义其实是一样的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *osThreadId_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *TaskHandle_t;</span><br></pre></td></tr></table></figure><p>所以用<code>osThreadNew()</code>创建任务获得的任务句柄变量，可以作为FreeRTOS任务操作函数的任务句柄输入参数。</p><p>FreeRTOS中还有3个用于获取任务句柄的函数。</p><ul><li>函数<code>xTaskGetCurrentTaskHandle()</code>，用于获取当前任务的句柄，其原型定义如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskGetCurrentTaskHandle</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>要使用这个函数，需要将参数<code>INCLUDE_xTaskGetCurrentTaskHandle</code>设置为1（默认为0），可以在CubeMX里设置。</strong></p><ul><li>函数<code>xTaskGetIdleTaskHandle()</code>，用于获得空闲任务的句柄，其原型定义如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskGetIdleTaskHandle</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>要使用这个函数，需要将参数<code>INCLUDE_xTaskGetIdleTaskHandle</code>设置为1（默认为0）。这个参数在CubeMX里面设置，需要用户在<code>FreeRTOSConfig.h</code>文件中自己添加宏定义，添加到文件<code>FreeRTOSConfig.h</code>的用户定义代码沙箱段，示例如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle 0</span></span><br></pre></td></tr></table></figure><ul><li>函数<code>xTaskGetHandle()</code>，用于通过任务名称获得任务句柄，其原型定义如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskGetHandle</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *pcNameToQuery )</span>;</span><br></pre></td></tr></table></figure><p>其中，参数<code>pcNameToQuery</code>是任务名称字符串，这个函数运行时间相对较长，不宜大量使用。<strong>如果两个任务具有相同的任务名称，则函数返回的结果是不确定的</strong>。函数使用示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *taskName = <span class="string">&quot;Task_LED0&quot;</span>;</span><br><span class="line">TaskHandle_t taskHandle = xTaskGetHandle(taskName);</span><br></pre></td></tr></table></figure><p>要使用这个函数，需要将参数<code>INCLUDE_xTaskGetHandle</code>设置为1（默认值为0），可以在CubeMX里设置。</p><h4 id="4-5-3-单个任务的操作"><a href="#4-5-3-单个任务的操作" class="headerlink" title="4.5.3 单个任务的操作"></a>4.5.3 单个任务的操作</h4><ol><li><strong>获取和设置任务的优先级</strong></li></ol><p>程序在运行时，可以获取或改变一个任务的优先级，相关的3个函数的原型定义如下。<strong>要使用这3个函数，需要将参数<code>INCLUDE_uxTaskPriorityGet</code>或<code>INCLUDE_vTaskPrioritySet</code>设置为1（默认值都是1），可以在CubeMX中设置。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">(TaskHandle_t xTask)</span>;<span class="comment">//返回一个任务的优先级</span></span><br><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGetFromISR</span><span class="params">(TaskHandle_t xTask)</span>;<span class="comment">//函数的ISR版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskPrioritySet</span><span class="params">(TaskHandle_t xTask, UBaseType_t uxNewPriority)</span>;<span class="comment">//设置优先级</span></span><br></pre></td></tr></table></figure><p>在这3个函数中，优先级用<code>UBaseType_t</code>类型的数表示，在文件<code>cmsis_os2.h</code>中，定义了优先级的枚举类型<code>osPriority_t</code>，其部分定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  osPriorityNone          =  <span class="number">0</span>,         <span class="comment">///&lt; No priority (not initialized).</span></span><br><span class="line">  osPriorityIdle          =  <span class="number">1</span>,         <span class="comment">///&lt; Reserved for Idle thread.</span></span><br><span class="line">  osPriorityLow           =  <span class="number">8</span>,         <span class="comment">///&lt; Priority: low</span></span><br><span class="line">  osPriorityLow1          =  <span class="number">8</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: low + 1</span></span><br><span class="line">  osPriorityLow2          =  <span class="number">8</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: low + 2</span></span><br><span class="line">  osPriorityLow3          =  <span class="number">8</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: low + 3</span></span><br><span class="line">  osPriorityLow4          =  <span class="number">8</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: low + 4</span></span><br><span class="line">  osPriorityLow5          =  <span class="number">8</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: low + 5</span></span><br><span class="line">  osPriorityLow6          =  <span class="number">8</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: low + 6</span></span><br><span class="line">  osPriorityLow7          =  <span class="number">8</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: low + 7</span></span><br><span class="line">  osPriorityBelowNormal   = <span class="number">16</span>,         <span class="comment">///&lt; Priority: below normal</span></span><br><span class="line">  osPriorityBelowNormal1  = <span class="number">16</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: below normal + 1</span></span><br><span class="line">  osPriorityBelowNormal2  = <span class="number">16</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: below normal + 2</span></span><br><span class="line">  osPriorityBelowNormal3  = <span class="number">16</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: below normal + 3</span></span><br><span class="line">  osPriorityBelowNormal4  = <span class="number">16</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: below normal + 4</span></span><br><span class="line">  osPriorityBelowNormal5  = <span class="number">16</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: below normal + 5</span></span><br><span class="line">  osPriorityBelowNormal6  = <span class="number">16</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: below normal + 6</span></span><br><span class="line">  osPriorityBelowNormal7  = <span class="number">16</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: below normal + 7</span></span><br><span class="line">  osPriorityNormal        = <span class="number">24</span>,         <span class="comment">///&lt; Priority: normal</span></span><br><span class="line">  osPriorityNormal1       = <span class="number">24</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: normal + 1</span></span><br><span class="line">  osPriorityNormal2       = <span class="number">24</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: normal + 2</span></span><br><span class="line">  osPriorityNormal3       = <span class="number">24</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: normal + 3</span></span><br><span class="line">  osPriorityNormal4       = <span class="number">24</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: normal + 4</span></span><br><span class="line">  osPriorityNormal5       = <span class="number">24</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: normal + 5</span></span><br><span class="line">  osPriorityNormal6       = <span class="number">24</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: normal + 6</span></span><br><span class="line">  osPriorityNormal7       = <span class="number">24</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: normal + 7</span></span><br><span class="line">  osPriorityAboveNormal   = <span class="number">32</span>,         <span class="comment">///&lt; Priority: above normal</span></span><br><span class="line">  osPriorityAboveNormal1  = <span class="number">32</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: above normal + 1</span></span><br><span class="line">  osPriorityAboveNormal2  = <span class="number">32</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: above normal + 2</span></span><br><span class="line">  osPriorityAboveNormal3  = <span class="number">32</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: above normal + 3</span></span><br><span class="line">  osPriorityAboveNormal4  = <span class="number">32</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: above normal + 4</span></span><br><span class="line">  osPriorityAboveNormal5  = <span class="number">32</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: above normal + 5</span></span><br><span class="line">  osPriorityAboveNormal6  = <span class="number">32</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: above normal + 6</span></span><br><span class="line">  osPriorityAboveNormal7  = <span class="number">32</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: above normal + 7</span></span><br><span class="line">  osPriorityHigh          = <span class="number">40</span>,         <span class="comment">///&lt; Priority: high</span></span><br><span class="line">  osPriorityHigh1         = <span class="number">40</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: high + 1</span></span><br><span class="line">  osPriorityHigh2         = <span class="number">40</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: high + 2</span></span><br><span class="line">  osPriorityHigh3         = <span class="number">40</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: high + 3</span></span><br><span class="line">  osPriorityHigh4         = <span class="number">40</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: high + 4</span></span><br><span class="line">  osPriorityHigh5         = <span class="number">40</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: high + 5</span></span><br><span class="line">  osPriorityHigh6         = <span class="number">40</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: high + 6</span></span><br><span class="line">  osPriorityHigh7         = <span class="number">40</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: high + 7</span></span><br><span class="line">  osPriorityRealtime      = <span class="number">48</span>,         <span class="comment">///&lt; Priority: realtime</span></span><br><span class="line">  osPriorityRealtime1     = <span class="number">48</span>+<span class="number">1</span>,       <span class="comment">///&lt; Priority: realtime + 1</span></span><br><span class="line">  osPriorityRealtime2     = <span class="number">48</span>+<span class="number">2</span>,       <span class="comment">///&lt; Priority: realtime + 2</span></span><br><span class="line">  osPriorityRealtime3     = <span class="number">48</span>+<span class="number">3</span>,       <span class="comment">///&lt; Priority: realtime + 3</span></span><br><span class="line">  osPriorityRealtime4     = <span class="number">48</span>+<span class="number">4</span>,       <span class="comment">///&lt; Priority: realtime + 4</span></span><br><span class="line">  osPriorityRealtime5     = <span class="number">48</span>+<span class="number">5</span>,       <span class="comment">///&lt; Priority: realtime + 5</span></span><br><span class="line">  osPriorityRealtime6     = <span class="number">48</span>+<span class="number">6</span>,       <span class="comment">///&lt; Priority: realtime + 6</span></span><br><span class="line">  osPriorityRealtime7     = <span class="number">48</span>+<span class="number">7</span>,       <span class="comment">///&lt; Priority: realtime + 7</span></span><br><span class="line">  osPriorityISR           = <span class="number">56</span>,         <span class="comment">///&lt; Reserved for ISR deferred thread.</span></span><br><span class="line">  osPriorityError         = <span class="number">-1</span>,         <span class="comment">///&lt; 系统无法确定或者非法的优先级</span></span><br><span class="line">  osPriorityReserved      = <span class="number">0x7FFFFFFF</span>  <span class="comment">///&lt; Prevents enum down-size compiler optimization.</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>用户可以在函数<code>vTaskPrioritySet()</code>中使用枚举类型，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TaskHandle_t taskHandle = xTaskGetCurrentTaskHandle();<span class="comment">//获取当前任务的句柄</span></span><br><span class="line">vTaskPrioritySet(taskHandle, (UBaseType_t)osPriorityAboveNormal);<span class="comment">//设置优先级</span></span><br></pre></td></tr></table></figure><ol><li><strong>函数<code>vTaskGetInfo()</code></strong></li></ol><p><code>vTaskGetInfo()</code>用于获取一个任务的信息，要使用这个函数，必须将参数<code>configUSE_TRACE_FACILITY</code>设置为1(默认值为1)，可在CubeMX里设置。这个函数的原型定义如下，各参数的意义见注释：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskGetInfo</span><span class="params">(TaskHandle_t xTask,<span class="comment">//任务的句柄</span></span></span><br><span class="line"><span class="params">                  TaskStatus_t *pxTaskStatus, <span class="comment">//用于存储任务状态信息的结构体指针</span></span></span><br><span class="line"><span class="params">                  BaseType_t xGetFreeStackSpace, <span class="comment">//是否返回栈空间高水位值</span></span></span><br><span class="line"><span class="params">                  eTaskState eState)</span>;<span class="comment">//指定任务的状态</span></span><br></pre></td></tr></table></figure><p>其中，参数<code>pxTaskStatus</code>是用于存储任务状态信息的TaskStatus_t结构体指针，这个结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xTASK_STATUS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TaskHandle_t xHandle;<span class="comment">//任务的句柄</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pcTaskName;<span class="comment">//任务的名称</span></span><br><span class="line">UBaseType_t xTaskNumber;<span class="comment">//任务的唯一编号</span></span><br><span class="line">eTaskState eCurrentState;<span class="comment">//任务的状态</span></span><br><span class="line">UBaseType_t uxCurrentPriority;<span class="comment">//任务的优先级</span></span><br><span class="line"><span class="comment">/* 在使用互斥量时，为避免优先级反转而继承的优先级，参数configUSE_MUTEXES设置为1时此变量才有意义 */</span></span><br><span class="line">UBaseType_t uxBasePriority;</span><br><span class="line"><span class="comment">/* 任务的总运行时间，configGENERATE_RUN_TIME_STATS设置为1时此变量才有意义 */</span></span><br><span class="line"><span class="type">uint32_t</span> ulRunTimeCounter;</span><br><span class="line">StackType_t *pxStackBase;<span class="comment">//指向栈空间的低地址</span></span><br><span class="line"><span class="type">uint16_t</span> usStackHighWaterMark;<span class="comment">//栈空间的高水位值，单位是字</span></span><br><span class="line">&#125; TaskStatus_t;</span><br></pre></td></tr></table></figure><p>其中，参数<code>eCurrentState</code>任务的状态是枚举类型，表示了任务的运行、就绪、阻塞、挂起等状态。其定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">eRunning = <span class="number">0</span>, <span class="comment">//运行状态</span></span><br><span class="line">eReady, <span class="comment">//就绪状态</span></span><br><span class="line">eBlocked, <span class="comment">//阻塞状态</span></span><br><span class="line">eSuspended, <span class="comment">//挂起状态，或无限等待时间的阻塞状态</span></span><br><span class="line">eDeleted, <span class="comment">//任务被删除，但是其任务控制块(TCB)还没有被释放</span></span><br><span class="line">eInvalid <span class="comment">//无效状态</span></span><br><span class="line">&#125; eTaskState;</span><br></pre></td></tr></table></figure><p>函数<code>vTaskGetInfo()</code>中的参数<strong><code>xGetFreeStackSpace</code>，表示是否在结构体<code>TaskStatus_t</code>中返回栈空间的高水位值<code>usStatusHighWaterMark</code>，如果<code>xGetFreeStatusSpace == pdTRUE</code>，就返回高水位值，因为返回任务的高水位值需要较长的时间，若<code>xGetFreeStackSpace == pdFALSE</code>，就可以忽略此过程。</strong></p><p><strong>函数<code>vTaskGetInfo()</code>中的参数<code>eState</code>用于指定查询信息时的任务状态</strong>，虽然结构体<code>TaskStatus_t</code>中由获取任务状态的成员变量，到那时不如直接赋值快。<strong>如果需要函数<code>vTaskGetInfo()</code>自动获取任务的状态，将参数<code>eState</code>设置为枚举值<code>eInvalid</code>即可。</strong></p><ol><li><strong>函数<code>pcTaskGetName()</code></strong></li></ol><p>函数<code>pcTaskGetName()</code>用于返回一个任务的任务名称字符串，其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">pcTaskGetName</span><span class="params">(TaskHandle_t xTaskToQuery)</span> ;</span><br></pre></td></tr></table></figure><p>如果要查询任务自己的任务名称，将参数<code>xTaskToQuery</code>设置为<code>NULL</code>即可。</p><ol><li><strong>函数<code>uxTaskGetStackHighWaterMark()</code></strong></li></ol><p>函数<code>uxTaskGetStackHighWaterMark()</code>用于获取一个任务的高水位值，其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetStackHighWaterMark</span><span class="params">(TaskHandle_t xTask)</span>;</span><br></pre></td></tr></table></figure><p>如果要查询任务自己的高水位值，将参数<code>xTask</code>设置为<code>NULL</code>即可。</p><p>若要使用这个函数，需要将参数<code>INCLUDE_eTaskGetState</code>或<code>configUSE_TRACE_FACILITY</code>设置为1，这两个参数默认值都是1，且都可以在CubeMX里设置。</p><h4 id="4-5-4-内核信息统计"><a href="#4-5-4-内核信息统计" class="headerlink" title="4.5.4 内核信息统计"></a>4.5.4 内核信息统计</h4><ol><li><strong>函数<code>uxTaskGetNumberOfTasks()</code></strong></li></ol><p>函数<code>uxTaskGetNumberOfTasks()</code>返回内核当前管理的任务的总数，包括就绪的、阻塞的、挂起的任务，<strong>也包括虽然删除了但还没有在空闲任务里释放的任务</strong>。其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetNumberOfTasks</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ol><li><strong>函数<code>vTaskList()</code></strong></li></ol><p>函数<code>vTaskList()</code>返回内核中所有任务的字符串列表信息，包括每个任务的名称、状态、优先级、高水位值、任务编号等。其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskList</span><span class="params">(<span class="type">char</span> * pcWriteBuffer)</span></span><br></pre></td></tr></table></figure><p>参数<code>pcWriteBuffer</code>是预先创建的一个字符数组的指针，用于储存返回的字符串信息。这个字符串数组必须足够大，FreeRTOS不会检查这个数组的大小。这个函数使用的示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> infoBuffer[<span class="number">3000</span>];</span><br><span class="line">vTaskList(infoBuffer);</span><br></pre></td></tr></table></figure><ol><li><strong>函数<code>uxTaskGetSystemState()</code></strong></li></ol><p>要使用这个函数，需要将参数<code>configUSE_TRACE_FACILITY</code>配置为1（默认值为1），可以在CubeMX里配置这个参数。</p><p>这个函数用于获得系统内所有任务的状态，为每个任务返回一个<code>TaskStatus_t</code>结构体数据，此结构体在函数<code>vTaskGetInfo()</code>部分介绍过。函数<code>uxTaskGetSystemState()</code>的原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetSystemState</span><span class="params">(TaskStatus_t * <span class="type">const</span> pxTaskStatusArray, <span class="type">const</span> UBaseType_t uxArraySize, <span class="type">uint32_t</span> * <span class="type">const</span> pulTotalRunTime)</span></span><br></pre></td></tr></table></figure><ul><li>参数<code>pxTaskStatusArray</code>是一个数组的指针，成员是结构体类型<code>TaskStatus_t</code>。需预先分配数组大小，必须大于或等于FreeRTOS内的任务数。返回的数据就储存在这个数组里，每个任务对应一个数组成员。</li><li>参数<code>uxArraySize</code>是数据<code>pxTaskStatusArray</code>的大小，表示数组<code>pxTaskStatusArray</code>的成员个数。</li><li>参数<code>pulTotalRunTime</code>用于返回FreeRTOS启动后总的运行时间，如果设置为<code>NULL</code>，则不返回这个数据。只有参数<code>configGENERATE_RUN_TIME_STATS</code>设置为1，才会返回这个数据，默认值为0，可在CubeMX里设置。</li></ul><p>函数的返回值是<code>uxTaskGetSystemState()</code>实际获取的任务信息的条数，也就是FreeRTOS中实际任务的个数，与函数<code>uxTaskGetNumberOfTasks()</code>返回的任务个数相同。</p><ol><li><strong>函数<code>vTaskGetRunTimeState()</code></strong></li></ol><p>要使用这个函数，必须将以下两个参数都设置为1。</p><ul><li><code>configGENERATE_RUN_TIME_STATS</code>，默认值为0，可在CubeMX里设置。</li><li><code>configUSE_STATS_FORMATTING_FUNCTIONS</code>，默认值为0，可在CubeMX里设置。</li></ul><p>函数<code>vTaskGetRunTimeState()</code>用于统计系统内每个任务的运行时间，包括绝对时间和占用CPU的百分比。其原型定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskGetRunTimeState</span><span class="params">(<span class="type">char</span> *pcWriteBuffer)</span>;</span><br></pre></td></tr></table></figure><p>参数<code>pcWriteBuffer</code>用于存储返回数据的字符数组，返回的数据以文字表格形式表示，与函数<code>vTaskList()</code>返回结果的方式类似。</p><p><strong>注意，函数<code>vTaskGetRunTimeStats()</code>运行时，会禁止所有中断，所以，不要在程序正常运行的时候使用这个函数，应该只在程序调试阶段使用。</strong></p><ol><li><strong>函数<code>xTaskGetSchedulerState()</code></strong></li></ol><p>这个函数返回调度器的状态，当以下两个参数中的某一个设置为1时，此函数就可用。</p><ul><li><code>INCLUDE_xTasskGetSchedulerState</code>，默认值为1，可在CubeMX设置</li><li><code>configUSE_TIMERS</code>，默认值为1，<strong>CubeMX里有这个参数，但不允许修改</strong>。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskGetSchedulerState</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>返回值用如下的3个宏定义常数表示任务调度器的状态：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskSCHEDULER_SUSPENDED( ( BaseType_t ) 0 ) <span class="comment">//被挂起</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskSCHEDULER_NOT_STARTED( ( BaseType_t ) 1 ) <span class="comment">//未启动</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskSCHEDULER_RUNNING( ( BaseType_t ) 2 ) <span class="comment">//正常运行</span></span></span><br></pre></td></tr></table></figure><h3 id="4-6-多任务编程示例（二）"><a href="#4-6-多任务编程示例（二）" class="headerlink" title="4.6 多任务编程示例（二）"></a>4.6 多任务编程示例（二）</h3><h4 id="4-6-1-示例功能与CubeMX项目设置"><a href="#4-6-1-示例功能与CubeMX项目设置" class="headerlink" title="4.6.1 示例功能与CubeMX项目设置"></a>4.6.1 示例功能与CubeMX项目设置</h4><p>创建工程<code>FreeRTOS_TwoTaskInfo</code>，在FreeRTOS中创建2个任务，任务<code>Task_ADC</code>通过ADC1采集电压值，在LCD上显示；任务<code>Task_Info</code>用于测试任务信息统计的一些工具函数，统计信息在LCD上显示。</p><ol><li><strong>ADC的设置</strong></li></ol><p>这次工程中，使用ADC1的通道1进行ADC电压采集，ADC1的模式设置如下所示：</p><p><img src="ADC1的参数设置结果.png" alt="ADC1的参数设置结果"></p><p>主要设置为独立模式、12为精度、数据右对齐、软件触发常规转换，无需开启ADC1的硬件中断。</p><ol><li><strong>FreeRTOS的设置</strong></li></ol><p>启用FreeRTOS，使用CMSIS_V2接口。<code>Config parameters</code>和<code>Include parameters</code>两个设置页面的参数都保持默认值。我们在FreeRTOS中创建2个任务，设置任务的参数，如下图所示：</p><p><img src="两个任务的主要参数.png" alt="两个任务的主要参数"></p><p><strong>两个任务的优先级不同，所以我们将栈空间大小都修改为256，并设置它们都使用动态分配内存方式。</strong></p><p><em>上图中两个任务的栈空间大小并不是随意给出的，是在程序运行过程中，通过统计栈空间的高水位值，给出的一个比较安全合理的值，给出的一个比较安全合理的值。栈空间大小，会导致栈空间溢出，程序无法正常运行，栈空间太大，会浪费内存。要设置合理的栈空间大小，最好在调试阶段统计一下任务的高水位值。</em></p><h4 id="4-6-2-程序功能实现"><a href="#4-6-2-程序功能实现" class="headerlink" title="4.6.2 程序功能实现"></a>4.6.2 程序功能实现</h4><ol><li><strong>主程序</strong></li></ol><p>完成设置后，CubeMX自动生成代码。其中主程序如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fsmc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_FSMC_Init();</span><br><span class="line">  MX_ADC1_Init();</span><br><span class="line">    </span><br><span class="line">  lcd_init();</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task Utilities&quot;</span>, RED);</span><br><span class="line">    </span><br><span class="line">  osKernelInitialize(); </span><br><span class="line">  MX_FREERTOS_Init();</span><br><span class="line">  osKernelStart();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在初始化部分，上述程序执行以下3个外设初始化函数。</p><ul><li><code>MX_GPIO_Init()</code>用于GPIO初始化，主要是两个LED的GPIO引脚的初始化。</li><li><code>MX_FSMC_Init()</code>用于FSMC连接TFT LCD接口的初始化。</li><li><code>MX_ADC1_Init()</code>用于ADC1的初始化。</li></ul><p>添加的两行用户代码，用于调用函数LCD的初始化函数，然后在LCD上显示项目文字信息。</p><ol><li><strong>FreeRTOS对象初始化</strong></li></ol><p>CubeMX自动生成的文件<code>freertos.c</code>包含两个任务的相关定义、FreeRTOS对象初始化函数<code>MX_FREERTOS_Init()</code>，以及两个任务函数的框架。对象初始化函数<code>MX_FREERTOS_Init()</code>相关代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adc.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Definitions for defaultTask */</span></span><br><span class="line">osThreadId_t defaultTaskHandle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t defaultTask_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;defaultTask&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">128</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Definitions for Task_ADC */</span></span><br><span class="line">osThreadId_t Task_ADCHandle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t Task_ADC_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;Task_ADC&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">256</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityNormal,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Definitions for Task_Info */</span></span><br><span class="line">osThreadId_t Task_InfoHandle;</span><br><span class="line"><span class="type">const</span> osThreadAttr_t Task_Info_attributes = &#123;</span><br><span class="line">  .name = <span class="string">&quot;Task_Info&quot;</span>,</span><br><span class="line">  .stack_size = <span class="number">256</span> * <span class="number">4</span>,</span><br><span class="line">  .priority = (osPriority_t) osPriorityLow,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartDefaultTask</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_ADC</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AppTask_Info</span><span class="params">(<span class="type">void</span> *argument)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* (MISRA C 2004 rule 8.1) */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    defaultTaskHandle = osThreadNew(StartDefaultTask, <span class="literal">NULL</span>, &amp;defaultTask_attributes);</span><br><span class="line">    Task_ADCHandle = osThreadNew(AppTask_ADC, <span class="literal">NULL</span>, &amp;Task_ADC_attributes);</span><br><span class="line">    Task_InfoHandle = osThreadNew(AppTask_Info, <span class="literal">NULL</span>, &amp;Task_Info_attributes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个任务的优先级不同，栈空间大小是256字，比默认的128字大。注意，<strong>在CubeMX中设置的参数<code>configMINIMAL_STACK_SIZE</code>，是系统自动创建的空闲任务的栈空间大小，其默认值是128字</strong>。</p><ol><li><strong>任务Task_ADC的功能实现</strong></li></ol><p>在任务<code>Task_ADC</code>里，我们对ADC1的IN1通道用轮询方式进行数据采集，并使用<code>vTaskDleayUntil()</code>函数实现比较精确的周期性采集。代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_ADC</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_ADC */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> adcVal = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> adcVal_True = <span class="number">0</span>;</span><br><span class="line">  lcd_show_string(<span class="number">0</span>, <span class="number">70</span>, <span class="number">500</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;=====================!&lt; Get ADC Value &gt;!=====================&quot;</span>, GREEN);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">90</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task_ADC: ADC by polling&quot;</span>, RED);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">110</span> ,<span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;ADC Value(mV) = &quot;</span>, RED);</span><br><span class="line">  TickType_t previousWakeTime = xTaskGetTickCount();</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">    <span class="keyword">if</span> (HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">100</span>) == HAL_OK) <span class="comment">//轮询方式等待转换完成</span></span><br><span class="line">    &#123;</span><br><span class="line">      adcVal = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">      adcVal_True = (<span class="number">3300</span> * adcVal) &gt;&gt; <span class="number">12</span>;</span><br><span class="line">      lcd_show_xnum(<span class="number">150</span>, <span class="number">110</span>, adcVal_True, <span class="number">5</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);</span><br><span class="line">    vTaskDelayUntil(&amp;previousWakeTime, pdMS_TO_TICKS(<span class="number">500</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对ADC以轮询方式进行数据采集的方式是：以<code>HAL_ADC_Start()</code>函数启动转换，然后调用函数<code>HAL_ADC_PollForConversion()</code>以轮询方式等待转换结束，并设置最多等待100ms。转换完成后，调用函数<code>HAL_ADC_GetValue()</code>读取ADC转换原始数值，ADC转换结果是12位有效右对齐数据，然后再转换成毫伏电压值显示。</p><ol><li><strong>任务<code>Task_Info</code>的功能实现</strong></li></ol><p>任务Task_Info主要用来测试一些任务管理函数，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AppTask_Info</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN AppTask_Info */</span></span><br><span class="line"><span class="comment">/*!&lt; ========获取单个任务的信息======== */</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetCurrentTaskHandle(); //获取当前任务句柄</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetIdleTaskHandle(); //获取空闲任务句柄</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetHandle(&quot;Task_ADC&quot;); //通过任务名称获取任务</span></span><br><span class="line">  TaskHandle_t taskHandle = Task_ADCHandle; <span class="comment">//直接使用任务名称获取任务句柄</span></span><br><span class="line">  </span><br><span class="line">  TaskStatus_t taskInfo; <span class="comment">//任务信息结构信息</span></span><br><span class="line">  BaseType_t getFreeStackSpace = pdTRUE; <span class="comment">//是否获取高水位值</span></span><br><span class="line">  eTaskState taskState = eInvalid; <span class="comment">//当前任务状态</span></span><br><span class="line">  vTaskGetInfo(taskHandle, &amp;taskInfo, getFreeStackSpace, taskState); <span class="comment">//获取任务信息</span></span><br><span class="line">  </span><br><span class="line">  taskENTER_CRITICAL(); <span class="comment">/* 临启临界代码段，不允许任务调度 */</span></span><br><span class="line">  lcd_show_string(<span class="number">0</span>, <span class="number">130</span>, <span class="number">500</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;===================!&lt; Get ADC Task Info &gt;!==================&quot;</span>, GREEN);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Get by vTaskGetInfo() &quot;</span>, RED);</span><br><span class="line">  </span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">170</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task Name = &quot;</span>, RED);</span><br><span class="line">  lcd_show_string(<span class="number">130</span>, <span class="number">170</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, (<span class="type">char</span> *)taskInfo.pcTaskName, BLUE);</span><br><span class="line">  </span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">190</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task Number = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">140</span>, <span class="number">190</span>, taskInfo.xTaskNumber, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line">  </span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">210</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task State = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">135</span>, <span class="number">210</span>, taskInfo.eCurrentState, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">230</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task Priority = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">155</span>, <span class="number">230</span>, taskInfo.uxCurrentPriority, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">250</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Stack High Water Mark = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">220</span>, <span class="number">250</span>, taskInfo.usStackHighWaterMark,<span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!&lt; 用函数uxTaskGetStackHighWaterMark()单独获取每个任务的高水位值 */</span></span><br><span class="line">  lcd_show_string(<span class="number">0</span>, <span class="number">270</span>, <span class="number">500</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;============!&lt; Get every task High Water Value &gt;!============&quot;</span>, GREEN);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">290</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;High Water Mark Of tasks&quot;</span>, RED);</span><br><span class="line"></span><br><span class="line">  taskHandle = xTaskGetIdleTaskHandle();</span><br><span class="line">  UBaseType_t highWaterMakr = uxTaskGetStackHighWaterMark(taskHandle);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">310</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Idle Task = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">125</span>, <span class="number">310</span>, highWaterMakr, <span class="number">3</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  taskHandle = Task_ADCHandle; <span class="comment">//Task_ADC任务句柄</span></span><br><span class="line">  highWaterMakr = uxTaskGetStackHighWaterMark(taskHandle);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">330</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task_ADC Task = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">155</span>, <span class="number">330</span>, highWaterMakr, <span class="number">3</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  taskHandle = Task_InfoHandle; <span class="comment">//Task_ADC任务句柄</span></span><br><span class="line">  highWaterMakr = uxTaskGetStackHighWaterMark(taskHandle);</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">350</span>, <span class="number">250</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task_Info Task = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">165</span>, <span class="number">350</span>, highWaterMakr, <span class="number">3</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!&lt; 获取内存的信息 */</span></span><br><span class="line">  lcd_show_string(<span class="number">0</span>, <span class="number">370</span>, <span class="number">500</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;====================!&lt; Get Kernel Info &gt;!====================&quot;</span>, GREEN);</span><br><span class="line">  UBaseType_t taskNum = uxTaskGetNumberOfTasks(); <span class="comment">//获取任务个数</span></span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">390</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;uxTaskGetNumberOfTask = &quot;</span>, RED);</span><br><span class="line">  lcd_show_xnum(<span class="number">220</span>, <span class="number">390</span>, taskNum, <span class="number">1</span>, <span class="number">16</span>, <span class="number">0</span>, BLUE);</span><br><span class="line"></span><br><span class="line">  taskEXIT_CRITICAL(); <span class="comment">//结束临界代码段，重新允许任务调度</span></span><br><span class="line">  UBaseType_t loopCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    loopCount++;</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">    vTaskDelay(pdMS_TO_TICKS(<span class="number">300</span>));</span><br><span class="line">    <span class="keyword">if</span> (loopCount == <span class="number">10</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lcd_show_string(<span class="number">30</span>, <span class="number">410</span>, <span class="number">200</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="string">&quot;Task_Info is deleted&quot;</span>, RED);</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">/* USER CODE END AppTask_Info */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段函数主要实现了以下几个功能。</p><p>(1) 使用函数<code>vTaskGetInfo()</code>获取一个任务的信息。首先要获取任务的句柄，程序用了多种方法获取任务句柄，即程序中的如下几行语句：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetCurrentTaskHandle(); //获取当前任务句柄</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetIdleTaskHandle(); //获取空闲任务句柄</span></span><br><span class="line"><span class="comment">//  TaskHandle_t taskHandle = xTaskGetHandle(&quot;Task_ADC&quot;); //通过任务名称获取任务</span></span><br><span class="line">  TaskHandle_t taskHandle = Task_ADCHandle; <span class="comment">//直接使用任务名称获取任务句柄</span></span><br></pre></td></tr></table></figure><p>只需要使用其中的一条语句获取任务句柄，其他语句需注释掉。<strong>另外，使用函数<code>xTaskGetIdleTaskHandle()</code>时，可能会出现编译错误，显示这个函数未定义</strong>。这是因为在源程序<code>tasks.c</code>中，这个函数有个预编译条件，只有当参数<code>INCLUDE_xTaskGetIdleTaskHandle</code>值为1时，才编译这个函数。而在文件<code>FreeTROS.h</code>中，这个参数的默认值为0，我们需要将这个参数的值修改为1。注意，<strong>不能在文件<code>FreeRTOS.h</code>中直接修改这个参数的值，而要在文件<code>FreeRTOSConfig.h</code>的用户代码沙箱段内，重新定义这个宏</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Defines */</span></span><br><span class="line"><span class="comment">/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle 1</span></span><br><span class="line"><span class="comment">/* USER CODE END Defines */</span></span><br></pre></td></tr></table></figure><p>这段沙箱段在文件<code>FreeRTOSConfig.h</code>中的最下方，就是用于重新定义一些无法在CubeMX中可视化设置的参数，用于替换其在文件<code>FreeRTOS.h</code>中的默认定义。</p><p><em>使用FreeRTOS时，如果编译时遇到函数未定义的错误，要注意查看其源代码里有没有预编译条件。有的函数在头文件里有定义，但是源程序里不一定编译，例如函数<code>vTaskGetIdleTaskHandle()</code></em></p><p>调用函数<code>vTaskGetInfo()</code>语句如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vTaskGetInfo(taskHandle, &amp;taskInfo, getFreeStackSpace, taskState); </span><br></pre></td></tr></table></figure><p>函数返回的任务信息存储在结构体变量<code>taskInfo</code>里。参数<code>getFreeStackSpace</code>确定是否获取任务栈空间的高水位值。若参数<code>taskState</code>指定为某种状态，就返回任务在这种状态下的参数，若<code>taskState</code>为<code>eInvaild</code>，就返回任务实际所处状态的信息。</p><p><code>vTaskGetInfo()</code>获取的任务信息包括任务编号、名称、优先级等，还有栈空间的高水位值。<strong>高水位值表示任务栈空间的最小可用剩余空间，这个字越小，就说明任务栈空间越容易溢出</strong>。</p><p>(2) 使用函数<code>uxTaskGetStackHighWaterMark()</code>获取一个任务的高水位值（单位：字），程序使用该函数分别获取了空闲任务，Task_ADC、Task_Info这三个任务的高水位值并加以显示。</p><p>(3) 获取内核其他信息。函数<code>uxTaskGetNumberOfTasks()</code>可获取FreeRTOS中当前管理的任务数。</p><p>(4) 定义关键代码段。程序使用函数<code>taskENTER_CRITICAL()</code>和<code>taskEXIT_CRITICAL()</code>定义了临界代码段。<strong>在开始LCD显示之前，使用了函数<code>taskENTER_CRITICAL()</code>定义临界代码段的开始，这样会暂停任务调度，使后面的代码段在执行时不会被其他任务打断</strong>；在进入for循环之前，使用函数<code>taskEXIT_CRITICAL()</code>定义临界代码段的结束，恢复任务调度。</p><p>(5) 删除任务。<strong>任务函数的主题一般是一个无限循环，在任务函数中不允许出现return语句，如果跳出了无限循环，需要在任务函数返回之前执行<code>vTaskDelete(NULL)</code>删除任务自己。</strong></p><h2 id="5-FreeRTOS的中断管理"><a href="#5-FreeRTOS的中断管理" class="headerlink" title="5 FreeRTOS的中断管理"></a>5 FreeRTOS的中断管理</h2><p>FreeRTOS任务有优先级，MCU的硬件中断有中断优先级，这是两个不同的概念。FreeRTOS的任务管理要用到硬件中断，使用FreeRTOS时也可以使用硬件中断，但是硬件中断ISR的设计要注意一些设计原则。</p><h3 id="5-1-FreeRTOS与中断"><a href="#5-1-FreeRTOS与中断" class="headerlink" title="5.1 FreeRTOS与中断"></a>5.1 FreeRTOS与中断</h3><p>中断是MCU的硬件特性，STM32 MCU的NVIC管理硬件中断。而FreeRTOS的运行要用到中断，比如FreeRTOS的上下文切换就是在PendSV中断里进行的，FreeRTOS还需要一个基础时钟产生滴答信号。在CubeMX中启用FreeRTOS后，系统会自动对NVIC做一些设置，以《多任务编程示例（二）》中的<code>FreeRTOS_TwoTaskInfo</code>工程为例，其NVIC设置如下图所示：</p><p><img src="FreeRTOS_TwoTaskInfo的NVIC设置.png" alt="FreeRTOS_TwoTaskInfo的NVIC设置"></p><p><strong>启用FreeRTOS后，中断优先级分组策略自动设置为4位全部用于抢占优先级</strong>，所以抢占优先级编号是0到15。这个设置对应于文件<code>FreeRTOSConfig.h</code>中的参数<code>configPRIO_BITS</code>，默认定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configPRIO_BITS         4</span></span><br></pre></td></tr></table></figure><p>这个参数在CubeMX中不能修改，固定为4，也就是分组策略使用4位抢占优先级。</p><p>在CubeMX中设置FreeRTOS的<code>config</code>参数时，有2个与中断相关的参数设置，如下图所示：</p><p><img src="FreeRTOS中与中断相关的两个参数.png" alt="FreeRTOS中与中断相关的两个参数"></p><ul><li><code>LIBRARY_LOWEST_INTERRUPT_PRIORITY</code>，<strong>表示中断的最低优先级数值。因为中断分组策略是4位全用于抢占优先级，所以这个数值为15</strong>。  </li><li><code>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>，<strong>表示FreeRTOS可管理的最高优先级，默认值为5</strong>。也就是说，<strong>只有在中断优先级数值大于或等于5的中断ISR里，才可以调用FreeRTOS的中断安全API函数</strong>，也就是带<code>FromISR</code>后缀的函数，使用<code>taskDISABLE_INTERRUPTS()</code>函数也只能屏蔽优先级数值大于或等于5的中断。</li></ul><p><strong><u>参数<code>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>绝对不允许设置为0！绝对不要在高于此优先级的中断ISR里调用FreeRTOS的API函数，即使是带<code>FromISR</code>的中断安全函数也不可以！</u></strong></p><p>在NVIC配置中，最右边一列<code>User FreeRTOS functions</code>，<strong>表示是否要在中断的ISR里使用FreeRTOS的API函数</strong>。如果勾选了此列的复选框，那么这个中断的优先级数值就不能小于5。<strong>这个复选框并不会对生成的代码产生任何影响，只是改变了某个中断的抢占优先级可设置范围</strong>。</p><p>根据<code>LIBRARY_LOWEST_INTERRUPT_PRIORITY</code>和<code>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>两个参数以及参数<code>configPRIO_BITS</code>的设置，<strong>文件<code>FreeRTOSConfig.h</code>还定义了一个参数<code>configKERNEL_INTERRUPT_PRIORITY</code>，用于写入寄存器的表示最低优先级的数值</strong>，其定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configKERNEL_INTERRUPT_PRIORITY </span></span><br><span class="line">  ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (<span class="number">8</span> - configPRIO_BITS) )</span><br></pre></td></tr></table></figure><p>经过这样计算之后，<code>configKERNEL_INTERRUPT_PRIORITY</code>的值是0xF0。</p><p><strong>参数<code>configKERNEL_INTERRUPT_PRIORITY</code>用于定义PendSV和SysTick的中断优先级</strong>，在文件port.c中的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portNVIC_PENDSV_PRI   </span></span><br><span class="line">(((<span class="type">uint32_t</span>) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; <span class="number">16UL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portNVIC_SYSTICK_PRI</span></span><br><span class="line">(((<span class="type">uint32_t</span>) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; <span class="number">24UL</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>portNVIC_PENDSV_PRI</code>和<code>portNVIC_SYSTICK_PRI</code>是用于写入寄存器的值，其数值与中断优先级的表示有关</strong>。</p><p><strong>PendSV（Pendable request for system service，可挂起的系统服务请求）中断用于上下文切换，也即是在这个中断ISR里决定哪个任务占用CPU</strong>。PendSV中断的抢占优先级为15，也就是最低优先级。所以，只有在没有其他中断ISR运行的情况下，FreeRTOS才会执行上下文切换。</p><p><strong>SysTick的中断优先级为15，是最低的。系统在SysTick中断里发出任务调度请求，所以，只有在没有其他中断IST运行的情况下，任务调度请求才会被及时响应</strong>。根据NVIC管理中断的特点，同等抢占优先级的中断是不能发生抢占的，所以，即使有一个抢占优先级为15中断在ISR运行，SysTick和PendSV的中断就无法被及时响应，也就是不会发生任务调度，任务函数也不会被执行。</p><p><img src="FreeRTOS中各个优先级中断的作用和分类.png" alt="FreeRTOS中各个优先级中断的作用和分类"></p><p>在《多任务编程示例（二）》中的<code>FreeRTOS_TwoTaskInfo</code>工程中，指定了定时器TIM6作为HAL基础时钟源。根据上图可以看出，TIM6中断的抢占优先级为0，也就是最高优先级，所以FreeRTOS无法屏蔽HAL的基础时钟中断。</p><h3 id="5-2-任务与中断服务例程"><a href="#5-2-任务与中断服务例程" class="headerlink" title="5.2 任务与中断服务例程"></a>5.2 任务与中断服务例程</h3><h4 id="5-2-1-任务与中断服务函数例程的关系"><a href="#5-2-1-任务与中断服务函数例程的关系" class="headerlink" title="5.2.1 任务与中断服务函数例程的关系"></a>5.2.1 任务与中断服务函数例程的关系</h4><p>MCU的中断有中断优先级，有中断服务例程(ISR)；FreeRTOS的任务有任务优先级，有任务函数。这两者的特点和区别具体如下。</p><ul><li><strong>中断是MCU的硬件特性，由硬件事件或软件信号引起中断，运行哪个ISR是由硬件决定的</strong>。中断的优先级数值越小，表示优先级越高，所以中断的最高优先级为0。</li><li><strong>FreeRTOS的任务是一个纯软件的概念，与硬件系统无关</strong>。任务的优先级是开发者在软件中赋予的，任务的优先级数字越低，表示优先级越低，所以任务的最低优先级为0。FreeRTOS的任务调度器决定哪个任务处于运行状态，FreeRTOS在中断优先级为15的PendSV中断里进行上下文切换，所以，<strong>只要有中断ISR在运行，FreeRTOS就无法进行任务切换</strong>。</li><li><strong>任务只有在没有ISR运行的时间才能运行，即使优先级最低的中断，也可以抢占高优先级的任务的执行，而任务不能抢占ISR的运行</strong>。</li></ul><p>注意对最后一条规则的理解。<strong>根据NVIC管理中断的原则，同等抢占优先级的中断是不能发生抢占的</strong>。<strong>一个优先级为15的RTC唤醒中断是不能抢占优先级为15的SysTick和PendSV中断的执行的</strong>，这是因为SysTick和PendSV中断的ISR运行时间很短，RTC唤醒中断的ISR能被及时执行。但是如果优先级为15的RTC唤醒中断的ISR执行时间很长，那么SysTick和PendSV发生了中断也无法发生抢占，也就是无法进行任务调度，任务函数也无法运行。</p><p>任务函数与中断的ISR运行时的关系可以如下图所示：</p><p><img src="任务函数与中断的ISR运行时的关系.png" alt="任务函数与中断的ISR运行时的关系"></p><ul><li>在t1时刻，User Task进入运行状态，占用CPU；在t2时刻，发生了一个中断ISR1，不管User Task的任务优先级有多高，ISR1都会抢占CPU。ISR1执行完成后，User Task才可以继续执行。</li><li>在t6时刻，发生了中断2，ISR2抢占了CPU。但是ISR2CPU的时间比较长，导致User Task执行时长变长，从软件运行响应来说，表现就是软件响应变迟钝了。</li></ul><p><strong>从上图可以看出，ISR执行时，就无法执行任务函数。所以，如果一个ISR执行的时间比较长，任务函数无法及时执行，FreeRTOS也无法进行任务调度，就会导致软件响应变迟钝</strong>。</p><p><strong>在实际的软件设计中，一般要尽量简化ISR的功能，使其尽量少占用CPU的时间</strong>。一般的硬件中断都是处理一些数据的接收或者发送工作的，例如，<u>常用中断方式进行ADC数据采集时，只需在ADC的中断里将数据读取到缓冲区，而对数据进行滤波、频谱计算等耗时的工作就需要转移到任务函数里处理</u>。</p><h4 id="5-2-2-中断屏蔽和临界代码段"><a href="#5-2-2-中断屏蔽和临界代码段" class="headerlink" title="5.2.2 中断屏蔽和临界代码段"></a>5.2.2 中断屏蔽和临界代码段</h4><p>一个任务函数在执行的时候，可能会被其他高优先级的任务抢占CPU，也可能被任何一个中断的ISR抢占CPU。在某些时候，任务的某段代码可能很关键，需要连续执行完，不希望被其他任务或者中断打断，这种程序称为<strong>临界段(critical section)</strong>。<strong>在FreeRTOS中，有函数定义临界代码段，也可以屏蔽系统的部分中断</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskDISABLE_INTERRUPTS()portDISABLE_INTERRUPTS() <span class="comment">//屏蔽MCU部分中断</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENABLE_INTERRUPTS()portENABLE_INTERRUPTS()  <span class="comment">//解除中断屏蔽</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL()portENTER_CRITICAL()     <span class="comment">//开始临界代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL()    portEXIT_CRITICAL()  <span class="comment">//结束临界代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )</span></span><br></pre></td></tr></table></figure><ul><li>宏函数<code>taskDISABLE_INTERRUPTS()</code>用于屏蔽MCU中的一些中断，可屏蔽的中断就是之前说的FreeRTOS可屏蔽的中断。注意，在FreeRTOS里，屏蔽中断并不是屏蔽MCU的所有中断，例如，优先级为0的TIM6的中断就是不可屏蔽的。</li><li>宏函数<code>taskENABLE_INTERRUPTS()</code>用于杰出中断屏蔽。</li><li>函数<code>taskENTER_CRITICAL()</code>和<code>taskEXIT_CRITICAL()</code>用于界定一个临界代码段，在临界代码段内，FreeRTOS会暂停任务调度，所以正在执行的任务不会被更高优先级的任务抢占，能保证代码执行的连续性。</li><li><code>taskENTER_CRITICAL_FROM_ISR()</code> 、<code>taskEXIT_CRITICAL_FROM_ISR( x )</code>分别是<code>taskENTER_CRITICAL()</code>、<code>taskEXIT_CRITICAL()</code>的ISR版本，用于在ISR中调用。</li></ul><p>定义临界代码段和屏蔽中断在功能上几乎是相同的，因为函数<code>taskENTER_CRITICAL()</code>里调用了<code>taskDISABLE_INTERRUPTS()</code>，<code>taskEXIT_CRITICAL()</code>里调用了<code>taskENABLE_INTERRUPTS()</code>。实际临界代码段的两个函数的底层代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortEnterCritical</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">portDISABLE_INTERRUPTS();</span><br><span class="line">uxCriticalNesting++;</span><br><span class="line"><span class="keyword">if</span>( uxCriticalNesting == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">configASSERT( ( portNVIC_INT_CTRL_REG &amp; portVECTACTIVE_MASK ) == <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortExitCritical</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">configASSERT( uxCriticalNesting );</span><br><span class="line">uxCriticalNesting--;</span><br><span class="line"><span class="keyword">if</span>( uxCriticalNesting == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">portENABLE_INTERRUPTS();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看出，<strong>函数<code>taskENTER_CRITICAL()</code>和函数<code>taskEXIT_CRITICAL()</code>使用了嵌套计数器，所以这一对函数可以嵌套使用。函数<code>taskDISABLE_INTERRUPTS()</code>和<code>taskENABLE_INTERRUPTS()</code>不能嵌套使用，只能成对使用。</strong></p><h4 id="5-2-3-在ISR中使用FreeRTOS-API函数"><a href="#5-2-3-在ISR中使用FreeRTOS-API函数" class="headerlink" title="5.2.3 在ISR中使用FreeRTOS API函数"></a>5.2.3 在ISR中使用FreeRTOS API函数</h4><p>在中断的ISR里，有时会需要调用FreeRTOS的API函数，但是调用普通的API函数可能会存在问题。例如，<strong>在ISR里调用<code>vTaskDelay()</code>就会出现问题，因为<code>vTaskDelay()</code>会使任务进入阻塞状态，而ISR根本不是任务，ISR运行的时候，也不能进行任务调度</strong>。</p><p>为此，FreeRTOS的API函数分为两个版本：一个称为”任务级“，即普通名称的API函数；另一个称为”中断级“，即带后缀<code>FromISR</code>函数或带后缀<code>FROM_ISR</code>的宏函数，<strong>中断级API函数也称为中断安全API函数</strong>。</p><p>例如，对应于<code>taskENTER_CRITICAL()</code>的中断级宏函数是<code>taskENTER_CRITICAL_FROM_ISR()</code>，对应于函数<code>xTaskGetTickCount()</code>的中断级函数是<code>xTaskGetTickCountFromISR()</code>。</p><p>FreeRTOS将API函数分为两个版本的好处是：在API的实现代码中，无须判断调用这个API函数的是一个ISR，还是一个任务函数，否则需要增加额外的代码，而且不同的MCU判断ISR和任务函数的机制可能不一样。所以，使用两个版本的API函数，使FreeRTOS的代码效率更高。</p><p><strong><u>在ISR中，绝对不能使用任务级API函数，但是在任务函数中，可以使用中断级API函数。此外，在FreeRTOS不能管理的高优先级中断的ISR里，连中断级API函数也不能调用。</u></strong></p><h4 id="5-2-4-中断及其ISR设计原则"><a href="#5-2-4-中断及其ISR设计原则" class="headerlink" title="5.2.4 中断及其ISR设计原则"></a>5.2.4 中断及其ISR设计原则</h4><p>根据FreeRTOS管理中断的特点，中断的优先级和ISR程序设计应该遵循如下原则。</p><ul><li>根据参数<code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>的设置，MCU的优先级为0到15的中断，分为FreeRTOS不可屏蔽中断和可屏蔽中断，要根据中断的重要性和功能，为其设置合适的中断优先级，使其成为FreeRTOS不可屏蔽中断或可屏蔽中断。</li><li><strong>ISR的代码应该尽量简短，应该将比较耗时的处理功能转移到任务函数里实现</strong>。</li><li>在可屏蔽中断的ISR里，能调用中断级的FreeRTOS API函数，绝对不能调用普通的FreeRTOS API函数里。<strong>在不可屏蔽中断的ISR里，不能调用任何的FreeRTOS API函数</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力电子技术</title>
      <link href="/2023/08/16/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/08/16/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="电力电子技术"><a href="#电力电子技术" class="headerlink" title="电力电子技术"></a>电力电子技术</h1><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><p><strong>电力电子技术就是使用电力电子器件对电能进行变化和控制的技术</strong>。目前所用的电力电子器件均由半导体制成，故电力电子器件也称<strong>电力半导体器件</strong>。</p><p>通常所用的电力有支流和交流两种从公共电网直接得到的电力是交流，从蓄电池和干电池得到的电力是直流，这些电源得到的电力往往不能直接满足需求，需要进行电力变化。电力变换通常可以分为四大类，即<strong>交流变直流</strong>(AC-DC)、<strong>直流变交流</strong>（DC-AC)、<strong>直流变直流</strong>(DC-DC)、<strong>交流变交流</strong>(AC-AC)。交流变直流称为<strong>整流</strong>，直流变交流称为<strong>逆变</strong>，直流变直流是值一种电压(或电流)的直流变为另一种电压(或电流)的直流，<strong>可用直流斩波电路实现</strong>。交流变交流可以是<strong>电压或电力的变换</strong>，称为交流电力控制，也可以是<strong>频率或相数的变换</strong>。</p><p>通常把电力电子技术分为电力电子器件制造技术和变流技术两个分支。变流技术又称为<strong>电力电子器件的应用技术</strong>，它包括<strong>使用电力电子器件构成各种电力变换电路和对这些电路进行控制的技术，以及由这些电路构成电力电子装置和电力电子系统的技术</strong>。</p><h2 id="2-电力电子器件"><a href="#2-电力电子器件" class="headerlink" title="2. 电力电子器件"></a>2. 电力电子器件</h2><h3 id="2-1-电力电子器件概述"><a href="#2-1-电力电子器件概述" class="headerlink" title="2.1 电力电子器件概述"></a>2.1 电力电子器件概述</h3><h4 id="2-1-1-电力电子器件的概念和特征"><a href="#2-1-1-电力电子器件的概念和特征" class="headerlink" title="2.1.1 电力电子器件的概念和特征"></a>2.1.1 电力电子器件的概念和特征</h4><p>在电气设备或电力系统中，直接承担电能的变换或控制任务的电路被称为<strong>主电路</strong>(Main Power Circuit)。电力电子器件(Power Electronic Device)是指<strong>可直接用于处理电能的主电路中，实现电能的变换或控制的电子器件</strong>。</p><p>由于电力电子器件直接用于处理电能的主电路，因而同处理信息的电子器件相比，他一般据有如下特征：</p><ol><li><strong>电力电子器件所能处理的电功率的大小</strong>，也就是其承受电压和电流的能力，是其最重要的参数。其处理电功率的能力小至毫瓦即，大至兆瓦级，<strong>一般都远大于处理信息的电子器件</strong>。</li><li>因为处理的电功率较大，为了减小本身的损耗，提高效率，<strong>电力电子器件一般都工作在开关状态</strong>。导通时阻抗很小，接近于短路，管压降接近于零，而电流由外电路决定；阻断时阻抗很大，接近于断路，电流几乎为零，而管制两端电压由外电路决定；<em>就像普通晶体管的饱和和截至状态一样</em>。因而电力电子器件的动态特性(也就是开关特性)和参数，也是电力电子器件特性很重要的方面，有时候甚至上升为第一位的重要方面。而在模拟电子电路中，电子器件一般都是工作在<strong>线性放大状态</strong>，<em>数字电子电路的电子器件虽然一般也工作在开关状态，但其目的时利用开关状态表示不同的信息</em>。正因为如此，也常常将一个电力电子器件或者外特征像一个开关的几个电力电子器件的组合称为<strong>电力电子开关</strong>，或者<strong>电力半导体开关</strong>，做电路分析时，为简单起见往往用理想开关来代替。</li><li><strong>在实际应用中，电力电子器件往往需要由信息电子电路来控制</strong>。由于电力电子器件所处理的电功率较大，因此<strong>普通的信息电子电路信号一般不能直接控制电力电子器件的导通或关断，需要一定的中间电路对这些信号进行适当的放大</strong>，这就是所谓的<strong>电力电子器件的驱动电路</strong>。</li><li>尽管工作在开关状态，但是<strong>电力电子器件自身的功率损耗通常仍远大于信息电子器件</strong>，因而为了保证不至于因为损耗散发的热量导致器件温度过高而损坏，不仅在器件封装上比较讲究散热设计，而且<strong>在其工作时一般都还需要安装散热器</strong>。这是因为<strong>电力电子器件在导通或者阻断状态下，并不是理想的短路或者断路</strong>。<u>导通时期间上有一定的通态压降，阻断时器件上由为下的断态漏电流流过。尽管其数值都很小，但分别于数值较大的通态电流和断态电压相作用，就形成了电力电子器件的通态损耗和断态损耗。</u>此外，还有在电力电子器件由断态转为通态(开通过程)或者由通态转为断态(关断过程)的转换过程中产生的损耗，分别称为<strong>开通损耗</strong>和<strong>关断损耗</strong>，总称<strong>开关损耗</strong>。<u>对某些器件来讲，驱动电路向其注入的功率也是造成器件发热的原因之一</u>。通常来讲，<strong>除一些特殊的器件外，电力电子器件的断态漏电流都极小，因而通态损耗时电力电子器件功率损耗的主要成因。当器件开关频率较高时，开关损耗会随之增大而可能称为器件功率损耗的主要因素</strong>。</li></ol><h4 id="2-1-2-应用电力电子器件的系统组成"><a href="#2-1-2-应用电力电子器件的系统组成" class="headerlink" title="2.1.2 应用电力电子器件的系统组成"></a>2.1.2 应用电力电子器件的系统组成</h4><p>电力电子器件在实际应用中，一般是由<strong>控制电路</strong>、<strong>驱动电路</strong>、以及<strong>电力电子器件为核心的主电路</strong>组成一个系统。</p><p><img src="电力电子器件在实际应用中的系统组成.png" alt="电力电子器件在实际应用中的系统组成"></p><p>由信息电子电路组成的控制电路按照系统的工作需求形成控制信号，通过驱动电路去控制主电路中电力电子器件的导通或者关断，来完成整个系统的功能。在有的电力电子系统中，需要检测主电路或者应用现场的信号，再根据这些信号并按照系统的工作要求来形成控制信号，这就需要<strong>检测电路</strong>。</p><p>主电路中的电压和电流一般比较大，而控制电路的元器件只能承受较小的电压和电流，因此在<strong>主电路和控制电路连接的路径上，如驱动电路与主电路的连接处，或者驱动电路与控制信号的连接处，以及主电路与检测电路的连接处，一般需要进行电气隔离，而通过其他手段如光、磁等来传递信号</strong>。此外，由于主电路中往往有电压和电流的过冲，而<strong>电力电子器件一般比主电路中普通的元器件要昂贵，但承受过电压和过电流的能力却要差一些</strong>，因此，在主电路和控制电路中附加一些保护电路，以保证电力电子器件和整个电力电子系统正常可靠运行，也往往是非常必要的。</p><p>电力电子器件一般有三个端子(或者称为极或引脚)，其中两个端子是连接在主电路中的流通主电路电流的端子，而第三端被称为控制端(或控制极)。<strong>电力电子器件的导通或者关断是通过在其控制端和一个主电路端子之间施加一定的信号来控制的</strong>，<u>这个主电路端子是驱动电路和主电路的公共端，一般是主电路电流流出电力电子器件的那个端子。</u></p><h4 id="2-1-3-电力电子器件的分类"><a href="#2-1-3-电力电子器件的分类" class="headerlink" title="2.1.3 电力电子器件的分类"></a>2.1.3 电力电子器件的分类</h4><p><strong>按照电力电子器件能够被控制电路信号所控制的程度，可以将电力电子器件分为以下三类：</strong></p><ol><li>通过控制信号可以控制器导通而不能控制器关断的电力电子器件被称为<strong>半控型器件</strong>，这类器件主要是指<strong>晶闸管</strong>(Thyristor)及其大部分派生器件，<strong>该类器件的关断完全是由其在主电路中承受的电压和电流决定的。</strong></li><li>通过控制信号既可以控制其导通，又可以控制其关断的电力电子器件被称为<strong>全控型器件</strong>，由于与半控型器件相比，可以由控制信号控制其关断，因此又称为<strong>自关断器件</strong>。这类器件品种很多，目前最常用的是<strong>绝缘栅双极型晶体管</strong>(Insulated-Gate Bipolar Transistor, IGBT)，和<strong>电力场效应管</strong>(POWER MOSFET，简称电力MOSFET)。</li><li>也有不能用控制信号来控制其通断的电力电子器件，因此也不需要驱动电路，这就是电力二极管，又被称为不可控器件。这种器件只有两个端子，其基本特性与信息电子电路中的二极管一样，<strong>该类器件的导通和关断完全是由其在主电路中承受的电压和电流决定的</strong>。</li></ol><p><strong>按照驱动电路加在电力电子器件控制端和公共端之间信号的性质</strong>，可以将电力电子器件(电力二极管除外)分为<strong>电流驱动型</strong>和<strong>电压驱动型</strong>两类。如果是通过从控制端主或抽出电流来实现导通或者关断的控制，这类电力电子器件被称为<strong>电流驱动型电力电子器件，或者电流控制型控制性电力电子器件</strong>。如果是仅通过在控制端和公共端之间施加一定的电压信号就可以实现导通或者关断的控制，这类电力电子器件则被称为<strong>电压驱动型电力电子器件，或者电压控制性电力电子器件</strong>。<em>由于电压驱动型器件实际上是通过加在控制端上的电压在器件的两个主电路端子之间产生可控的电场来改变流过器件的电流大小和通断状态的，所以电压驱动型器件又被称为<strong>场控器件</strong>，或者<strong>场效应器件</strong>。</em></p><p><strong>根据驱动电路加在电力电子器件控制端和公共端之间有效信号的波形</strong>，又可以将电力电子器件(电力二极管除外)分为<strong>脉冲触发型</strong>和<strong>电平控制型</strong>两类。如果是通过在控制端施加一个电压或电流的脉冲信号来实现器件的开通或者关断的控制，一旦进入导通或者阻断状态且主电路条件不变的情况下，器件就能维持其导通或阻断状态，而不必通过继续施加控制端信号来维持其状态，这类电力电子器件被称为<strong>脉冲触发型电力电子器件</strong>。如果必须通过持续在控制端和公共端之间施加一定电平的电压或电流信号来使器件开通并维持在导通状态，或者关断并维持在阻断状态，这类电力电子器件则被称为<strong>电平控制型电力电子器件</strong>。</p><p>此外，同处理信息的电子器件类似，电力电子器件还可以按照器件内部自由电子电子和空穴两种载流子参与导电的情况为非<strong>单极性器件</strong>、<strong>双极性器件</strong>和<strong>复合型器件</strong>三类。由一种载流子参与导电的器件称为<strong>单极性器件(也称为多子器件)</strong>；由自由电子和空穴两种载流子参与导电的器件称为<strong>双极性器件(也称为少子器件)</strong>；由单极性器件和双极性器件集成混合而成的器件则被称为<strong>复合型器件，也称混合型器件。</strong></p><h3 id="2-2-不可控器件——电力二极管"><a href="#2-2-不可控器件——电力二极管" class="headerlink" title="2.2 不可控器件——电力二极管"></a>2.2 不可控器件——电力二极管</h3><p>电力二极管虽然是不可控器件，但是其结构和原理简单，工作可靠，所以知道现在电力二极管仍然大量应用于许多电气设备当中。在采用全控型器件的电路中电力二极管往往是不可缺少的，特别是开通和关断速度很快的<strong>快恢复二极管</strong>和<strong>肖特基二极管</strong>，据有不可替代的地位。</p><h4 id="2-2-1-PN结与电力二极管的工作原理"><a href="#2-2-1-PN结与电力二极管的工作原理" class="headerlink" title="2.2.1 PN结与电力二极管的工作原理"></a>2.2.1 PN结与电力二极管的工作原理</h4><p>电力二极管的基本结构和工作原理与信息电子电路中的二极管是一样的，都是以半导体PN结为基础的。<strong>电力二极管实际上是由一个面积较大的PN结和两端引线以及封装组成的</strong>。从外观上看，电力二极管可以有螺栓形、平板型等多种封装。</p><p><img src="电力二极管外形结构与电气符号.png" alt="电力二极管外形结构与电气符号"></p><p><strong>下面简单回顾以下PN结的形成与原理。</strong></p><p>通过扩散工艺，在本征半导体中掺入少量合适的杂质元素，便可得到<strong>杂质半导体</strong>。按掺入的杂质元素不同，可形成<strong>N型半导体</strong>和<strong>P型半导体</strong>；控制掺入杂质元素的浓度，就可以控制杂质半导体的导电性能。</p><p><strong>一、N型半导体</strong></p><p>在纯净的硅晶体中掺入五价元素(如磷)，使之取代晶格中硅原子的位置，就形成了<strong>N型半导体</strong>，由于杂质原子最外层有五个价电子，所以出了与其周围硅原子形成共价键外，还多出一个电子。多出的电子不受共价键束缚，只需要获得很少的能量，就能成为自由电子。而杂质原子因在晶格上，且又缺少电子，故变为不能移动的正离子。<strong>N型半导体中，自由电子为多子，空穴为少子</strong>。由于杂质原子可以提供电子，故称之为<strong>施主原子</strong>。<u>N型半导体主要靠自由电子导电，掺入的杂质越多，多子(自由电子)的浓度就越高，导电性就越强。</u></p><p><img src="杂质半导体.png" alt="杂质半导体"></p><p><strong>二、P型半导体</strong></p><p>在纯净的硅晶体中掺入三价元素(如硼)，使之取代晶格中硅原子的位置，就形成<strong>P型半导体</strong>。由于杂质原子最外层有3个价电子，所以当它们与周围的硅原子形成共价键时，就产生了一个”空位”(空位为电中性)，当硅原子的外层电子填补此空位时，其共价键中变产生一个空穴，而杂质原子成为不可移动的负离子。因而<strong>P型半导体中，空穴为多子，自由电子为少子</strong>，主要靠空穴导电。<u>与N型半导体相同，掺入的杂质越多，空穴的浓度就越高，使得导电性能越强。因杂质原子中空位吸收电子，故称之为<strong>受主原子</strong>。</u></p><p><strong>三、PN结的形成</strong></p><p>物质总是从浓度高的地方向浓度低的地方运动，这种由于浓度差产生的运动称为<strong>扩散运动</strong>，当把P型半导体和N型半导体制作在一起时，在它们的交界面，两种载流子浓度相差很大，必然导致<strong>P区的空穴向N区扩散，且N区的自由电子向P区扩散</strong>。由于扩散到P区的自由电子与空穴复合，扩散到N区的空穴与自由电子复合，所以在交界面附近多子浓度下降，P区出现负离子区，N区出现正离子区，它们是不能移动的，称为<strong>空间电荷区</strong>，从而形成<strong>内电场</strong>。<u>随着扩散运动的进行，空间电荷区加宽，内电场增强，其方向为<strong>N区指向P区，正好阻止扩散运动的进行</strong>。同时，在内电场的作用下少子产生<strong>漂移运动</strong>，使得N区的空穴向P区移动，P区的自由电子向N区移动。</u>扩散运动和漂移运动即互相联系又互相矛盾，最终达到动态平衡，正、负空间电荷量达到稳定值，形成了一个稳定的PN结。</p><p><img src="空间电荷区.png" alt="空间电荷区"></p><p><strong>四、PN结的单向导电性</strong></p><p>如果在PN结的两端外加电压，就将破坏原来的平衡状态，此时，扩散电流不再等于漂移电流，因而PN结将有电流流过。<strong>当外加电压极性不同时，PN结表现出截然不同的导电性能，即呈现出单向导电性。</strong></p><ol><li><strong>PN结外加正向电压时处于导通状态</strong></li></ol><p>当电源正极接到PN结的P端，且电源负极接到PN结的N端时，称PN结外加正向电压，也称正向偏置。此时外电场将多数载流子推向空间电荷区，使其变窄，削弱了内电场，破坏了原来的平衡，使得<u>扩散运动加剧，漂移运动减弱</u>。由于电源的作用，扩散运动将源源不断的进行，从而形成正向电流，<strong>PN结导通</strong>，<u><strong>PN结导通时的结压降只有零点几伏，因而应在它所在的回路中串联一个电阻，以限制回路电流，防止PN结因正向电流过大而损坏</strong>。</u></p><p><img src="PN结正向偏置.png" alt></p><ol><li>PN结外加方向电压时处于截至状态</li></ol><p>当电源正极接到PN结的N端，电源负极接到PN结的P端时，称PN结外加<strong>反向电压</strong>，也称<strong>反向偏置</strong>。此时外电场使空间电荷区变宽，加强了内电场，<u>阻止扩散运动的进行，而加剧漂移运动的进行</u>，形成反向电流，也称<strong>漂移电流</strong>，因为少子的数目极少，即使所有少子都参与漂移运动，反向电流也非常小，所以在近似分析中常常将它忽略不计，认为PN结外加反向电压时处于<strong>截止</strong>状态。</p><p><img src="PN结反向偏置.png" alt></p><p>这就是PN结的单向导电性，二极管的基本原理就在于PN结的单向导电性这个主要特征。</p><p><strong>为了建立承受高电压和大电流能力，电力二极管具体的半导体物理结构和工作原理据有如下不同于信息电子电路二极管之处</strong>。</p><p>首先，电力二极管大都是垂直导电结构，即电流在硅片内流动的总体方向是与硅片表面垂直的。而信息电子二极管一般时横向导电结构，即电流在硅片内流动的总体方向时与硅片表面平行的。<strong>垂直导电结构使得硅片中通过电流的有效面积增大，可以显著提高二极管的通流能力</strong>。</p><p>其次，电力二极管在P区和N区之间多了一层低掺杂N区(在半导体物理中用N^-^表示)，也称为<strong>漂移区</strong>。低掺杂N区由于掺杂浓度低而接近于无掺杂的本征半导体，因此，电力二极管的结构也被称为P-i-N结构。由于掺杂浓度低，低掺杂N区就可以承受很高的电压而不至于被击穿，因此<strong>低掺杂N区越厚，电力二极管能承受的反向电压就越高</strong>。</p><p>当然，低掺杂N区由于掺杂浓度低而具有的高电阻率对于电力二极管的正向导通是不利的。这个矛盾是通过<strong>电导调制效应</strong>来解决的。<strong>当PN结上流过的正向电流较小时，二极管的电阻主要是作为基片的低掺杂N区的欧姆电阻，其阻值较高且为常量，因而管压降随正向电流的上升而增加</strong>；<strong>当PN结上流过的正向电流较大时，由P区注入并积累在低掺杂N区的少子空穴浓度将很大，为了维持半导体的电中性条件，其多子浓度也应大幅度增加，使得其电阻率明显下降，也就是电导率大大增加</strong>，这就是电导调制效应。<u>电导调制效性使得电力二极管在正向电流较大时压降仍然很低，维持在1V左右，所以正向偏置的电力二极管表现为<strong>低阻态</strong></u>。</p><p>PN结具有一定的反向耐压能力，当施加的反向电压过大时，反向电流将会急剧增大，破坏PN结反向偏置为截止的工作状态，这就是<strong>反向击穿</strong>。<strong>反向击穿按照机理不同有雪崩击穿和齐纳击穿两种形式</strong>。反向击穿发生时，只要外电路中采取了措施，将反向电流限制在一定范围内，则当反向电压降低后PN结仍可以恢复原来的状态。但如果反向电流未被限制住，使得反向电流和反向电压的乘积超过了PN结允许的耗散功率，就会因为热量散发不出去而导致PN结温度上升，直至过热而烧毁，这就是<strong>热击穿</strong>。</p><p>PN结中的电荷量随外加电压而变化，呈现电容效应，称为<strong>结电容</strong>，又称<strong>微分电容</strong>，结电容按其产生机制和作用的差别分为<strong>势垒电容</strong>和<strong>扩散电容</strong>。势垒电容旨在外加电压变化时才起作用，外加电压频率越高，势垒电容作用越明显。<u>势垒电容的大小与PN结截面积成正比，与阻挡层厚度成反比</u>；而扩散电容仅在正向偏置时起作用。<strong>在正向偏置时，当正向电压较低时，势垒电容为主；正向电压较高时，扩散电容为结电容的主要成分</strong>。<u>结电容影响PN结的工作频率，特别是在高速开关状态下，可能使其单向导电性变差，甚至不能够工作。</u></p><p>由于电力二极管正向导通时要流过很大的电流，其电流密度较大，因而额外载流子的注入水平较高，<strong>电导调制效应不可忽略</strong>，而且其引线和焊接电阻的压降等都有明显的影响；由于其承受的电流变化率di/dt较大，因此其<strong>引线和器件自身的电感效应也会有较大的影响</strong>；此外，尽管有电导调制效应，<strong>为了提高反向耐压而设置的低掺杂N区也或多或少会造成正向压降比信息电子二极管大一些</strong>。</p><h4 id="2-2-2-电力二极管的基本特性"><a href="#2-2-2-电力二极管的基本特性" class="headerlink" title="2.2.2 电力二极管的基本特性"></a>2.2.2 电力二极管的基本特性</h4><ol><li><strong>静态特性</strong></li></ol><p>电力二极管的静态特性主要是指其伏安特性。当电力二极管承受的正向电压大到一定值时，正向电流才开始明显增加，处于稳定导通状态。当电力二极管承受反向电压时，只有少子引起的微小而数值恒定的反向漏电流。当反向电压超过一定数值之后，反向电流急剧增加，即反向击穿。</p><p><img src="二极管伏安特性曲线.png" alt></p><ol><li><strong>动态特性</strong></li></ol><p>因为结电容的存在，电力二极管在零偏置(外加电压为零)，正向偏置和反向偏置这三种状态之间转换的时候，必然经历一个过渡过程。在这些过渡过程中，PN结的一些区域需要一定时间来调整其带点状态，因而其电压-电流特性不能用前面的福安特性来描述，而是随时间变化的，这就是电力二极管的动态特性，<u>并且往往专指反应通态和断态之间转换过程的开关特性</u>，这个概念虽然有由电力二极管引出，但可以推广至其他各种电力电子器件。</p><p><strong>当原来处于正向导通状态的电力二极管的外加电压突然从正向变为反向时，该电力二极管并不能立即关断，而是需要经过一段短暂的时间才能重新获得反向阻断能力，进入截止状态</strong>。<u>在关断之前有较大的反向电流出现，并伴随有明显的反向电压过冲。这是因为正向导通时在PN结两侧储存的大量少子需要被清除掉以达到反向偏置稳态的缘故。</u></p><p><img src="电力二极管的动态特性_正向偏置转为反向偏置.png" alt></p><p>上图为电力二极管正向偏置转为反向偏置时的动态特性曲线，设t~F~时刻外加电压突然由正向变为反向，正向电流在此反向电压作用下开始下降，<strong>下降速率由反向电压大小和电路中的电感决定，而管压降由于电导调制效应基本变化不大</strong>，直至正向电流降为零的时刻t~0~。此时电力二极管由于在PN结两侧(特别是多掺杂N区)储存有大量的少子的缘故而并没有恢复反向阻断的能力(<strong>正向偏置时，外电场移植漂移运动就是抑制少子的运动</strong>)，这些少子在外加反向电压的作用下加剧漂移运动，因而流过较大的反向电流。当空间电荷区附近存储的少子即将被抽尽时，管压降变为负极性，于是开始抽取距离空间电荷区较远的浓度较低的少子。因而在管压降极性改变后不久的t~1~时刻，反向电流从其最大值I~RP~开始下降，空间电荷区开始迅速变宽，电力二极管开始重新恢复对反向电压的阻断能力。在t~1~时刻以后，由于反向电流迅速下降，在外电路的电感的作用下会在电力二极管两端产生比外加反向电压大得多的反向电压过冲U~RP~。在电流变化率接近于零的t~2~时刻(有的电力二极管标定为电流下降至25%I~RP~的时刻)，电力二极管两端承受的反向电压才降至外加电压的大小，电力二极管完全恢复对反向电压的阻断能力。</p><p><img src="电力二极管的动态特性_零偏置转为正向偏置.png" alt></p><p>上图为电力二极管由零偏置转为正向偏置时其动态过程的波形，可以看出，在这一动态过程中，电力二极管的正向压降也会先出现一个过冲<em>U~FP~</em>，经过一段时间才区域接近稳态压降的某个值。这一动态过程时间被称为正向恢复时间<em>t~fr~</em>。出现电压过充的原因为：</p><ul><li>电导调制效应引起作用所需的大量少子需要一定时间来储存，在达到稳态导通前管压降较大。</li><li>正向电流上升会因为器件自身的电感而产生较大的压降。电流上升率越大，<em>U~FP~</em>越高。</li></ul><p><em>当电力二极管由反向偏置转换为正向偏置时，除上述时间外，势垒电容电荷的调整也需要更多时间来完成。</em></p><h4 id="2-2-3-电力二极管的主要参数"><a href="#2-2-3-电力二极管的主要参数" class="headerlink" title="2.2.3 电力二极管的主要参数"></a>2.2.3 电力二极管的主要参数</h4><ol><li><strong>正向平均电流<em>I~F(AV)~</em></strong></li></ol><p>指电力二极管长期运行时，在指定的管壳温度和散热条件下，其允许流过的最大公频正弦半波电流的平均值。</p><ol><li><strong>正向压降<em>U~F~</em></strong></li></ol><p>指电力二极管在指定温度下，流过某一指定的稳态正向电流时对应的正向压降。有时候，其参数表中也会给出在指定温度下流过某一瞬态正向电流时电力二极管的最大瞬时正向压降。</p><ol><li><strong>反向重复峰值电压<em>U~RRM~</em></strong></li></ol><p>指对电力二极管所能重复施加的反向最高峰值电压。通常是其雪崩击穿电压U~B~的2/3。使用时，往往按照电路中电力二极管可能承受的反向最高峰值电压的两倍来选定参数。</p><ol><li><strong>最高工作结温<em>T~JM~</em></strong></li></ol><p>结温是指管芯PN结的平均温度，用T~j~表示。最高工作结温是指在PN结不至损坏的前提下能承受的最高平均温度，用T~JM~表示。</p><ol><li><strong>反向恢复时间<em>t~rr~</em></strong></li><li><strong>浪涌电流<em>I~FSM~</em></strong></li></ol><p>指电力二极管所能承受的最大的连续一个或者几个工频周期的过电流。</p><h4 id="2-2-4-电力二极管的主要类型"><a href="#2-2-4-电力二极管的主要类型" class="headerlink" title="2.2.4 电力二极管的主要类型"></a>2.2.4 电力二极管的主要类型</h4><ol><li><strong>普通二极管</strong></li></ol><p><strong>普通二极管</strong>又称整流二极管，多用于开关频率不高(1kHz以下)的整流电路中。其<strong>反向恢复时间较长</strong>，一般在5us以上。但其正向电流定额和反向电压定额却可以达到很高，分贝可达到千安和数千伏以上。</p><ol><li><strong>快恢复二极管</strong></li></ol><p>恢复过程很短，特别是<strong>反向恢复过程很短(一般在5us以下)</strong>的二极管称为<strong>快恢复二极管</strong>。工艺上采用了掺金措施，结构上有的仍采用PN结型结构，但大多采用对此加以改进的PiN结构，特别是采用外延型PiN结构的<strong>快恢复外延二极管</strong>，其反向恢复时间更短(可低于50ns)，正向压降也很低(0.9V左右)，不管是什么结构，快恢复二极管从性能上可分为<strong>快速恢复</strong>和<strong>超快速恢复</strong>两个等级。前者反向恢复时间为数百纳秒或更长，后者则在100ns以下，甚至能达到20~30ns。</p><ol><li><strong>肖特基二极管</strong></li></ol><p>以金属和半导体接触形成的势垒为基础的二极管称为<strong>肖特基二极管</strong>。与以PN结为基础的电力二极管相比，肖特基二极管的优点在于：<strong>反向恢复时间很短(10~40ns)，正向恢复过程中也不会有明显的电压过冲；在反向耐压较低的情况下其正向压降也很小，明显低于快恢复二极管</strong>，因此其开关损耗和正向导通损耗都比快恢复二极管还小，效率高。肖特基二极管的缺点在于：<strong>但所能承受的反向耐压提高时，其正向压降也会搞得不能满足要求，因此多用于200V以下的低压场合；并且其反向漏电流较大且对温度敏感，因此反向稳态损耗不能忽略，而且必须严格地限制其工作温度</strong>。</p><h3 id="2-3-半控型器件——晶闸管"><a href="#2-3-半控型器件——晶闸管" class="headerlink" title="2.3 半控型器件——晶闸管"></a>2.3 半控型器件——晶闸管</h3><p><strong>晶闸管</strong>是晶体闸流管的简称，又称作<strong>可控硅整流器</strong>，其特点是<strong>所能承受的电压和电流容量高，工作可靠</strong>，因此在大容量的应用场合具有比较重要的地位。</p><h4 id="2-3-1-晶闸管的结构与工作原理"><a href="#2-3-1-晶闸管的结构与工作原理" class="headerlink" title="2.3.1 晶闸管的结构与工作原理"></a>2.3.1 晶闸管的结构与工作原理</h4><p><img src="晶闸管结构与电气图形符号.png" alt></p><p>上图为晶闸管的结构以及电器图形符号。晶闸管引出<strong>阳极A</strong>，<strong>阴极K</strong>和<strong>门极(控制端)G</strong>三个连接端。</p><p>晶闸管内部是PNPN四层半导体结构，分别命名为P~1~、N~1~、P~2~、N~2~四个区。P~1~区引出阳极A，N~2~区引出阴极K，P~2~区引出门极G。四个区形成J~1~、J~2~、J~3~三个PN结。<strong>如果正向电压(阳极高于阴极)加到器件上，则J~2~处于反向偏置状态，器件A、K两端之间处于阻断状态，只能流过很小的漏电流；如果反向电压加到器件上，则J~1~和J~3~反偏，该器件也处于阻断状态，仅有极小的反向漏电流流过。</strong></p><p><img src="晶闸管的双晶体管模型及其工作原理 .png" alt></p><p>晶闸管导通的工作原理可以用双晶体管模型来解释，如上图所示。如果在晶闸管器件上取一倾斜的截面，则晶闸管可以看作由P~1~N~1~P~2~和N~1~P~2~N~2~构成的两个晶体管V~1~和V~2~组合而成。如果外界电路向门极注入电流<em>I~G~</em>，也就是注入驱动电流，则<em>I~G~</em>流入晶体管V~2~的基极，即产生集电极电流<em>I~c2~</em>，它构成晶体管V~1~的基极电流，放大成集电极电流<em>I~c1~</em>，又进一步增大V~2~的基极电流，如此形成强烈的正反馈，最后V~1~和V~2~进入完全饱和状态，即晶闸管导通。<strong>此时如果撤掉外电路注入门极的电流<em>I~G~</em>，晶闸管由于内部已经形成了强烈的正反馈会仍然维持导通状态。而若要使晶闸管关断，必须去掉阳极所加的正向电压，或者给阳极施加反压，或者设法使流过晶闸管的电流甲地到接进与零的某一数值以下，晶闸管才能关闭</strong>。所以对晶闸管的驱动过程更多是称为<strong>触发</strong>，产生注入门极的触发电流<em>I~G~</em>的电流称为<strong>门极触发电路</strong>，也正是由于通过其门极只能控制其开通，不能控制其关断，晶闸管才被称为<strong>半控型器件</strong>。</p><h4 id="2-3-2-晶闸管的基本特性"><a href="#2-3-2-晶闸管的基本特性" class="headerlink" title="2.3.2 晶闸管的基本特性"></a>2.3.2 晶闸管的基本特性</h4><ol><li><strong>静态特性</strong></li></ol><p>1） <strong>当晶闸管承受反向电压时，不论门极是否有触发电流，晶闸管都不会导通</strong>。</p><p>2） <strong>当晶闸管承受正向电压时，仅在门极有触发电流的情况下晶闸管才能导通</strong>。</p><p>3） <strong>晶闸管一旦导通，门极就是去控制作用，不论门极触发电流是否还存在，晶闸管都保持导通</strong>。</p><p>4） <strong>若要使已导通的晶闸管关断，只能利用外加电压和外电路的作用使流过晶闸管的电流降到接近于零的某一数值以下</strong>。</p><p><img src="晶闸管的伏安特性.png" alt="晶闸管的伏安特性"></p><p>上图为晶闸管的伏安特性曲线图，其中<strong><em>(I~G2~&gt;I~G1~&gt;I~G~)</em></strong> 。位于第一象限的是晶闸管的正向特性，位于第三象限的是晶闸管的方向特性。</p><p>当<em>I~G~</em> = 0时，如果在器件两端施加正向电压，晶闸管处于<strong>正向阻断状态</strong>，只有很小的正向漏电流流过。<strong>如果正向电流超过正向转折电流<em>U~bo~</em>，则漏电流急剧增大，器件开通。</strong>随着门极电流幅值的增大，正向转折电压降低。导通后的晶闸管特性和二极管的正向特性相似。即使通过较大的阳极电流，晶闸管本身的压降也很小，在1V左右。<strong>导通期间，如果门极电流为0，并且阳极电流降至接近于0的某一数值 <em>I~H~</em>以下，则晶闸管又回到正向阻断状态。</strong> <em>I~H~</em>称为维持电流。</p><p>当在晶闸管上施加反向电压时，其伏安特性类似二极管的反向特性。晶闸管处于方向阻断状态时，只有极小的反向漏电流通过。当反向电压超过一定限度，到反向击穿电压之后，外电路如果无限制措施，则反向漏电流急剧增大，导致晶闸管发热损坏。</p><p><strong>晶闸管的门极触发电流是从门极流入晶闸管，从阴极流出的，阴极是晶闸管主电路与控制电路的公共端</strong>。门极触发电流也往往是通过<strong>触发电路在门极和阴极之间施加触发电压而产生的</strong>。从晶闸管的结构图可以看出，门极和阴极之间是一个PN结J~3~，其伏安特性称为<strong>门极伏安特性</strong>。<u>为了保证可靠、安全的触发，门极触发电路所提供的触发电压、触发电流和功率都应该限制在晶闸管门极伏安特性曲线中的可靠触发区内。</u></p><p><img src="晶闸管的门极伏安特性.png" alt="晶闸管的门极伏安特性"></p><p>上图为晶闸管的门极伏安特性曲线，其中，OABCO区域为<strong>不可靠触发区</strong>；ABCDEGA区域为<strong>允许可靠触发区</strong>；推荐的<strong>安全可靠触发区</strong>为ABCFH(图中阴影部分)。</p><ol><li><strong>动态特性</strong></li></ol><p>晶闸管的开通和关断的动态特性的物理机理是很复杂的，这里只能对其过程作一简单介绍。晶闸管开通和关断过程波形如下图所示，其中开通过程描述的是<strong>使门极在坐标原点时刻开始受到理想阶跃电流触发的情况</strong>；而关断过程描述的是<strong>对已导通的晶闸管，外电路所加电压在某一时刻突然由正向变为反向的情况</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电力电子技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I2C总线与通信协议</title>
      <link href="/2023/07/31/I2C%E6%80%BB%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/07/31/I2C%E6%80%BB%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-I2C总线和通信协议"><a href="#1-I2C总线和通信协议" class="headerlink" title="1. I2C总线和通信协议"></a>1. I2C总线和通信协议</h2><p>I2C(Inter-Integrated Circuit)接口是一种<strong>串行数字总线接口</strong>。I2C接口只有2根信号线，总线上可以连接多个设备，硬件实现简单，可拓展性钱。I2C通信协议可以用普通GPIO引脚进行软件模拟。I2C接口主要用于<strong>通信速率要求不高，以及多个器件之间通信的应用场景。</strong></p><h3 id="1-1-I2C总线结构"><a href="#1-1-I2C总线结构" class="headerlink" title="1.1 I2C总线结构"></a>1.1 I2C总线结构</h3><p>一个器件的I2C接口只有2根信号线，即双向串行数据线SDA和时钟信号线SCL。<strong>I2C是一种多设备总线，一根总线上可以挂在多个设备。</strong></p><p>I2C总线有如下特点：</p><ul><li>I2C总线只有两根信号线，SDA是双向串行数据线，SCL是时钟信号线，用于数据收发的同步。</li><li>I2C总线上可以挂载多个设备，一般有一个主设备、多个从设备。MCU一般作为主设备，外围器件作为从设备。<strong>在I2C通信协议中，主动发起通信的器件就是主设备，被动进行响应的器件就是从设备。</strong></li><li>I2C总线上每个器件有一个7位或10位的地址，<strong>主设备发起通信时，会首先发送目标设备地址，只有地址对应的从设备才会做出响应。</strong></li><li><strong>I2C总线的两根信号线上有上拉电阻</strong>。当I2C器件空闲时，其输出接口是高阻态。当所有设备都空闲时，I2C总线上时高电平。</li><li>I2C通信有标准模式和快速模式，<strong>标准模式传输速率为100Kbit/s，快速模式传输速率为400kbit/s。</strong></li></ul><h3 id="1-2-I2C总线通信时序"><a href="#1-2-I2C总线通信时序" class="headerlink" title="1.2 I2C总线通信时序"></a>1.2 I2C总线通信时序</h3><p>I2C通信总是由主机启动，<strong>每个通信过程由起始信号开始，由停止信号结束</strong>。一个数据包由8位，每个数据包后有一个应答位(ACk)或者非应答位(NACK)。例如，主设备向从设备发送1字节数据的时序图如下：</p><p><img src="I2C传输1字节的时序图.png" alt="I2C传输1字节的时序图"></p><ul><li>起始位：<strong>当SCL为高电平时，SDA的下降沿就是起始位</strong>，是启动一次I2C通信的起始信号。</li><li>停止位：<strong>当SCL为高电平时，SDA的上升沿就是停止位</strong>，是停止一次I2C通信的结束信号。</li><li>数据位：在SCL的一个时钟周期内传输一个数据位，<strong>当SCL位低电平时，发送设备更新SDA的电平，当SCL位高电平时，接收数据读取SDA的电平就是有效的一位数据。</strong></li><li>数据包：<strong>I2C数据通信一个数据包总是8位</strong>，也就是1个字节的数据。</li><li>应答信号：在发送完8位数据包之后，发送设备在第9个SCL时钟周期采集接收设备的应答信号。<strong>若在SCL的第9个周期采集的SDA为低电平，就是应答信号ACK，如果采集的SDA是高电平，就是非应答信号NACK。</strong></li></ul><p>在一次I2C通信过程中，可以传输多个字节的数据。<strong>主机启动I2C通信之后，发送的第一个字节目标设备地址，后面再发送或接收的数据由具体器件的指令定义决定</strong>。I2C通信协议只是定义了基础的数据传输时序，除了用MCU硬件I2C接口实现，也可以用普通GPIO引脚的输入输出模拟I2C通信时序，这个之后再说。</p><h3 id="1-3-I2C总线通信协议"><a href="#1-3-I2C总线通信协议" class="headerlink" title="1.3 I2C总线通信协议"></a>1.3 I2C总线通信协议</h3><p><img src="7Bit设备的数据传输.png" alt="7Bit设备的数据传输"></p><p>在I2C通信之中，<strong>在起始信号后的首字节由7位从机地址和1位读写位组成</strong>，结构如下：</p><p><img src="I2C从机地址结构.png" alt="I2C从机地址结构"></p><p>发送完这个字节之后，主机释放SDA总线等待从机给出ACK应答。如果从机给出了ACK应答，表示从机地址正确（有从机响应）并且已知晓是读还是写，便可以开始读写数据。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由master来决定如何处理（STOP或ReSTART）。</p><ol><li><strong>主机写-从机接收</strong></li></ol><p>主机对从机发送数据时，主机对从机发送一个开始字节，然后即可一直发送数据。以示例来讲解，其第一帧数据为要操作的寄存器地址，所以为：“<strong>[1-Byte]开始字节(写) + [1-Byte]寄存器地址 + [1-Byte]寄存器数据</strong>”。</p><p><img src="I2C向一个寄存器写入数据.png" alt="I2C向一个寄存器写入数据"></p><ol><li><strong>主机读-从机发送</strong></li></ol><p><strong>主机对向从机读取数据时，方式同发送数据有所不同，要多一次通信过程</strong>。主机需要先向从机发送一次信号，告诉从机”我要读取数据“，然后重开一次通信，等待从机主动返回数据。以示例来讲解，发送 “<strong>[1-Byte]开始字节(写) + [1-Byte]要读取的寄存器的地址</strong>”，之后结束通信，或者重开始，来进入到第二次通信中，<strong>先发送 [1-Byte]开始字节(读)</strong>，<strong>然后等待读取从机发送过来的 [1-Byte]数据即可</strong>。</p><p><img src="I2C读取一个寄存器的数据.png" alt="I2C读取一个寄存器的数据"></p><h2 id="2-I2C的驱动程序"><a href="#2-I2C的驱动程序" class="headerlink" title="2. I2C的驱动程序"></a>2. I2C的驱动程序</h2><p>驱动程序包括宏定义、结构体定义、宏函数和功能函数。<strong>I2C的数据传输有阻塞式、中断式、和DMA式。</strong></p><h3 id="2-1-阻塞式数据传输"><a href="#2-1-阻塞式数据传输" class="headerlink" title="2.1 阻塞式数据传输"></a>2.1 阻塞式数据传输</h3><p>阻塞式数据传输使用方便，且<strong>I2C接口的传输速率不高，一般穿数据量也不大</strong>，故阻塞式传输时常用的数据传输方式。</p><h4 id="2-1-1-阻塞式数据传输相关函数"><a href="#2-1-1-阻塞式数据传输相关函数" class="headerlink" title="2.1.1 阻塞式数据传输相关函数"></a>2.1.1 阻塞式数据传输相关函数</h4><div class="table-container"><table><thead><tr><th>函数名</th><th>功能描述</th></tr></thead><tbody><tr><td>HAL_I2C_IsDeviceReady()</td><td>检查摸个从设备是否准备好了I2C通信</td></tr><tr><td>HAL_I2C_Master_Transmit()</td><td>作为主设备向某个地址的从设备发送一定长度的数据</td></tr><tr><td>HAL_I2C_Master_Recevie()</td><td>作为主设备向某个地址的从设备接收一定长度的数据</td></tr><tr><td>HAL_I2C_Slave_Transmit()</td><td>作为从设备发送一定长度的数据</td></tr><tr><td>HAL_I2C_Slave_Receive()</td><td>作为从设备接收一定长度的数据</td></tr><tr><td>HAL_I2C_Mem_Write()</td><td>向某个从设备的指定存储地址开始写入一定长度的数据</td></tr><tr><td>HAL_I2C_Mem_Read()</td><td>向某个从设备的指定存储地址开始读取一定长度的数据</td></tr></tbody></table></div><h4 id="2-1-2-阻塞式数据传输实验"><a href="#2-1-2-阻塞式数据传输实验" class="headerlink" title="2.1.2 阻塞式数据传输实验"></a>2.1.2 阻塞式数据传输实验</h4><p>硬件平台：正点原子战舰V3开发板</p><p>实验内容：I2C读取/写入24C02数据</p><p>使用STM32CubeMX生成工程文件，CubeMX配置图如下：</p><p><img src="I2C_CubeMX配置.png" alt></p><p>I2C1的参数设置分为两组：</p><p>(1) Master Features组，主设备参数</p><ul><li>I2C Speed Mode：速度模式，<strong>可选择标准模式(Standard Mode)或快速模式(Fast Mode)。</strong>本次实验我们选择标准模式。</li><li>I2C Clock Speed(Hz)：<strong>I2C时钟速度，标准模式最大值为100kHz，快速模式最大值为400kHz。</strong>本次实验使用标准模式最大值100kHz。</li><li>Fast Mode Duty Cycle(快速模式下配置)：快速模式占空比，选择快速模式后这个参数会出现，用于设置时钟信号的占空比，是一个周期内低电平与高电平的时间比，有2：1和16：9两种选项。本次实验使用标准模式，故图中没有出现这个参数。</li></ul><p>(2)Slave Features组，从设备参数</p><ul><li>Clock No Streth Mode：禁止时钟延长，设置为Disable表示允许时间延长。</li><li>Primary Address Length selection：设备主地址长度，可选7-bit或10-bit，这里选择7-bit。</li><li>Dual Address Acknowledge：双地址确认，从设备可以有两个地址，如果设置为Enabled，还会出现一个Secondary slave address参数，用于设置从设备副地址。</li><li>Primary slave address：从设备主地址，设置从设备主地址，作为I2C从设备时才需要设置。</li><li>General Call address detection，广播呼叫检测，设置为Disabled表示禁止广播呼叫，不对地址0x00应答；否则，就是允许广播呼叫，对地址0x00应答。</li></ul><h4 id="2-1-3-24C02-C相关函数"><a href="#2-1-3-24C02-C相关函数" class="headerlink" title="2.1.3 24C02.C相关函数"></a>2.1.3 24C02.C相关函数</h4><p>函数<code>EP24C_IsDeviceReady(void)</code>用于检查24C02是否做好了I2C通信的准备。其中：</p><ul><li><code>I2C_HANDLE</code>是I2C接口的对象指针</li><li><code>Dev_ADDR_24CXX</code>是24C02的写地址</li><li><code>Trials</code>为尝试的次数</li><li><code>EP24C_TIMEOUT</code>是超时等待时间。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">EP24C_IsDeviceReady</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> Trials = <span class="number">10</span>; <span class="comment">/*!&lt; 尝试次数 */</span></span><br><span class="line">    HAL_StatusTypeDef result = HAL_I2C_IsDeviceReady(&amp;I2C_HANDLE, DEV_ADDR_24CXX, Trials, EP24C_TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>EP24C_WriteOneByte(uint16_t memAddress, uint8_t byteData)</code>为向24C02指定地址写入一字节数据。其中：</p><ul><li><code>memAddress</code>为存储器内部写入数据的起始地址；</li><li><code>byteData</code>为带写入数据的缓冲区指针；</li><li><code>EP24C_MEMADD_SIZE</code>为存储器内部地址大小；</li><li>1为写入的数据字节数；</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">EP24C_WriteOneByte</span><span class="params">(<span class="type">uint16_t</span> memAddress, <span class="type">uint8_t</span> byteData)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_StatusTypeDef result = HAL_I2C_Mem_Write(&amp;I2C_HANDLE, DEV_ADDR_24CXX, memAddress, EP24C_MEMADD_SIZE, &amp;byteData, <span class="number">1</span>, EP24C_TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与函数<code>EP24C_WriteOneByte(uint16_t memAddress, uint8_t byteData)</code>类似，函数<code>EP24C_ReadOneByte(uint16_t memAddress, uint8_t *pBuffer)</code>为读取指定地址的一字节数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">EP24C_ReadOneByte</span><span class="params">(<span class="type">uint16_t</span> memAddress, <span class="type">uint8_t</span> *pBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_StatusTypeDef result = HAL_I2C_Mem_Read(&amp;I2C_HANDLE, DEV_ADDR_24CXX, memAddress, EP24C_MEMADD_SIZE, pBuffer, <span class="number">1</span>, EP24C_TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础的读写函数就是这样，接下来就是对读写函数的应用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!&lt; 从指定地址读取指定长度数据 */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">EP24C_ReadBytes</span><span class="params">(<span class="type">uint16_t</span> memAddress, <span class="type">uint8_t</span> *pBuffer, <span class="type">uint16_t</span> bufferLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bufferLen &gt; MEM_SIZE_24CXX)</span><br><span class="line">        <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line"></span><br><span class="line">    HAL_StatusTypeDef result = HAL_I2C_Mem_Read(&amp;I2C_HANDLE, DEV_ADDR_24CXX, memAddress, EP24C_MEMADD_SIZE, pBuffer, bufferLen, EP24C_TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!&lt; 在限定的一页内写入连续数据，最多8字节。可以从任意地址开始，但是起始地址+数据长度不能超过页边距 */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">EP24C_WriteInOnePage</span><span class="params">(<span class="type">uint16_t</span> memAddress, <span class="type">uint8_t</span> *pBuffer, <span class="type">uint16_t</span> bufferLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bufferLen &gt; PAGE_SIZE_24CXX)</span><br><span class="line">        <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line">    HAL_StatusTypeDef result = HAL_I2C_Mem_Write(&amp;I2C_HANDLE, DEV_ADDR_24CXX, memAddress, EP24C_MEMADD_SIZE, pBuffer, bufferLen, EP24C_TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!&lt; 写任意长度的数据，可以超过8字节，但是数据地址必须从页首开始，即8xN。自动分解多次写入 */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">EP24C_WriteLongData</span><span class="params">(<span class="type">uint16_t</span> memAddress, <span class="type">uint8_t</span> *pBuffer, <span class="type">uint16_t</span> bufferLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bufferLen &gt; MEM_SIZE_24CXX)</span><br><span class="line">        <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line"></span><br><span class="line">    HAL_StatusTypeDef result = HAL_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (bufferLen &lt; PAGE_SIZE_24CXX)</span><br><span class="line">    &#123;</span><br><span class="line">        result = HAL_I2C_Mem_Write(&amp;I2C_HANDLE, DEV_ADDR_24CXX, memAddress, EP24C_MEMADD_SIZE, pBuffer, bufferLen, EP24C_TIMEOUT);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint8_t</span> *point = pBuffer;</span><br><span class="line">    <span class="type">uint16_t</span> pageCount = bufferLen / PAGE_SIZE_24CXX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; pageCount; i++) <span class="comment">/*!&lt; 一次写入一个PAGE的数据 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = HAL_I2C_Mem_Write(&amp;I2C_HANDLE, DEV_ADDR_24CXX, memAddress, EP24C_MEMADD_SIZE, point, PAGE_SIZE_24CXX, EP24C_TIMEOUT);</span><br><span class="line">        point += PAGE_SIZE_24CXX;</span><br><span class="line">        memAddress += PAGE_SIZE_24CXX;</span><br><span class="line">        HAL_Delay(<span class="number">5</span>); <span class="comment">/*!&lt; 等待这一页写完 */</span></span><br><span class="line">        <span class="keyword">if</span> (result != HAL_OK)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint16_t</span> leftBytes = bufferLen % PAGE_SIZE_24CXX;<span class="comment">/*!&lt; 剩余数据 */</span></span><br><span class="line">    <span class="keyword">if</span> (leftBytes &gt; <span class="number">0</span>)</span><br><span class="line">        result = HAL_I2C_Mem_Write(&amp;I2C_HANDLE, DEV_ADDR_24CXX, memAddress, EP24C_MEMADD_SIZE, point, PAGE_SIZE_24CXX, EP24C_TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.c中的while(1)函数处理如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">      <span class="keyword">switch</span>(KeyScan(<span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">case</span> WKUP_PRES:</span><br><span class="line">              EP24C_WriteOneByte(addr_any, num1);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> KEY1_PRES:</span><br><span class="line">              EP24C_ReadOneByte(addr_any, &amp;num2);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> KEY2_PRES:</span><br><span class="line">              EP24C_WriteLongData(addr_page, i2cTxBuf, <span class="keyword">sizeof</span>(i2cTxBuf));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> KEY0_PRES:</span><br><span class="line">              EP24C_ReadBytes(addr_page, i2cRxBuf, <span class="number">50</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以通过按键向24c02写入/读取一个或多个数据，例如按下WKUP按键，向24c02的寄存器0x04写入数据num1 = 0x6b,使用逻辑分析仪查看时序图如下：</p><p><img src="24c02_WriteOneByte.png" alt></p><p>再通过按下KEY1读取寄存器0x04数据到num2，使用逻辑分析仪查看时序图如下：</p><p><img src="24c02_ReadOneByte.png" alt></p><h2 id="3-GPIO模拟I2C"><a href="#3-GPIO模拟I2C" class="headerlink" title="3. GPIO模拟I2C"></a>3. GPIO模拟I2C</h2><h3 id="3-1-GPIO模拟I2C驱动程序"><a href="#3-1-GPIO模拟I2C驱动程序" class="headerlink" title="3.1 GPIO模拟I2C驱动程序"></a>3.1 GPIO模拟I2C驱动程序</h3><h4 id="3-1-1-准备工作"><a href="#3-1-1-准备工作" class="headerlink" title="3.1.1 准备工作"></a>3.1.1 准备工作</h4><p>使用GPIO模拟I2C之前，首先要进行IO口的配置，CubeMX配置图如下：</p><p><img src="GPIO_I2CCubeMX配置.png" alt></p><p>其中<strong>SDA口要设置成<code>Output Open Drain</code>开漏输出模式</strong>，因为使用GPIO模拟I2C时，SDA口需要是双向的，设置成开漏输出模式，就可以不用设置SDA口的输出模式，在SDA为输出模式时，也可以读取SDA IO口的状态。</p><p>其次，使用GPIO模拟I2C需要使用us级延时，而STM32的HAL库只支持ms级延时，我们可以通过SysTick定时器产生us级延时。</p><p>首先是延时函数的初始化，主要是对SysTick定时器的一些配置。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 配置SysTick使用外部时钟源，是AHB总线时钟的1/8有72MHz/8=9MHz</span></span><br><span class="line">    SysTick-&gt;CTRL &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// SysTick计算一个数需要 1/9MHz 秒,计算9个数则需要9*1/9MHz=1us,所以延时函数delay_us传入的数值是“需要多少个1us”,delay_ms同理</span></span><br><span class="line">    fac_us = <span class="number">9</span>;</span><br><span class="line">    fac_ms = (<span class="type">uint16_t</span>)fac_us * <span class="number">1000</span>; <span class="comment">// 1ms = 1000us</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后就是us级延时函数以及ms延时函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint32_t</span> nus)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> temp;</span><br><span class="line">    SysTick-&gt;LOAD = nus * fac_us;             <span class="comment">// 时间加载</span></span><br><span class="line">    SysTick-&gt;VAL = <span class="number">0x00</span>;                      <span class="comment">// 清空计数器</span></span><br><span class="line">    SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk; <span class="comment">// 开始倒数</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = SysTick-&gt;CTRL;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((temp &amp; <span class="number">0x01</span>) &amp;&amp; !(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))); <span class="comment">// 等待时间到达</span></span><br><span class="line">    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;      <span class="comment">// 关闭计数器</span></span><br><span class="line">    SysTick-&gt;VAL = <span class="number">0X00</span>;                            <span class="comment">// 清空计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于ms级延时函数<code>delay_ms()</code>，需要注意nms的范围<code>SysTick-&gt;LOAD</code>为24位寄存器，所以,最大延时为:<code>nms&lt;=0xffffff*8*1000/SYSCLK</code>，<code>SYSCLK</code>单位为Hz,nms单位为ms，对72M条件下,<code>nms&lt;=1864</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint16_t</span> nms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> temp;</span><br><span class="line">    SysTick-&gt;LOAD = (<span class="type">uint32_t</span>)nms * fac_ms;   <span class="comment">// 时间加载(SysTick-&gt;LOAD为24bit)</span></span><br><span class="line">    SysTick-&gt;VAL = <span class="number">0x00</span>;                      <span class="comment">// 清空计数器</span></span><br><span class="line">    SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk; <span class="comment">// 开始倒数</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = SysTick-&gt;CTRL;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((temp &amp; <span class="number">0x01</span>) &amp;&amp; !(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))); <span class="comment">// 等待时间到达</span></span><br><span class="line">    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;      <span class="comment">// 关闭计数器</span></span><br><span class="line">    SysTick-&gt;VAL = <span class="number">0X00</span>;                            <span class="comment">// 清空计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-IOI2C驱动"><a href="#3-1-2-IOI2C驱动" class="headerlink" title="3.1.2 IOI2C驱动"></a>3.1.2 IOI2C驱动</h4><p>首先是I2C的起始信号和结束信号，再复习一下I2C的基础：<strong>起始和结束信号产生条件：总线在空闲状态时，SCL和SDA都保持着高电平。</strong></p><ul><li>当SCL为高电平而SDA由高到低的跳变，表示产生一个起始条件；</li><li>当SCL为高而SDA由低到高的跳变，表示产生一个停止条件。</li></ul><p><img src="I2C传输1字节的时序图.png" alt="I2C传输1字节的时序图"></p><p>代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C1_SDA_Out1();</span><br><span class="line">    I2C1_SCL_Out1(); delay_general();</span><br><span class="line">    I2C1_SDA_Out0(); delay_general();</span><br><span class="line">    I2C1_SCL_Out0(); delay_general();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C1_SDA_Out0(); delay_general();</span><br><span class="line">    I2C1_SCL_Out1(); delay_general();</span><br><span class="line">    I2C1_SDA_Out1(); delay_general();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是I2C数据传输功能，<strong>I2C数据传输以字节为单位，主设备SCL线上产生每个时钟脉冲的过程中将在SDA线上传输一个数据位。并且，SDA只有在SCL为低电平的时候才能变化。</strong></p><p>I2C发送一个字节的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C1_SendByte</span><span class="params">(<span class="type">uint8_t</span> txd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> t;</span><br><span class="line">    </span><br><span class="line">    I2C1_SCL_Out0();</span><br><span class="line">    delay_general();</span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="number">8</span>; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((txd &amp; <span class="number">0x80</span>) &gt;&gt; <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            I2C1_SDA_Out1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            I2C1_SDA_Out0();</span><br><span class="line">        &#125;</span><br><span class="line">        txd &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        I2C1_SCL_Out1();</span><br><span class="line">        delay_general();</span><br><span class="line">        I2C1_SCL_Out0();</span><br><span class="line">        delay_general();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I2C读取一个字节的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C1_ReadByte</span><span class="params">(<span class="type">uint8_t</span> ack)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> receive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        I2C1_SCL_Out1();</span><br><span class="line">        delay_general();</span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (I2C1_SDA_READ())</span><br><span class="line">        &#123;</span><br><span class="line">            receive++;</span><br><span class="line">        &#125;</span><br><span class="line">        I2C1_SCL_Out0();</span><br><span class="line">        delay_general();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C1_NAck();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        I2C1_Ack();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个字节按照数据位从高位到地位的顺序传输完成之后，从机会拉低SDA线，回应给主机一个应答位，此时才认为一个字节真正的被传输完成。<strong>当然，并不是所有的字节传输都必须有一个应答位，比如：当从设备不能再接收主设备发送的数据时，从设备将回传一个非定应答位。</strong></p><p>I2C作为主机等待从机应答代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!&lt; 等待应答信号 </span></span><br><span class="line"><span class="comment">  !&lt; 返回值：1 = 接收应答失败，0 = 接收应答成功 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C1_WaitAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ucErrTime = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> rack = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    I2C1_SDA_Out1();</span><br><span class="line">    delay_general();</span><br><span class="line">    I2C1_SCL_Out1();</span><br><span class="line">    delay_general();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (I2C1_SDA_READ())</span><br><span class="line">    &#123;</span><br><span class="line">        ucErrTime++;</span><br><span class="line">        <span class="keyword">if</span> (ucErrTime &gt; <span class="number">250</span>)&#123;</span><br><span class="line">            I2C1_Stop();</span><br><span class="line">            rack = <span class="number">1</span>; <span class="comment">/*!&lt; 接收应答失败 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    I2C1_SCL_Out0();</span><br><span class="line">    <span class="keyword">return</span> rack; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在I2C主机读取从机数据时，也需要发送应答位或者非应答位，其代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!&lt; 产生ACK应答信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C1_SCL_Out0(); delay_general();</span><br><span class="line">    I2C1_SDA_Out0(); delay_general();</span><br><span class="line">    I2C1_SCL_Out1(); delay_general();</span><br><span class="line">    I2C1_SCL_Out0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C1_NAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C1_SCL_Out0(); delay_general();</span><br><span class="line">    I2C1_SDA_Out1(); delay_general();</span><br><span class="line">    I2C1_SCL_Out1(); delay_general();</span><br><span class="line">    I2C1_SCL_Out0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-AT24C02驱动程序"><a href="#3-1-3-AT24C02驱动程序" class="headerlink" title="3.1.3 AT24C02驱动程序"></a>3.1.3 AT24C02驱动程序</h4><p>调用IOI2C程序，来驱动AT24C02实现读取/写入STM32 EEPROM。首先是读取AT24C02中的一个字节。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">AT24C02_ReadOneByte</span><span class="params">(<span class="type">uint16_t</span> RegAddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> receive = <span class="number">0</span>;</span><br><span class="line">    I2C1_Start();</span><br><span class="line">    I2C1_SendByte(DEV_ADDR_24C02_W);</span><br><span class="line">    I2C1_WaitAck();</span><br><span class="line">    </span><br><span class="line">    I2C1_SendByte(RegAddr);</span><br><span class="line">    I2C1_WaitAck();</span><br><span class="line">      </span><br><span class="line">    I2C1_Start();</span><br><span class="line">    I2C1_SendByte(DEV_ADDR_24C02_R);</span><br><span class="line">    I2C1_WaitAck();</span><br><span class="line">      </span><br><span class="line">    receive = I2C1_ReadByte(<span class="number">0</span>);</span><br><span class="line">    I2C1_Stop();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数入口参数<code>RegAddr</code>为要读取数据的寄存器地址。</p><p>向AT24C02写入一个字节函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AT24C02_WriteOneByte</span><span class="params">(<span class="type">uint16_t</span> RegAddr, <span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C1_Start();</span><br><span class="line">    I2C1_SendByte(DEV_ADDR_24C02_W);</span><br><span class="line">    I2C1_WaitAck();</span><br><span class="line">    </span><br><span class="line">    I2C1_SendByte(RegAddr);</span><br><span class="line">    I2C1_WaitAck();</span><br><span class="line">    </span><br><span class="line">    I2C1_SendByte(data);</span><br><span class="line">    I2C1_WaitAck();</span><br><span class="line">    I2C1_Stop();</span><br><span class="line">    delay_ms(<span class="number">10</span>); <span class="comment">/*!&lt;= 注意: EEPROM 写入比较慢,必须等到10ms后再写下一个字节 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I2C不允许连续写入，尤其是EEPROM写入比较慢，所以必须等待10ms才可以写入下一个字节。</p><p>有了上面两个函数，可以根据这两个函数封装成向AT24C02连续写入/读取数据的函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AT24C02_ReadReg</span><span class="params">(<span class="type">uint16_t</span> RegAddr, <span class="type">uint8_t</span> *pBuf, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(datalen--)</span><br><span class="line">    &#123;</span><br><span class="line">        *pBuf++ = AT24C02_ReadOneByte(RegAddr++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AT24C02_WriteReg</span><span class="params">(<span class="type">uint16_t</span> RegAddr, <span class="type">uint8_t</span> *pBuf, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(datalen--)</span><br><span class="line">    &#123;</span><br><span class="line">        AT24C02_WriteOneByte(RegAddr, *pBuf);</span><br><span class="line">        RegAddr++;</span><br><span class="line">        pBuf++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>RegAddr</code>为AT24C02寄存器地址，<code>*pBuf</code>为读取/写入的地址，<code>datalen</code>为读取/写入的数据长度。</p><h3 id="3-2-应用程序"><a href="#3-2-应用程序" class="headerlink" title="3.2 应用程序"></a>3.2 应用程序</h3><p>在死循环之前，需要初始化延时函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delay_init();</span><br></pre></td></tr></table></figure><p>之后在死循环中通过扫描按键向24c02写入/读取一个或多个数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">switch</span>(KeyScan(<span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">case</span> WKUP_PRES:</span><br><span class="line">             AT24C02_WriteOneByte(addr_any, num1);</span><br><span class="line">          <span class="keyword">case</span> KEY1_PRES:</span><br><span class="line">              num2 = AT24C02_ReadOneByte(addr_any);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> KEY2_PRES:</span><br><span class="line">              AT24C02_WriteReg(<span class="number">0</span>,i2cTxBuf,test_size);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> KEY0_PRES:</span><br><span class="line">              AT24C02_ReadReg(<span class="number">0</span>,i2cRxBuf,test_size);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>例如，按下KEY2向AT24C02写入一串数据<code>i2c test</code>,使用逻辑分析仪分析时序如下：</p><p><img src="ioi2c写入AT24C02数据.png" alt></p><p>可以看到，STM32向AT24C02写入了许多Byte数据，并且，每个Byte数据之间间隔10ms。</p><p><img src="ioi2c写入AT24C02数据2.png" alt></p><p>放大显示发送第一个Byte数据时序如下：</p><p><img src="ioi2c写入AT24C02数据第一个字节.png" alt></p><p>之后按下KEY0向AT24C02读取这串数据,使用逻辑分析仪分析时序如下：</p><p><img src="ioi2c读取AT24C02数据.png" alt></p><p>同样放大显示读取第一个Byte数据时序如下：</p><p><img src="ioi2c读取AT24C02数据第一Byte.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> STM32 </tag>
            
            <tag> I2C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双环控制PID算法</title>
      <link href="/2023/07/27/%E5%8F%8C%E7%8E%AF%E6%8E%A7%E5%88%B6PID%E7%AE%97%E6%B3%95/"/>
      <url>/2023/07/27/%E5%8F%8C%E7%8E%AF%E6%8E%A7%E5%88%B6PID%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-PID算法概念"><a href="#1-PID算法概念" class="headerlink" title="1. PID算法概念"></a>1. PID算法概念</h3><p>PID算法是工业应用中最广泛算法之一，在闭环系统的控制中，可自动对控制系统进行准确且迅速的校正。PID算法已经有100多年历史，在四轴飞行器，平衡小车、汽车定速巡航、温度控制器等场景均有应用。</p><h4 id="PID算法数学公式"><a href="#PID算法数学公式" class="headerlink" title="PID算法数学公式"></a>PID算法数学公式</h4><p>PID算法数学公式如下所示：</p><script type="math/tex; mode=display">u(t) = K_pe(t) + K_i \int^t_0e(t)dt + K_d \frac{de(t)}{dt}</script><p>该公式适用于连续的模拟量信号，然而本系统中使用的传感器数据为离散的数字量信号，故而需要对公式进行离散化处理，使用一阶差分代替一阶微分、使用累加代 替积分，离散化之后的公式如下：</p><script type="math/tex; mode=display">u(t) = K_pe(t) + K_i \sum(t) + K_d[e(t) - e(t-1)]</script><h3 id="2-双环控制PID算法"><a href="#2-双环控制PID算法" class="headerlink" title="2. 双环控制PID算法"></a>2. 双环控制PID算法</h3><p>在比较复杂的系统之中，普通的PID算法可能不能满足系统的需求，在工业控制中，对于复杂的系统，常见的方法是使用多环控制的PID算法。针对基于PID的智能自平衡小车，最常见的方法就是使用双环控制的PID算法。</p><p>在智能自平衡车的双环控制PID算法中，包含直立环和速度环可实现小车在原地保持平衡状态，若小车需要转向，也可以再加入转向环，本文主要详细讲述直立环和速度环的双环控制。</p><h4 id="PD直立环"><a href="#PD直立环" class="headerlink" title="PD直立环"></a>PD直立环</h4><p>直立环使用PD控制，用于控制小车保持直立状态。直立环的入口参数为小车当前的倾斜角度<code>Angle</code>与X轴角速度 <code>Gyro_X</code>（即为角度的微分），具体的算法实现为：计算出小车当前角度与平衡角度的偏差<code>Angle_bias</code>带入PD控制公式：</p><script type="math/tex; mode=display">u(t)=K_pe(t) + K_d[e(t) - e(t-1)]</script><p>可以得到直立环的PWM输出值为：</p><script type="math/tex; mode=display">BalancePWM = BalanceK_p \times AngleBias + BalanceK_d \times GyroX</script><p>其中<code>BalancePWM</code>为直立环比例增益；<code>BalanceKd</code>为直立环微分增益；</p><p>直立环代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Balance</span><span class="params">(<span class="type">float</span> Angle, <span class="type">float</span> Gyro)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> Angle_bias, Gyro_bias;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    Angle_bias = Middle_angle - Angle; <span class="comment">// 求出平衡的角度中值 和机械相关</span></span><br><span class="line">    Gyro_bias = <span class="number">0</span> - Gyro;</span><br><span class="line">    balance = -PID.Balance_Kp / <span class="number">100</span> * Angle_bias - Gyro_bias * PID.Balance_Kd / <span class="number">100</span>; <span class="comment">// 计算平衡控制的电机PWM</span></span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="PI速度环"><a href="#PI速度环" class="headerlink" title="PI速度环"></a>PI速度环</h4><p>速度环使用PI控制，用于控制小车的速度。速度环入口参数为小车左右电机的转 速。在平衡模式下，小车的理想状态是保持直立，并且尽量保持在原地不动，故此时 小车的目标速度为0。同时为了减小速度环对直立环的干扰，速度环的速度变化应该缓 慢且平和，故而在速度环中使用一阶低通滤波，减缓速度的变化。一阶低通滤波公式如下：</p><script type="math/tex; mode=display">y(n) = Kx(n) + (1-K) y (n-1)</script><p>与直立环类似，速度环也需要先求出当前的速度偏差量<code>Speed_bias</code> ，经过一阶低通滤波之后，带入PI控制公式：</p><script type="math/tex; mode=display">u(t) = K_pe(t) + K_i \sum e(t)</script><p>可以得到速度环的PWM输出值为：</p><script type="math/tex; mode=display">VelocityPWM = VelocityK_p \times VelocityBias + VelocityK_i \times \sum VelocityBias</script><p>速度环代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Velocity</span><span class="params">(<span class="type">int</span> encoder_left, <span class="type">int</span> encoder_right)</span></span><br><span class="line">&#123;</span><br><span class="line">    Encoder_Least = <span class="number">0</span> - (encoder_left + encoder_right); </span><br><span class="line">    Encoder_bias *= <span class="number">0.86</span>;                 <span class="comment">// 一阶低通滤波器</span></span><br><span class="line">    Encoder_bias += Encoder_Least * <span class="number">0.14</span>; <span class="comment">// 一阶低通滤波器，减缓速度变化</span></span><br><span class="line">    Encoder_Integral += Encoder_bias;     <span class="comment">// 积分出位移 积分时间：10ms</span></span><br><span class="line">    Encoder_Integral = Encoder_Integral + Movement;<span class="comment">// 接收遥控器数据，控制前进后退</span></span><br><span class="line">    <span class="keyword">if</span> (Encoder_Integral &gt; <span class="number">10000</span>)</span><br><span class="line">        Encoder_Integral = <span class="number">10000</span>; <span class="comment">// 积分限幅</span></span><br><span class="line">    <span class="keyword">if</span> (Encoder_Integral &lt; <span class="number">-10000</span>)</span><br><span class="line">        Encoder_Integral = <span class="number">-10000</span>;                                                               <span class="comment">// 积分限幅</span></span><br><span class="line">    velocity = -Encoder_bias * PID.Velocity_Kp / <span class="number">100</span> - Encoder_Integral * PID.Velocity_Ki / <span class="number">100</span>; <span class="comment">// 速度控制</span></span><br><span class="line">    <span class="keyword">if</span> (Turn_Off(BalanceCar.Angle_Balance, BalanceCar.Voltage) == <span class="number">1</span> || BalanceCar.Flag_Stop == <span class="number">1</span>)</span><br><span class="line">        Encoder_Integral = <span class="number">0</span>; <span class="comment">// 电机关闭后清除积分</span></span><br><span class="line">    <span class="keyword">return</span> velocity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果小车出现倾角，在直立控制的作用下就会使小车在倾斜的方向加速，我们可以利用小车的这个特性来进行速度控制。<strong>控制速度实际上就变成了控制小车的倾角。</strong></p><p>车轮的速度可以通过读取编码器数值来获得。小车的速度控制对快速性要求并不高，但是对于准确性有一定的要求。PID 控制中微分(Didderential)控制 主要的作用是减少振荡，加快稳定速度，积分(Intergral)控制主要的作用是减少静态误差，所以我们可以建立速度 PI 闭环控制。输出一个角度使小车达到目标速度，这就是串级PID控制，<strong>让速度环的输出作为直立环的输入，角度控制的输出直接作用于电机上。</strong></p><p><img src="Resources/项目Project/PID_BalanceCar/image/Software/双环控制PID.png" alt="双环控制PID"></p><p>假如速度环输出为<code>v</code>，作为目标角度输出直立环，直立环的输出<code>a</code>直接作用于电机，使小车产生一个倾角，那么由如下关系：</p><script type="math/tex; mode=display">a=K_p \times (v - v_1) + K_d \times dv</script><script type="math/tex; mode=display">v_1 = K_p \times e(k) + K_i \times \sum e(k)</script><p>我们将两个式子合并，可以得到下面公式：</p><script type="math/tex; mode=display">a = K_p \times v + K_d \times dv - K_p[Kp_1 \times e(k) + K_i \sum e(k)]</script><p>a 为直接输出于小车的 PWM。观察式子可以知道，这个串级 PID 系统实际 上是由一个 PD 控制器和一个 PI 控制器组成，我们可以分拆优化为两个控制环分别叠加到电机 PWM 上。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> PID算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>modbus-blog</title>
      <link href="/2023/07/21/modbus-blog/"/>
      <url>/2023/07/21/modbus-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="modbus-RTU协议"><a href="#modbus-RTU协议" class="headerlink" title="modbus-RTU协议"></a>modbus-RTU协议</h1><p><strong>Modbus报文帧结构</strong><br>一个报文就是一帧数据，一个数据帧就一个报文： 指的是一串完整的指令数据，本质就是一串数据<br>Modbus协议在串行链路上的报文格式如下所示：<br><img src="https://github.com/KeyL-SJ/stm32_uart_modbus/assets/78483846/bcec2fe4-3a28-42b3-b2aa-8d75f8fe1f36" alt="image"></p><div class="table-container"><table><thead><tr><th style="text-align:center">从机地址</th><th style="text-align:center">功能码</th><th style="text-align:center">数据</th><th style="text-align:center">CRC校验</th></tr></thead><tbody><tr><td style="text-align:center">1 byte</td><td style="text-align:center">1 byte</td><td style="text-align:center">N bytes</td><td style="text-align:center">2 bytes</td></tr></tbody></table></div><p><strong>帧结构 = 从机地址 + 功能吗 + 数据 + 校验</strong></p><ul><li><p>从机地址: 每个从机都有唯一地址，占用一个字节,范围0-255,其中有效范围是1-247,其中255是广播地址(广播就是对所有从机发送应答)</p></li><li><p>功能码: 占用一个字节,功能码的意义就是,知道这个指令是干啥的,比如你可以查询从机的数据,也可以修改从机的数据,所以不同功能码对应不同功能.</p></li><li>数据: 根据功能码不同,有不同功能，比方说功能码是查询从机的数据，这里就是查询数据的地址和查询字节数等。</li><li>校验: 在数据传输过程中可能数据会发生错误，CRC检验检测接收的数据是否正确</li></ul><h1 id="Modbus功能码"><a href="#Modbus功能码" class="headerlink" title="Modbus功能码"></a>Modbus功能码</h1><p><strong>Modbus规定了多个功能，那么为了方便的使用这些功能，我们给每个功能都设定一个功能码，也就是指代码。</strong></p><p>Modbus协议同时规定了二十几种功能码，但是常用的只有8种，用于对存储区的读写，如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">功能码</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">01H</td><td style="text-align:center">读取输出线圈</td></tr><tr><td style="text-align:center">02H</td><td style="text-align:center">读取输入线圈</td></tr><tr><td style="text-align:center">03H</td><td style="text-align:center">读取保持寄存器</td></tr><tr><td style="text-align:center">04H</td><td style="text-align:center">读取输入寄存器</td></tr><tr><td style="text-align:center">05H</td><td style="text-align:center">写入单线圈</td></tr><tr><td style="text-align:center">06H</td><td style="text-align:center">写入单寄存器</td></tr><tr><td style="text-align:center">0FH</td><td style="text-align:center">写入多线圈</td></tr><tr><td style="text-align:center">10H</td><td style="text-align:center">写入多寄存器</td></tr></tbody></table></div><p>当然我们用的最多的就是03和06 一个是读取数据，一个是修改数据。</p><h1 id="CRC校验"><a href="#CRC校验" class="headerlink" title="CRC校验"></a>CRC校验</h1><p><strong>错误校验（CRC）域占用两个字节包含了一个16位的二进制值。CRC值由传输设备计算出来，然后附加到数据帧上，接收设备在接收数据时重新计算CRC值，然后与接收到的CRC域中的值进行比较，如果这两个值不相等，就发生了错误。</strong></p><p>例如若主机向从机发送报文<code>01 03 00 00 00 01 84 0A</code> 其中， 最后两个字节<code>84 0A</code>就是CRC校验位，从机接收到主机发送的报文之后，根据报文的非校验位<code>01 03 00 00 00 01</code>计算CRC校验位，若从机计算出的校验位与主机发送的校验位相同，则证明数据在发送的过程中没有发生错误，反之，则代表数据传输发生错误。</p><h2 id="CRC校验流程"><a href="#CRC校验流程" class="headerlink" title="CRC校验流程"></a>CRC校验流程</h2><p>1、预置一个16位寄存器为<code>0FFFFH</code>（全1），称之为CRC寄存器。</p><p>2 、把数据帧中的第一个字节的8位与CRC寄存器中的低字节进行异或运算，结果存回CRC寄存器。</p><p>3、将CRC寄存器向右移一位，最高位填以0，最低位移出并检测。</p><p>4 、如果最低位为0：重复第三步（下一次移位）；如果最低位为1：将CRC寄存器与一个预设的固定值<code>0A001H</code>进行异或运算。</p><p>5、重复第三步和第四步直到8次移位。这样处理完了一个完整的八位。</p><p>6 、重复第2步到第5步来处理下一个八位，直到所有的字节处理结束。</p><p>7、最终CRC寄存器的值就是CRC的值。</p><p>看着很复杂哈，其实理解了原理就很简单了，这里贴出本项目中CRC校验的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">modbus_crc16</span><span class="params">(<span class="type">uint8_t</span> *pbuffer, <span class="type">uint16_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> crc_high = <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">uint16_t</span> crc_low = <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (length--)</span><br><span class="line">    &#123;</span><br><span class="line">        index = crc_high ^ *pbuffer++;</span><br><span class="line">        crc_high = crc_low ^ auchCRCHi[index];</span><br><span class="line">        crc_low = auchCRCLo[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (crc_high &lt;&lt; <span class="number">8</span> | crc_low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="详细的发送和接收数据："><a href="#详细的发送和接收数据：" class="headerlink" title="详细的发送和接收数据："></a>详细的发送和接收数据：</h1><h2 id="1、主机对从机读数据操作"><a href="#1、主机对从机读数据操作" class="headerlink" title="1、主机对从机读数据操作"></a>1、主机对从机读数据操作</h2><p><strong>主机发送报文格式如下：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">从机地址</th><th style="text-align:center">功能码</th><th style="text-align:center">起始地址（高）</th><th style="text-align:center">起始地址（低）</th><th style="text-align:center">寄存器数量（高）</th><th style="text-align:center">寄存器数量（低）</th><th style="text-align:center">校验</th></tr></thead><tbody><tr><td style="text-align:center">0x01</td><td style="text-align:center">0x03</td><td style="text-align:center">0x00</td><td style="text-align:center">0x01</td><td style="text-align:center">0x00</td><td style="text-align:center">0x01</td><td style="text-align:center">0xD5 0xCA</td></tr></tbody></table></div><p><strong>含义：从地址为0x01的从机的0x0001寄存器开始读取数量为1的数据</strong></p><ul><li><code>0x01</code>:从机地址</li><li><code>0x03</code>: 查询功能码，读取单个指定从机寄存器的数据</li><li><code>0x00 0x01</code>: 要从从机读取数据的寄存器起始地址，表示从从机0x0001开始读取数据</li><li><code>0x00 0x01</code>: 要读取的寄存器数量，表示读取一个寄存器的数据</li><li><code>0XD5 0XCA</code>:  循环冗余校验 CRC</li></ul><p>假设从机<code>0x01</code>的数据如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">寄存器地址</th><th style="text-align:center">数据</th></tr></thead><tbody><tr><td style="text-align:center">0x0000</td><td style="text-align:center">0x0000</td></tr><tr><td style="text-align:center">0x0001</td><td style="text-align:center">0x0017</td></tr><tr><td style="text-align:center">0x0002</td><td style="text-align:center">0x0020</td></tr><tr><td style="text-align:center">0x0003</td><td style="text-align:center">0x0040</td></tr></tbody></table></div><p><strong>那么从机的回复报文格式如下：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">从机地址</th><th style="text-align:center">功能码</th><th style="text-align:center">字节数量</th><th style="text-align:center">数据1（高）</th><th style="text-align:center">数据1（低）</th><th style="text-align:center">校验</th></tr></thead><tbody><tr><td style="text-align:center">0x01</td><td style="text-align:center">0x03</td><td style="text-align:center">0x02</td><td style="text-align:center">0x00</td><td style="text-align:center">0x17</td><td style="text-align:center">0xF8 0x4A</td></tr></tbody></table></div><p><strong>含义</strong>：</p><ul><li><code>0x01</code>：从机的地址</li><li><code>0x03</code>：查询功能，读取从机寄存器的数据</li><li><code>0x02</code>： 返回字节数为2个 一个寄存器2个字节</li><li><code>0x00 0x17</code>：寄存器的值是0017</li><li><code>0xF8 0x4A</code>： 循环冗余校验 CRC</li></ul><h2 id="2、主机对从机写数据操作"><a href="#2、主机对从机写数据操作" class="headerlink" title="2、主机对从机写数据操作"></a>2、主机对从机写数据操作</h2><h4 id="2-1、一次写一个寄存器的数据（0x06）"><a href="#2-1、一次写一个寄存器的数据（0x06）" class="headerlink" title="2.1、一次写一个寄存器的数据（0x06）"></a>2.1、一次写一个寄存器的数据（0x06）</h4><p><strong>主机发送报文格式如下：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">从机地址</th><th style="text-align:center">功能码</th><th style="text-align:center">寄存器地址（高）</th><th style="text-align:center">寄存器地址（低）</th><th style="text-align:center">数据（高）</th><th style="text-align:center">数据（低）</th><th style="text-align:center">校验</th></tr></thead><tbody><tr><td style="text-align:center">0x01</td><td style="text-align:center">0x06</td><td style="text-align:center">0x00</td><td style="text-align:center">0x00</td><td style="text-align:center">0x00</td><td style="text-align:center">0x01</td><td style="text-align:center">0x48 0x0A</td></tr></tbody></table></div><p><strong>含义：在地址为0x01的从机的0x0000寄存器写入数据0x0001</strong></p><ul><li><code>0x01</code>:从机地址</li><li><code>0x06</code>: 写入功能码，在单个指定从机寄存器写入指定数据</li><li><code>0x00 0x00</code>: 要在从机写入数据的寄存器地址，表示在从机0x0000寄存器写入数据</li><li><code>0x00 0x01</code>: 要写入的数据</li><li><code>0x48 0x0A</code>:  循环冗余校验 CRC</li></ul><p><strong>从机回复报文格式：</strong><code>0x06</code>功能码的从机回报文与主机发送的报文是一致的，表示成功写入数据</p><h4 id="2-2、一次写多个寄存器的数据（0x10）"><a href="#2-2、一次写多个寄存器的数据（0x10）" class="headerlink" title="2.2、一次写多个寄存器的数据（0x10）"></a>2.2、一次写多个寄存器的数据（0x10）</h4><p><strong>主机发送报文格式如下：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">从机地址</th><th style="text-align:center">功能码</th><th style="text-align:center">起始地址</th><th>写入数量</th><th style="text-align:center">数据长度</th><th style="text-align:center">数据 1</th><th style="text-align:center">数据2</th><th style="text-align:center">数据3</th><th style="text-align:center">CRC校验</th></tr></thead><tbody><tr><td style="text-align:center">0x01</td><td style="text-align:center">0x10</td><td style="text-align:center">0x0000</td><td>0x00 0x03</td><td style="text-align:center">0x06</td><td style="text-align:center">0x0001</td><td style="text-align:center">0x0002</td><td style="text-align:center">0x0003</td><td style="text-align:center">0x3A 0x81</td></tr></tbody></table></div><p><strong>含义：从地址为0x01的从机的0x0000寄存器开始写入3个数据分别为0x0001、0x0002、0x0003</strong></p><ul><li><code>0x01</code>:从机地址</li><li><code>0x10</code>: 批量写入功能码，从指定从机寄存器开始写入指定数量的数据</li><li><code>0x00 0x00</code>: 开始从从机写入数据的寄存器地址，表示从从机0x0000寄存器开始写入数据</li><li><code>0x00 0x03</code>: 要写入的数据的数量</li><li><code>0x06</code>: 要写入的数据长度 = 要写入的数据数量 * 2</li><li><code>0x0001</code> <code>0x0002</code> <code>0x0003</code>: 要写入的数量</li><li><code>0x3A 0x81</code>:  循环冗余校验 CRC</li></ul><p><strong>从机的回复报文格式如下：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">从机地址</th><th style="text-align:center">功能码</th><th style="text-align:center">起始地址（高）</th><th style="text-align:center">起始地址（低）</th><th style="text-align:center">寄存器数量</th><th style="text-align:center">校验</th></tr></thead><tbody><tr><td style="text-align:center">0x01</td><td style="text-align:center">0x10</td><td style="text-align:center">0x00</td><td style="text-align:center">0x00</td><td style="text-align:center">0x00 0x03</td><td style="text-align:center">0x80 0x08</td></tr></tbody></table></div><p><strong>含义</strong>：</p><ul><li><code>0x01</code>：从机的地址</li><li><code>0x10</code>：批量写入功能码，从指定从机寄存器开始写入指定数量的数据</li><li><code>0x00 0x00</code>：开始从从机写入数据的寄存器地址，表示从从机0x0000寄存器开始写入数据</li><li><code>0x00 0x03</code>：寄存器数量，表示成功写入3个寄存器</li><li><code>0x80 0x08</code>： 循环冗余校验 CRC</li></ul><h1 id="实战示例"><a href="#实战示例" class="headerlink" title="实战示例"></a>实战示例</h1><h4 id="1、Modbus-Poll-amp-Modbus-Slave"><a href="#1、Modbus-Poll-amp-Modbus-Slave" class="headerlink" title="1、Modbus Poll&amp;Modbus Slave"></a>1、Modbus Poll&amp;Modbus Slave</h4><p>在开始写代码之前可以先通过Modbus Poll和Modbus Slave两个软件来模拟实验，首先通过Virtual Serial Port Driver Pro虚拟串口软件创建两个虚拟串口</p><p><img src="虚拟串口.png" alt="虚拟串口"></p><p>之后在Modbus Poll和Modbuus Slave中连接虚拟出来的串口，注意波特率等参数的配置，二者要相同</p><p><img src="ModbusSlave连接配置.png" alt="ModbusSlave连接配置"></p><p>连接成功之后，Modbus Poll会实时的读取Modbus Slave中的全部数据，也可以通过Modbus Poll修改Modbus Slave中的数据，可以通过Modbus Poll工具栏中的放大镜查看具体的报文</p><p><img src="ModbusPoll数据页.png" alt="ModbusPoll数据页"></p><h1 id="2、STM32作为从机，串口调试助手作为主机"><a href="#2、STM32作为从机，串口调试助手作为主机" class="headerlink" title="2、STM32作为从机，串口调试助手作为主机"></a>2、STM32作为从机，串口调试助手作为主机</h1><p>本系统中使用STM32作为从机，串口调试助手作为主机模拟modbus通讯功能效果如下：</p><p><img src="串口助手主机STM32从机.png" alt="串口助手主机STM32从机"></p><p>串口调试助手使用<strong>SSCOM</strong>，这款串口调试助手是我用过串口调试助手中唯一一个带有加ModbusCRC16校验位功能的，用于modbus调试非常舒服，在上图的测试中，使用串口调试助手作为主机向STM32发送了<code>01 03 00 00 00 01 84</code>，其中<code>84 0A</code>为CRC16校验位，是串口调试助手自动加上去的。串口调试助手发送的报文含义为从<strong>地址为0x01</strong>的从机的<strong>0x0000寄存器</strong>开始读取<strong>数量为1</strong>的数据，通过keil的Debug界面可以看到STM32的<code>0x0000</code>寄存器的数据为<code>0x0001</code>，而串口调试助手成功接收到了STM32的应答报文。</p><p>代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief         本机作为从机时， modbus事件处理</span></span><br><span class="line"><span class="comment"> * @param[in]     无</span></span><br><span class="line"><span class="comment"> * @param[out]    无</span></span><br><span class="line"><span class="comment"> * @retval        无</span></span><br><span class="line"><span class="comment"> * @note          无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modbus_slave_event</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> crc, receive_crc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modbus_struct.receive_flag == <span class="number">0</span> || modbus_struct.receive_count &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*!&lt; modbus crc校验 */</span></span><br><span class="line">    crc = modbus_crc16(&amp;modbus_struct.receive_buffer[<span class="number">0</span>]</span><br><span class="line">                      , modbus_struct.receive_count - <span class="number">2</span>);</span><br><span class="line">    receive_crc = modbus_struct.receive_buffer[modbus_struct.receive_count - <span class="number">2</span>] * <span class="number">256</span> </span><br><span class="line">                + modbus_struct.receive_buffer[modbus_struct.receive_count - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (crc == receive_crc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (modbus_struct.receive_buffer[<span class="number">0</span>] == modbus_struct.address)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(modbus_struct.receive_buffer[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x03</span>:</span><br><span class="line">                modbus_slave_function_0x03();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x06</span>:</span><br><span class="line">                modbus_slave_function_0x06();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">                modbus_slave_function_0x10();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modbus_struct.receive_count = <span class="number">0</span>;</span><br><span class="line">    modbus_struct.receive_flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中定义了一个stm32作为从机时候的事件处理函数，接收串口接收的数据，通过CRC校验之后，根据主机发送来的功能码做出响应，以<code>0x03</code>功能码为例，其代码具体如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief         本机作为从机时， modbus 0x03功能码函数</span></span><br><span class="line"><span class="comment"> *                接收主机的数据之后，返回给主机相应数据</span></span><br><span class="line"><span class="comment"> * @param[in]     无</span></span><br><span class="line"><span class="comment"> * @param[out]    无</span></span><br><span class="line"><span class="comment"> * @retval        无</span></span><br><span class="line"><span class="comment"> * @note          无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_slave_function_0x03</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> reg_address, reg_length, crc;</span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    reg_address = modbus_struct.receive_buffer[<span class="number">2</span>] * <span class="number">256</span> </span><br><span class="line">        + modbus_struct.receive_buffer[<span class="number">3</span>]; <span class="comment">/*!&lt; 读取寄存器首地址 */</span></span><br><span class="line">    reg_length = modbus_struct.receive_buffer[<span class="number">4</span>] * <span class="number">256</span> </span><br><span class="line">           + modbus_struct.receive_buffer[<span class="number">5</span>];  <span class="comment">/*!&lt; 读取寄存器个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!&lt; 给主机的应答 */</span></span><br><span class="line">    modbus_struct.send_buffer[i++] = modbus_struct.address;</span><br><span class="line">    modbus_struct.send_buffer[i++] = <span class="number">0x03</span>;</span><br><span class="line">    modbus_struct.send_buffer[i++] = ((reg_length * <span class="number">2</span>) % <span class="number">256</span>);<span class="comment">/*!&lt; 返回字节个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; reg_length; j++) <span class="comment">/*!&lt; 返回主机要读取的数据 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        modbus_struct.send_buffer[i++] = reg[reg_address + j] / <span class="number">256</span>;</span><br><span class="line">        modbus_struct.send_buffer[i++] = reg[reg_address + j] % <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    crc = modbus_crc16(modbus_struct.send_buffer, i); <span class="comment">/*!&lt; 计算CRC校验位 */</span></span><br><span class="line">    modbus_struct.send_buffer[i++] = crc / <span class="number">256</span>;</span><br><span class="line">    modbus_struct.send_buffer[i++] = crc % <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    HAL_UART_Transmit_DMA(&amp;huart1, modbus_struct.send_buffer,i); <span class="comment">/*!&lt; 发送数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、STM32作为主机，Modbus-Slave作为从机"><a href="#3、STM32作为主机，Modbus-Slave作为从机" class="headerlink" title="3、STM32作为主机，Modbus Slave作为从机"></a>3、STM32作为主机，Modbus Slave作为从机</h1><p>本系统中使用STM32作为主机，Modbus Slave作为从机模拟modbus通讯功能效果如下：</p><p><img src="STM32主机ModbusSlave从机.png" alt="STM32主机ModbusSlave从机"></p><p>以功能码<code>0x10</code>为例，在连接成功之后，可以通过keil debug中修改<code>modbus_host_0x10_buffer</code>数组中的数据来改变Modbus Slave中的值</p><p>具体代码实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief         本机作为主机时，modbus 0x10向从机写入多个数据</span></span><br><span class="line"><span class="comment"> * @param[in]     slave:从机地址</span></span><br><span class="line"><span class="comment"> *                start_address:要写入数据的寄存器起始地址</span></span><br><span class="line"><span class="comment"> *                register_num:要写入数据的寄存器数量</span></span><br><span class="line"><span class="comment"> *                data_length:要写入数据的数据长度 = register_num * 2</span></span><br><span class="line"><span class="comment"> *                pbuffer:要写入的数据</span></span><br><span class="line"><span class="comment"> * @param[out]    无</span></span><br><span class="line"><span class="comment"> * @retval        无</span></span><br><span class="line"><span class="comment"> * @note          调用该函数时发送一次数据，之后将host_send_flag置1，之后不再发送</span></span><br><span class="line"><span class="comment"> *                直到接收到从机的应答，将host_send_flag置0，之后可再次发送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modbus_host_weiredata_0x10</span><span class="params">(<span class="type">uint8_t</span> slave, <span class="type">uint16_t</span> start_address, <span class="type">uint16_t</span> register_num, <span class="type">uint8_t</span> data_length, <span class="type">uint8_t</span>* pbuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> crc;</span><br><span class="line">    <span class="keyword">if</span> (modbus_struct.host_send_flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        modbus_struct.slave_address = slave;</span><br><span class="line">        modbus_struct.host_send_buffer[<span class="number">0</span>] = slave;</span><br><span class="line">        modbus_struct.host_send_buffer[<span class="number">1</span>] = <span class="number">0x10</span>;</span><br><span class="line">        modbus_struct.host_send_buffer[<span class="number">2</span>] = start_address / <span class="number">256</span>;</span><br><span class="line">        modbus_struct.host_send_buffer[<span class="number">3</span>] = start_address % <span class="number">256</span>;</span><br><span class="line">        modbus_struct.host_send_buffer[<span class="number">4</span>] = register_num / <span class="number">256</span>;</span><br><span class="line">        modbus_struct.host_send_buffer[<span class="number">5</span>] = register_num % <span class="number">256</span>;</span><br><span class="line">        modbus_struct.host_send_buffer[<span class="number">6</span>] = data_length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data_length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            modbus_struct.host_send_buffer[<span class="number">7</span> + i] = pbuffer[i];</span><br><span class="line">        &#125;</span><br><span class="line">        crc = modbus_crc16(&amp;modbus_struct.host_send_buffer[<span class="number">0</span>], <span class="number">7</span> + data_length);</span><br><span class="line">        modbus_struct.host_send_buffer[<span class="number">7</span> + data_length] = crc / <span class="number">256</span>;</span><br><span class="line">        modbus_struct.host_send_buffer[<span class="number">8</span> + data_length] = crc % <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart1, modbus_struct.host_send_buffer, <span class="number">9</span> + data_length);</span><br><span class="line">        modbus_struct.host_send_flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
            <tag> STM32 </tag>
            
            <tag> UART </tag>
            
            <tag> Modbus </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
